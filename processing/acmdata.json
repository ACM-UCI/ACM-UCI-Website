{
    "Fall 2018": [
        null,
        [
            null,
            {
                "Code": "// link is https://leetcode.com/problems/reverse-integer/description/\nclass Solution {\npublic:\n    int reverse(int x) {\n        long long res = 0;\n        while(x) {\n            res = res*10 + x%10;\n            x /= 10;\n        }\n        return (res<INT_MIN || res>INT_MAX) ? 0 : res;\n    }\n};\n",
                "Contributor": "timothy4",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/reverse-integer/description/",
                "Name": "Reverse Integer",
                "Note": "",
                "Session": "2",
                "Solution": "reverse_integer.cpp"
            },
            {
                "Code": "//https://www.hackerrank.com/challenges/mini-max-sum/problem\n// Complete the miniMaxSum function below.\nvoid miniMaxSum(vector<int> arr) {\n    long min= arr[0],max = arr[0];\n    long total = 0;\n    for(int i =0; i<arr.size();++i){\n        if (arr[i]<min){\n            min = arr[i];\n        }\n        else if(arr[i]>max){\n            max = arr[i];\n        }\n        total+=arr[i];\n    }\n    cout<<total-max<< \" \"<<total-min<<endl;\n}\n",
                "Contributor": "bwakasa",
                "Difficulty": "easy",
                "Link": "https://www.hackerrank.com/challenges/mini-max-sum/problem",
                "Name": "Mini-max-sum",
                "Note": "",
                "Session": "2",
                "Solution": "min-max-sum.cpp"
            },
            {
                "Code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint M;\nint N;\nint T;\nint dp[10010];\n\nint main(){\n    while (scanf(\"%d %d %d\",&M,&N,&T)==3){\n\n        memset(dp, -1, sizeof(dp));\n\n        dp[M] = 1;\n        dp[N] = 1;\n        dp[0] = 0;\n\n        if (M == 1 || N ==1) {\n            printf(\"%d\n\",T);\n            continue;\n        }\n\n        for(int i=0;i<T;++i)\n            if (dp[i]>=0){\n                if (i+M <= T)\n                    dp[i+M] = max(dp[i+M],dp[i]+1);\n                if (i+N <= T)\n                    dp[i+N] = max(dp[i+N],dp[i]+1);\n            }\n\n        if(dp[T]>=0)\n        {\n            printf(\"%d\n\",dp[T]);\n            continue;\n        }\n\n        for(int i=T-1; i>-1; i--)\n            if(dp[i]>=0)\n            {\n                printf(\"%d %d\n\",dp[i],T-i);\n                break;\n            }\n    }\n\n    return 0;\n}\n",
                "Contributor": "craut",
                "Difficulty": "icpc",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=655&problem=1406",
                "Name": "Homer",
                "Note": "",
                "Session": "2",
                "Solution": "10465(homer).cpp"
            },
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 11100\n\n// Based on (copied) from\n// github.com/lamphanviet/competitive-programming/uva-online-judge/accepted-solutions/11100\n// - The Trip - 2007.cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  scanf(\"%d\n\", &n);\n  while (n > 0) {\n    // Make initial list of bags.\n    vector<int> bags;\n    for (int i = 0; i < n; ++i) {\n      int x;\n      scanf(\"%d\n\", &x);\n      bags.push_back(x);\n    }\n    sort(bags.begin(), bags.end());\n    bags.push_back(-1);\n\n    // The number of sets of bags needed is equal to the maximum number of\n    // one kind of bag. For instance, in the sample input for the problem,\n    // we need 3 sets because we have 3 bags of size 2.\n    int numsets = 0;\n    int tempsize = 1;\n    for (int i = 1; i <= n; ++i) {\n      if (bags[i] != bags[i - 1]) {\n        if (tempsize > numsets) numsets = tempsize;\n        tempsize = 1;\n      } else {\n        ++tempsize;\n      }\n    }\n\n    // Print output for this case -- The bags in each set are determined by\n    // simply going through the input, stepping by numsets each time. This\n    // works because the input is already sorted, so as we go through we\n    // always increase in bag size. We are guaranteed to not have repeated\n    // bag sizes because there are at most numsets bags of each size.\n    printf(\"%d\n\", numsets);\n    for (int i = 0; i < numsets; ++i) {\n      printf(\"%d\", bags[i]);\n      for (int j = i + numsets; j < n; j += numsets) {\n        printf(\" %d\", bags[j]);\n      }\n      putchar('\n');\n    }\n\n    // Get next input\n    scanf(\"%d\n\", &n);\n    if (n > 0) putchar('\n');\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "icpc",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2041",
                "Name": "The Trip",
                "Note": "",
                "Session": "2",
                "Solution": "11100.cpp"
            },
            {
                "Code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n;\n\nint get_max_sub(vector<vector<int> > & grid) {\n    // make cumulative grid\n    int cum[2 * n][2 * n];\n    for (int i = 0; i < 2 *n; ++i) {\n        for (int j = 0; j < 2 * n; ++j) {\n            cum[i][j] = grid[i][j];\n            if (i > 0) cum[i][j] += cum[i - 1][j];\n            if (j > 0) cum[i][j] += cum[i][j - 1];\n            if (i > 0 && j > 0) cum[i][j] -= cum[i - 1][j - 1];\n        }\n    }\n\n    int result = 75 * -100;\n    // starting coordinate\n    for (int a = 0; a < 2 * n; ++a) {\n        for (int b = 0; b < 2 * n; ++b) {\n\n            // ending coordinate\n            for (int x = a; x < 2 * n && x < (a + n); ++x) {\n                for (int y = b; y < 2 * n && y < (b + n); ++y) {\n                    int temp = cum[x][y];\n                    if (a > 0) temp -= cum[a - 1][y];\n                    if (b > 0) temp -= cum[x][b - 1];\n                    if (a > 0 && b > 0) temp += cum[a - 1][b - 1];\n                    result = max(result, temp);\n                }\n            }\n\n        }\n    }\n    return result;\n}\n\nint main () {\n\n    // read input\n    int q; scanf(\"%d\", &q);\n    while (q --> 0) {\n        scanf(\"%d\", &n);\n        vector<vector<int> > grid(2*n, vector<int>(2*n));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                scanf(\"%d\", &grid[i][j]);\n                grid[i][j + n] = grid[i][j];\n                grid[i + n][j] = grid[i][j];\n                grid[i + n][j + n] = grid[i][j];\n\n            }\n        }\n\n        cout << get_max_sub(grid) << endl;\n    }\n    return 0;\n}\n",
                "Contributor": "jtuyls",
                "Difficulty": "icpc",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1768",
                "Name": "Torus",
                "Note": "",
                "Session": "2",
                "Solution": "10827.cpp"
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "icpc",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=611&page=show_problem&problem=3399",
                "Name": "Jollo",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "icpc",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=612&page=show_problem&problem=637",
                "Name": "How Many Knights",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "icpc",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=615&page=show_problem&problem=1886",
                "Name": "Mother Bear",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "icpc",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=615&page=show_problem&problem=2162",
                "Name": "Magic Square",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "icpc",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=617&page=show_problem&problem=97",
                "Name": "Traffic Lights",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "icpc",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=618&page=show_problem&problem=549",
                "Name": "Counterfeit Dollar",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "icpc",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=618&page=show_problem&problem=3502",
                "Name": "Consanguine Calculations",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "icpc",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=620&page=show_problem&problem=3212",
                "Name": "All Integer Average",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "icpc",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=620&page=show_problem&problem=3237",
                "Name": "Mobile Casanova",
                "Note": "",
                "Session": "2",
                "Solution": ""
            }
        ],
        [
            null,
            {
                "Code": "class Solution {\npublic:\n        int coinChange(vector<int>& coins, int amount) {\n        int Max = amount + 1;\n        int coinlen = coins.size();\n        vector<int> dp(amount + 1, Max);\n        dp[0] = 0;\n        for (int i = 0; i < amount + 1; ++i)\n        {\n            for (int j = 0; j < coinlen; ++j)\n            {\n                if(coins[j] <= i)\n                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n\n    }\n};\n",
                "Contributor": "timothy4",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/coin-change/description/",
                "Name": "Coin Change",
                "Note": "",
                "Session": "1",
                "Solution": "coin_change.cpp"
            },
            {
                "Code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def flatten(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        stack = []\n        if root:\n            if root.right:\n                stack.append(root.right)\n            if root.left:\n                stack.append(root.left)\n            curr = root\n\n            while stack:\n                temp = stack.pop()\n                curr.right = temp\n                curr.left = None\n\n                if temp:\n                    if temp.right:\n                        stack.append(temp.right)\n                    if temp.left:\n                        stack.append(temp.left)\n\n                curr = temp\n",
                "Contributor": "amourady",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/",
                "Name": "Flatten Binary Tree",
                "Note": "",
                "Session": "1",
                "Solution": "flatten_tree_to_list.py"
            },
            {
                "Code": "def convert_binary(n):\n    a = str(bin(n))\n    return a[2:]\n\n\n\n\ndef compute_tree(decisions):\n    p = 1\n    q = 1\n    for i in decisions[1:]:\n        if i == '1':\n            q = p + q\n        else:\n            p = p+q\n\n\n    return (p,q)\n\n\nT = int(input())\nfor _ in range(T):\n    b = [int(i) for i in input().split()]\n    decisions = convert_binary(b[1])\n    val = compute_tree(decisions)\n    print(b[0], str(val[1]) + \"/\" + str(val[0]))\n",
                "Contributor": "kgajulap",
                "Difficulty": "easy",
                "Link": "https://open.kattis.com/problems/rationalsequence3",
                "Name": "Rational Sequence",
                "Note": "",
                "Session": "1",
                "Solution": "rational.py"
            },
            {
                "Code": "#include <iostream>\n#include <tuple>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint main () {\n    int q; scanf(\"%d\", &q);\n    while (q --> 0) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n        vector<tuple<int, int, int> > edges;\n        for (int i = 0; i < m; ++i) {\n            int a, b, w;\n            scanf(\"%d %d %d\", &a, &b, &w);\n            edges.push_back(make_tuple(a, b, w));\n        }\n\n        // Bellman - Ford\n        int distance[n];\n        for (int i = 0; i < n; ++i) {\n            distance[i] = INFINITY;\n        }\n        distance[0] = 0;\n\n        for (int i = 0; i < n - 1; ++i) {\n            for (auto e: edges) {\n                int a, b, w;\n                tie(a, b, w) = e;\n                distance[b] = min(distance[b], distance[a] + w);\n            }\n        }\n\n        // check for negative cycle\n        bool isNegativeCylce = false;\n        for (auto e: edges) {\n            int a, b, w;\n            tie(a, b, w) = e;\n            if (distance[a] + w < distance[b]) {\n                cout << \"possible\" << endl;\n                isNegativeCylce = true;\n                break;\n            }\n        }\n\n        if (!isNegativeCylce) cout << \"not possible\" << endl;\n\n    }\n    return 0;\n}\n",
                "Contributor": "jtuyls",
                "Difficulty": "med",
                "Link": "https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=499",
                "Name": "Wormholes",
                "Note": "",
                "Session": "1",
                "Solution": "558.cpp"
            },
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 11729\n#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\n#define FORe(i, a, b) for (int i = a; i <= b; ++i)\n#define PAI(arr, len) /*Print array of integers*/ \\n  {                                               \\n    for (int _i = 0; _i < len; ++_i) {            \\n      if (_i != len - 1) {                        \\n        printf(\"%d \", arr[_i]);                   \\n      } else {                                    \\n        printf(\"%d\", arr[_i]);                    \\n      }                                           \\n    }                                             \\n    putchar('\n');                                \\n  }\n#define PBS(n, len) /*Print a bitset*/ \\n  {                                    \\n    for (int _i = 0; _i < len; ++_i) { \\n      putchar(n % 2 + '0');            \\n      n /= 2;                          \\n    }                                  \\n    putchar('\n');                     \\n  }\n#define GET(x) scanf(\"%d\", &x)\n#define PLN putchar('\n')\ntypedef long long ll;\nusing namespace std;\n\n// first: briefing time\n// second: job time\npair<int, int> sd[1010];\n\n// Compare by seeing which scenario would take longer - having a or b go first.\n// If a has briefing and job time b1 and j1, and b has b2 and j2, then the time\n// with a first is b1 + max(j1, b2 + j2). The time if b goes first is b2 +\n// max(j2, b1 + j1). If a's time is less than b's time, a goes first and vice\n// versa.\nbool compare(pair<int, int> a, pair<int, int> b) {\n  int t_a = a.first + max(a.second, b.first + b.second);\n  int t_b = b.first + max(b.second, a.first + a.second);\n  return t_a < t_b;\n}\n\nint main() {\n  int n;\n  for (int ca = 1; GET(n) && n; ++ca) {\n    FOR(i, 0, n) {\n      GET(sd[i].first);\n      GET(sd[i].second);\n    }\n\n    // Sort as described above\n    sort(sd, sd + n, compare);\n\n    // Calculate total time - tot keeps track of briefing times covered so far,\n    // and fin keeps track of last time when job finishes.\n    int tot = 0;\n    int fin = 0;\n    FOR(i, 0, n) {\n      tot += sd[i].first;\n      fin = max(fin, tot + sd[i].second);\n    }\n    tot = fin;\n\n    // output\n    printf(\"Case %d: %d\n\", ca, tot);\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=658&page=show_problem&problem=2829",
                "Name": "Commando War",
                "Note": "",
                "Session": "1",
                "Solution": "uva11729.cpp"
            },
            {
                "Code": "import collections\n\ndef str_reduction(a):\n    count = 0\n    map = collections.Counter(a)\n    #print([map['a'],map['b'],map['c']])\n    ls = sorted([map['a'],map['b'],map['c']])\n    count = recursive_reduce(ls)\n    return count\n\ndef recursive_reduce(list):\n    if list[0] <= 0 and list[1] <= 0:\n        return list[-1]\n    else:\n        list[-1]-=1\n        list[1]-=1\n        list[0]+=1\n        return recursive_reduce(sorted(list))\n\nfor i in range(int(input())):\n    a = input()\n    print(str_reduction(a))\n\n",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://www.hackerrank.com/challenges/string-reduction/problem",
                "Name": "String Reduction",
                "Note": "",
                "Session": "1",
                "Solution": "StringReduction.py"
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "announcement",
                "Link": "If you're interested in ICPC make sure to fill out the form and watch out for updates on facebook page",
                "Name": "ICPC",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "announcement",
                "Link": "IEEExtreme is on next Friday",
                "Name": "IEEEXtreme",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "#include <iostream>\n#include <tuple>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint main () {\n    int q; scanf(\"%d\", &q);\n    while (q --> 0) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n        vector<tuple<int, int, int> > edges;\n        for (int i = 0; i < m; ++i) {\n            int a, b, w;\n            scanf(\"%d %d %d\", &a, &b, &w);\n            edges.push_back(make_tuple(a, b, w));\n        }\n\n        // Bellman - Ford\n        int distance[n];\n        for (int i = 0; i < n; ++i) {\n            distance[i] = INFINITY;\n        }\n        distance[0] = 0;\n\n        for (int i = 0; i < n - 1; ++i) {\n            for (auto e: edges) {\n                int a, b, w;\n                tie(a, b, w) = e;\n                distance[b] = min(distance[b], distance[a] + w);\n            }\n        }\n\n        // check for negative cycle\n        bool isNegativeCylce = false;\n        for (auto e: edges) {\n            int a, b, w;\n            tie(a, b, w) = e;\n            if (distance[a] + w < distance[b]) {\n                cout << \"possible\" << endl;\n                isNegativeCylce = true;\n                break;\n            }\n        }\n\n        if (!isNegativeCylce) cout << \"not possible\" << endl;\n\n    }\n    return 0;\n}\n",
                "Contributor": "jtuyls",
                "Difficulty": "med",
                "Link": "https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=499",
                "Name": "Wormholes",
                "Note": "",
                "Session": "2",
                "Solution": "558.cpp"
            },
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 11729\n#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\n#define FORe(i, a, b) for (int i = a; i <= b; ++i)\n#define PAI(arr, len) /*Print array of integers*/ \\n  {                                               \\n    for (int _i = 0; _i < len; ++_i) {            \\n      if (_i != len - 1) {                        \\n        printf(\"%d \", arr[_i]);                   \\n      } else {                                    \\n        printf(\"%d\", arr[_i]);                    \\n      }                                           \\n    }                                             \\n    putchar('\n');                                \\n  }\n#define PBS(n, len) /*Print a bitset*/ \\n  {                                    \\n    for (int _i = 0; _i < len; ++_i) { \\n      putchar(n % 2 + '0');            \\n      n /= 2;                          \\n    }                                  \\n    putchar('\n');                     \\n  }\n#define GET(x) scanf(\"%d\", &x)\n#define PLN putchar('\n')\ntypedef long long ll;\nusing namespace std;\n\n// first: briefing time\n// second: job time\npair<int, int> sd[1010];\n\n// Compare by seeing which scenario would take longer - having a or b go first.\n// If a has briefing and job time b1 and j1, and b has b2 and j2, then the time\n// with a first is b1 + max(j1, b2 + j2). The time if b goes first is b2 +\n// max(j2, b1 + j1). If a's time is less than b's time, a goes first and vice\n// versa.\nbool compare(pair<int, int> a, pair<int, int> b) {\n  int t_a = a.first + max(a.second, b.first + b.second);\n  int t_b = b.first + max(b.second, a.first + a.second);\n  return t_a < t_b;\n}\n\nint main() {\n  int n;\n  for (int ca = 1; GET(n) && n; ++ca) {\n    FOR(i, 0, n) {\n      GET(sd[i].first);\n      GET(sd[i].second);\n    }\n\n    // Sort as described above\n    sort(sd, sd + n, compare);\n\n    // Calculate total time - tot keeps track of briefing times covered so far,\n    // and fin keeps track of last time when job finishes.\n    int tot = 0;\n    int fin = 0;\n    FOR(i, 0, n) {\n      tot += sd[i].first;\n      fin = max(fin, tot + sd[i].second);\n    }\n    tot = fin;\n\n    // output\n    printf(\"Case %d: %d\n\", ca, tot);\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=658&page=show_problem&problem=2829",
                "Name": "Commando War",
                "Note": "",
                "Session": "2",
                "Solution": "uva11729.cpp"
            },
            {
                "Code": "import collections\n\ndef str_reduction(a):\n    count = 0\n    map = collections.Counter(a)\n    #print([map['a'],map['b'],map['c']])\n    ls = sorted([map['a'],map['b'],map['c']])\n    count = recursive_reduce(ls)\n    return count\n\ndef recursive_reduce(list):\n    if list[0] <= 0 and list[1] <= 0:\n        return list[-1]\n    else:\n        list[-1]-=1\n        list[1]-=1\n        list[0]+=1\n        return recursive_reduce(sorted(list))\n\nfor i in range(int(input())):\n    a = input()\n    print(str_reduction(a))\n\n",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://www.hackerrank.com/challenges/string-reduction/problem",
                "Name": "String Reduction",
                "Note": "",
                "Session": "2",
                "Solution": "StringReduction.py"
            },
            {
                "Code": "def magic(pancakes, k):\n    bool_panck = []\n    for i in pancakes:\n        if i == '+':\n            bool_panck.append(1)\n        else:\n            bool_panck.append(0)\n    opt = [1 for i in range(len(bool_panck))]\n    ctr = 0\n\n    while(bool_panck != opt):\n        ctr += 1\n        index = 0\n        while bool_panck[index] == 1:\n            index += 1\n\n        if index + k > len(bool_panck):\n            return -1\n\n        else:\n            for i in range(k):\n                bool_panck[index + i] = 1 -bool_panck[index+i]\n\n    return ctr\n\n\nn = int(input())\nfor i in range(1,n+1):\n    a = input().rstrip().split()\n    pancakes = a[0]\n    k = int(a[1])\n\n    val = magic(pancakes, k)\n    if val == -1:\n        val = \"IMPOSSIBLE\"\n    else:\n        val = str(val)\n    print(\"Case #\" + str(i) + \": \" + val)\n",
                "Contributor": "kgajulap",
                "Difficulty": "codealong",
                "Link": "https://code.google.com/codejam/contest/3264486/dashboard",
                "Name": "Oversized Pancake Flipper",
                "Note": "",
                "Session": "2",
                "Solution": "pancake_flipper.py"
            },
            {
                "Code": "// Complete the compareTriplets function below.\n//https://www.hackerrank.com/challenges/compare-the-triplets/problem\nvector<int> compareTriplets(vector<int> a, vector<int> b) {\n    int alice, bob;\n    vector<int>result;\n    alice = bob = 0;\n    for(int i = 0; i<a.size();++i){\n        if (a[i]>b[i]){\n            ++alice;\n        }\n        else if(b[i]>a[i]){\n            ++bob;\n        }\n    }\n    result.push_back(alice);\n    result.push_back(bob);\n    return result;\n}\n",
                "Contributor": "bwakasa",
                "Difficulty": "easy",
                "Link": "https://www.hackerrank.com/challenges/compare-the-triplets/problem",
                "Name": "Compare the Triplets",
                "Note": "",
                "Session": "2",
                "Solution": "comp_trip.cpp"
            },
            {
                "Code": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        s_nums = set(nums)\n        count = 1\n        while True:\n            if count in s_nums:\n                count += 1\n            else: return count\n",
                "Contributor": "amourady",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/first-missing-positive/description/",
                "Name": "First Missing Positive",
                "Note": "",
                "Session": "2",
                "Solution": "first_missing_positive.py"
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "icpc",
                "Link": "https://open.kattis.com/problem-sources/2015%20I3CPC%20East-Central%20NA%20Regional%20Contest ",
                "Name": "ICPC Problemset",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "announcement",
                "Link": "If you want to participate in ICPC make sure you are up to date with posts on Facebook group",
                "Name": "ICPC",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "announcement",
                "Link": "IEEExtreme is on the 19th",
                "Name": "IEEExtreme",
                "Note": "",
                "Session": "2",
                "Solution": ""
            }
        ],
        [
            null,
            {
                "Code": "",
                "Contributor": "craut",
                "Difficulty": "codealong",
                "Link": "https://www.hackerrank.com/challenges/sherlock-and-array/problem?h_r=next-challenge&h_v=legacy",
                "Name": "Sherlock and Array",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "a = [int(i) for i in input().rstrip().split()]\nn = a[0]\nk  = a[1]\n\nc = [int(i) for i in input().rstrip().split()]\n\nc.sort()\nc = c[::-1]\ns = 0\nfor i in range(n):\n    s += (int(i/k) + 1)* c[i]\nprint(s)\n",
                "Contributor": "kgajulap",
                "Difficulty": "easy",
                "Link": "https://www.hackerrank.com/challenges/greedy-florist/problem ",
                "Name": "Greedy Florist",
                "Note": "",
                "Session": "1",
                "Solution": "florist.py"
            },
            {
                "Code": "class Solution:\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        begin = len(gas)-1\n        finish = 0\n\n        total = gas[begin]-cost[begin]\n        while(begin>finish):\n            if(total>=0):\n                total+=gas[finish]-cost[finish]\n                finish+=1\n            else:\n                begin-=1\n                total+=gas[begin] -cost[begin]\n\n        if total>=0:\n            return begin\n        else:\n            return -1\n",
                "Contributor": "bwakasa",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/gas-station/description/",
                "Name": "Gas Station",
                "Note": "",
                "Session": "1",
                "Solution": "gas_station.py"
            },
            {
                "Code": "### bandit problem solution python\n\n\ndef factorial(n):\n    f = 1\n    for i in range(1,n+1):\n        f*= i\n\n    return f\n\n\ndef combinations(n,k):\n    return int(factorial(n)/(factorial(k)*factorial(n-k)))\n\n\n\ndef magic(n,m):\n    return (combinations(n,m-1), int((n-m+1)*combinations(n,m-1)/n))\n\n\ntest = int(input())\nfor i in range(test):\n    a= [int(i) for i in input().split()]\n    result = magic(a[0], a[1])\n\n    print(result[0],\n          result[1])\n",
                "Contributor": "kgajulap",
                "Difficulty": "med",
                "Link": "http://socalcontest.org/history/2014/socal2014.pdf",
                "Name": "Locked Treasure",
                "Note": "",
                "Session": "1",
                "Solution": "bandits.py"
            },
            {
                "Code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint M;\nint S;\n\nint main(){\n    scanf(\"%d %d\",&M,&S);\n    int pref[M][S];\n    int wrst_song_rnk[S];\n    int songs_to_play[S];\n    memset(songs_to_play,0,sizeof(songs_to_play));\n    memset(wrst_song_rnk,-1,sizeof(wrst_song_rnk));\n\n    for (int m=0;m<M;++m){\n        for (int s=0;s<S;++s){\n            scanf(\"%d\",&pref[m][s]);\n            wrst_song_rnk[pref[m][s]-1] = max(wrst_song_rnk[pref[m][s]-1],s);\n        }\n    }\n\n    int num_songs = 1;\n\n    for(int cur_col=0;cur_col<num_songs;++cur_col){\n        for(int m=0;m<M;++m){\n            int song = pref[m][cur_col];\n            songs_to_play[song-1]=1;\n            num_songs = max(num_songs,wrst_song_rnk[song-1]+1);\n        }\n    }\n\n    printf(\"%d\n\",num_songs);\n\n    for(int i=0;i<S;++i)\n        if (songs_to_play[i])\n            printf(\"%d \",i+1);\n    printf(\"\n\");\n\n    return 0;\n}\n",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/rockband",
                "Name": "Rockband",
                "Note": "",
                "Session": "1",
                "Solution": "rockband.cpp"
            },
            {
                "Code": "#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\nfrom itertools import accumulate\n\ndef maximumSum(a, m):\n\n    # logic: \"it looks simple but it's pretty complicated...\"\n    # know that finding the sum subarrays is equiv to pref[j]-pref[i] for j>i\n    # finding the max(pref[j]-pref[i])%m is equivalent to finding the pref[i]-pref[j] that is the smallest\n    # Proof:\n    # (pref[j]-pref[i]+M)%M == (M - -1*(pref[j]-pref[i]))%M == (M-(pref[i]-pref[j]))%M\n    # sorting the arr puts elements close to each other next to each other -> best way to min difference\n\n    modm = lambda x:x%m\n    cur_max = max(map(modm,a))\n    # construct the prefix arr\n    cum_sum = list(map(modm,accumulate(a)))\n    cur_max = max(cur_max,max(cum_sum))\n    # sorted by values 1st then index as mod m keeps the prefix arr no longer in sorted order\n    pref = sorted(enumerate(cum_sum),key=lambda x:(x[1],x[0]))\n    minimum = m\n\n    for i in range(1, len(a)): #determine the minimum\n        if pref[i-1][0] > pref[i][0] and (pref[i][1] - pref[i-1][1] < minimum):\n            minimum = pref[i][1] - pref[i-1][1]\n    return max(cur_max,m-minimum)\n\n\n\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    q = int(input())\n\n    for q_itr in range(q):\n        nm = input().split()\n\n        n = int(nm[0])\n\n        m = int(nm[1])\n\n        a = list(map(int, input().rstrip().split()))\n\n        result = maximumSum(a, m)\n\n        fptr.write(str(result) + '\n')\n\n    fptr.close()\n",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://www.hackerrank.com/challenges/maximum-subarray-sum/problem",
                "Name": "Max Subarray Sum",
                "Note": "",
                "Session": "1",
                "Solution": "max_subarray_sum.py"
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "announcement",
                "Link": "Congrats to those who made it to the ICPC regionals. If you have questions come and talk to me.",
                "Name": "ICPC",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "announcement",
                "Link": "IF ALL OF THIS IS TOO EASY COME UP AND I CAN TRY GIVING YOU A PROBLEM OR ASK CHINMAY TO GIVE YOU A PROBLEM",
                "Name": "Note",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "### bandit problem solution python\n\n\ndef factorial(n):\n    f = 1\n    for i in range(1,n+1):\n        f*= i\n\n    return f\n\n\ndef combinations(n,k):\n    return int(factorial(n)/(factorial(k)*factorial(n-k)))\n\n\n\ndef magic(n,m):\n    return (combinations(n,m-1), int((n-m+1)*combinations(n,m-1)/n))\n\n\ntest = int(input())\nfor i in range(test):\n    a= [int(i) for i in input().split()]\n    result = magic(a[0], a[1])\n\n    print(result[0],\n          result[1])\n",
                "Contributor": "kgajulap",
                "Difficulty": "med",
                "Link": "http://socalcontest.org/history/2014/socal2014.pdf",
                "Name": "Locked Treasure",
                "Note": "",
                "Session": "2",
                "Solution": "bandits.py"
            },
            {
                "Code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint M;\nint S;\n\nint main(){\n    scanf(\"%d %d\",&M,&S);\n    int pref[M][S];\n    int wrst_song_rnk[S];\n    int songs_to_play[S];\n    memset(songs_to_play,0,sizeof(songs_to_play));\n    memset(wrst_song_rnk,-1,sizeof(wrst_song_rnk));\n\n    for (int m=0;m<M;++m){\n        for (int s=0;s<S;++s){\n            scanf(\"%d\",&pref[m][s]);\n            wrst_song_rnk[pref[m][s]-1] = max(wrst_song_rnk[pref[m][s]-1],s);\n        }\n    }\n\n    int num_songs = 1;\n\n    for(int cur_col=0;cur_col<num_songs;++cur_col){\n        for(int m=0;m<M;++m){\n            int song = pref[m][cur_col];\n            songs_to_play[song-1]=1;\n            num_songs = max(num_songs,wrst_song_rnk[song-1]+1);\n        }\n    }\n\n    printf(\"%d\n\",num_songs);\n\n    for(int i=0;i<S;++i)\n        if (songs_to_play[i])\n            printf(\"%d \",i+1);\n    printf(\"\n\");\n\n    return 0;\n}\n",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/rockband",
                "Name": "Rockband",
                "Note": "",
                "Session": "2",
                "Solution": "rockband.cpp"
            },
            {
                "Code": "#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\nfrom itertools import accumulate\n\ndef maximumSum(a, m):\n\n    # logic: \"it looks simple but it's pretty complicated...\"\n    # know that finding the sum subarrays is equiv to pref[j]-pref[i] for j>i\n    # finding the max(pref[j]-pref[i])%m is equivalent to finding the pref[i]-pref[j] that is the smallest\n    # Proof:\n    # (pref[j]-pref[i]+M)%M == (M - -1*(pref[j]-pref[i]))%M == (M-(pref[i]-pref[j]))%M\n    # sorting the arr puts elements close to each other next to each other -> best way to min difference\n\n    modm = lambda x:x%m\n    cur_max = max(map(modm,a))\n    # construct the prefix arr\n    cum_sum = list(map(modm,accumulate(a)))\n    cur_max = max(cur_max,max(cum_sum))\n    # sorted by values 1st then index as mod m keeps the prefix arr no longer in sorted order\n    pref = sorted(enumerate(cum_sum),key=lambda x:(x[1],x[0]))\n    minimum = m\n\n    for i in range(1, len(a)): #determine the minimum\n        if pref[i-1][0] > pref[i][0] and (pref[i][1] - pref[i-1][1] < minimum):\n            minimum = pref[i][1] - pref[i-1][1]\n    return max(cur_max,m-minimum)\n\n\n\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    q = int(input())\n\n    for q_itr in range(q):\n        nm = input().split()\n\n        n = int(nm[0])\n\n        m = int(nm[1])\n\n        a = list(map(int, input().rstrip().split()))\n\n        result = maximumSum(a, m)\n\n        fptr.write(str(result) + '\n')\n\n    fptr.close()\n",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://www.hackerrank.com/challenges/maximum-subarray-sum/problem",
                "Name": "Max Subarray Sum",
                "Note": "",
                "Session": "2",
                "Solution": "max_subarray_sum.py"
            },
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 11729\n#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\n#define FORe(i, a, b) for (int i = a; i <= b; ++i)\n#define PAI(arr, len) /*Print array of integers*/ \\n  {                                               \\n    for (int _i = 0; _i < len; ++_i) {            \\n      if (_i != len - 1) {                        \\n        printf(\"%d \", arr[_i]);                   \\n      } else {                                    \\n        printf(\"%d\", arr[_i]);                    \\n      }                                           \\n    }                                             \\n    putchar('\n');                                \\n  }\n#define PBS(n, len) /*Print a bitset*/ \\n  {                                    \\n    for (int _i = 0; _i < len; ++_i) { \\n      putchar(n % 2 + '0');            \\n      n /= 2;                          \\n    }                                  \\n    putchar('\n');                     \\n  }\n#define GET(x) scanf(\"%d\", &x)\n#define PLN putchar('\n')\ntypedef long long ll;\nusing namespace std;\n\n// first: briefing time\n// second: job time\npair<int, int> sd[1010];\n\n// Compare by seeing which scenario would take longer - having a or b go first.\n// If a has briefing and job time b1 and j1, and b has b2 and j2, then the time\n// with a first is b1 + max(j1, b2 + j2). The time if b goes first is b2 +\n// max(j2, b1 + j1). If a's time is less than b's time, a goes first and vice\n// versa.\nbool compare(pair<int, int> a, pair<int, int> b) {\n  int t_a = a.first + max(a.second, b.first + b.second);\n  int t_b = b.first + max(b.second, a.first + a.second);\n  return t_a < t_b;\n}\n\nint main() {\n  int n;\n  for (int ca = 1; GET(n) && n; ++ca) {\n    FOR(i, 0, n) {\n      GET(sd[i].first);\n      GET(sd[i].second);\n    }\n\n    // Sort as described above\n    sort(sd, sd + n, compare);\n\n    // Calculate total time - tot keeps track of briefing times covered so far,\n    // and fin keeps track of last time when job finishes.\n    int tot = 0;\n    int fin = 0;\n    FOR(i, 0, n) {\n      tot += sd[i].first;\n      fin = max(fin, tot + sd[i].second);\n    }\n    tot = fin;\n\n    // output\n    printf(\"Case %d: %d\n\", ca, tot);\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "codealong",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2829",
                "Name": "Commando War",
                "Note": "",
                "Session": "2",
                "Solution": "uva11729.cpp"
            },
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 11100\n\n// Based on (copied) from\n// github.com/lamphanviet/competitive-programming/uva-online-judge/accepted-solutions/11100\n// - The Trip - 2007.cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  scanf(\"%d\n\", &n);\n  while (n > 0) {\n    // Make initial list of bags.\n    vector<int> bags;\n    for (int i = 0; i < n; ++i) {\n      int x;\n      scanf(\"%d\n\", &x);\n      bags.push_back(x);\n    }\n    sort(bags.begin(), bags.end());\n    bags.push_back(-1);\n\n    // The number of sets of bags needed is equal to the maximum number of\n    // one kind of bag. For instance, in the sample input for the problem,\n    // we need 3 sets because we have 3 bags of size 2.\n    int numsets = 0;\n    int tempsize = 1;\n    for (int i = 1; i <= n; ++i) {\n      if (bags[i] != bags[i - 1]) {\n        if (tempsize > numsets) numsets = tempsize;\n        tempsize = 1;\n      } else {\n        ++tempsize;\n      }\n    }\n\n    // Print output for this case -- The bags in each set are determined by\n    // simply going through the input, stepping by numsets each time. This\n    // works because the input is already sorted, so as we go through we\n    // always increase in bag size. We are guaranteed to not have repeated\n    // bag sizes because there are at most numsets bags of each size.\n    printf(\"%d\n\", numsets);\n    for (int i = 0; i < numsets; ++i) {\n      printf(\"%d\", bags[i]);\n      for (int j = i + numsets; j < n; j += numsets) {\n        printf(\" %d\", bags[j]);\n      }\n      putchar('\n');\n    }\n\n    // Get next input\n    scanf(\"%d\n\", &n);\n    if (n > 0) putchar('\n');\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "easy",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2041",
                "Name": "The Trip",
                "Note": "",
                "Session": "2",
                "Solution": "11100.cpp"
            },
            {
                "Code": "'''\n    Algorithm category: Binary search + greedy\n    Problem explaination: Using O(n^2) solution would lead to getting a TLE(Time\n    limit exceeded) error by comparing each P with the rest of P.\n    However, it is not hard to test if 100, for example, is one of the solutions(may\n    not be the optimal one). if 100 can not be one of the solution, how about 100/2?\n    This intuition give us a clue to use binary search on the answer and use\n    greedy algorithm to check if this answer is correct or not\n    Side Note: The online judge accept my Pyhton 2.7 solution but give TLE error\n    for my Python3's. There are places in this solution that can be optimized.\n    Try to come up and pass the online judge using Python3 if interested.\n'''\ndef solve(field,size,answer):\n    star_pos = -1\n    p_pos = -1\n    for i in range(size):\n        #print(p_pos,star_pos)\n        if field[i] == \"*\":\n            if star_pos != -1:\n                if p_pos != -1:\n                    if star_pos < p_pos and i > p_pos: #*...P.*.* star on both side of P\n                        if min(2*(p_pos-star_pos)+(i-p_pos),2*(i-p_pos)+\\n                               (p_pos-star_pos)) > answer:\n                            star_pos = i\n                            p_pos = -1\n                            continue\n                    elif i-p_pos > answer: #..P..*P when star on the right of P\n                        star_pos = i\n                        p_pos = -1\n                        continue\n            else:\n                if p_pos != -1: #P..*.P\n                    if i - p_pos > answer:\n                        p_pos = -1\n                star_pos = i\n\n        if field[i] == \"P\":\n            if p_pos != -1:\n                star_pos = -1\n            if star_pos != -1:\n                #print(\"star_pos:\",star_pos,\"current pos\",i)\n                if i - star_pos > answer:\n                    return -1\n            p_pos = i\n\n    if p_pos == -1:\n        return -1\n    return 1\n\n\n\n\nif __name__ == \"__main__\":\n    size = int(input().strip()) #Change this statement in to int(raw_input().strip()) in Python 2.7\n    field = input().strip() # Change this statement into raw_input().strip() in Python 2.7\n    first = 1\n    last = 2*size\n    best = last + 1\n    while first <= last:\n        mid = int(first + (last - first)/2)\n        if solve(field,size,mid) == -1:\n            first = mid + 1\n        else:\n            best = mid\n            last = mid - 1\n    print(best)\n\n",
                "Contributor": "renjied",
                "Difficulty": "med",
                "Link": "http://codeforces.com/contest/847/problem/E",
                "Name": "Packmen",
                "Note": "",
                "Session": "2",
                "Solution": "cf_packman.py"
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "announcement",
                "Link": "Congrats to those who made it to the ICPC regionals. If you have questions come and talk to me.",
                "Name": "ICPC",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "announcement",
                "Link": "IF ALL OF THIS IS TOO EASY COME UP AND I CAN TRY GIVING YOU A PROBLEM OR ASK CHINMAY TO GIVE YOU A PROBLEM",
                "Name": "Note",
                "Note": "",
                "Session": "2",
                "Solution": ""
            }
        ],
        [
            null,
            {
                "Code": "",
                "Contributor": "renjied",
                "Difficulty": "codealong",
                "Link": "https://codeforces.com/contest/909/problem/B",
                "Name": "Segments",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cmath>\nusing namespace std;\n\nint main () {\n    for (int a = 1; a < 2000; ++a) {\n        if (pow(a, 4)/pow(10, 6) > 2000) break;\n        for (int b = a; b < 2000 - a; ++b) {\n            if (a * pow(b, 3)/pow(10, 6) > 2000) break;\n            for (int c = b; c < 2000 - a - b; ++c) {\n                if (a * b * pow(c, 2)/pow(10, 6) > 2000) break;\n                double d = (pow(10, 6) * (a + b + c)/(a * b * c - pow(10, 6)));\n                if (ceil(d) == floor(d) && d >= c && a + b + c + d <= 2000) {\n                    printf(\"%.2f %.2f %.2f %.2f\n\", a/100.0, b/100.0, c/100.0, d/100.0);\n                }\n            }\n        }\n    }\n    return 0;\n}\n",
                "Contributor": "jtuyls",
                "Difficulty": "easy",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=643&page=show_problem&problem=2177",
                "Name": "Grocery Store",
                "Note": "",
                "Session": "1",
                "Solution": "11236.cpp"
            },
            {
                "Code": "#include <iostream>\n#include <climits>\nusing namespace std;\n\nint main () {\n    int q; scanf(\"%d\", &q);\n    while (q --> 0) {\n        int arr[5][5] = {0};\n        int valid[5][5] = {0};\n\n        int n; scanf(\"%d\", &n);\n        for (int i = 0; i < n; ++i) {\n            int row, col, val;\n            scanf(\"%d %d %d\", &row, &col, &val);\n            arr[row][col] = val;\n        }\n\n        long long best_dist = LLONG_MAX;\n        int result[5] = {0, 1, 2, 3, 4};\n        for (int i = 0; i < 25; ++i) {\n            for (int j = i + 1; j < 25; ++j) {\n                for (int x = j + 1; x < 25; ++x) {\n                    for (int y = x + 1; y < 25; ++y) {\n                        for (int z = y + 1; z < 25; ++z) {\n                            long long total_dist = 0;\n                            pair<int, int> offices[5] = { make_pair(i/5, i % 5), make_pair(j/5, j % 5), make_pair(x/5, x % 5), make_pair(y/5, y % 5), make_pair(z/5, z % 5) };\n                            for (int k = 0; k < 25; ++k) {\n                                int min_dist = INT_MAX;\n                                int row = k / 5;\n                                int col = k % 5;\n                                // loop through 5 offices\n                                for (int r = 0; r < 5; ++r) {\n                                    min_dist = min(min_dist, (abs(row - offices[r].first) + abs(col - offices[r].second)) * arr[row][col]);\n                                }\n                                total_dist += min_dist;\n                            }\n                            if (total_dist < best_dist) {\n                                best_dist = total_dist;\n                                result[0] = i;\n                                result[1] = j;\n                                result[2] = x;\n                                result[3] = y;\n                                result[4] = z;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        cout << result[0] << \" \" << result[1] << \" \" << result[2] << \" \" << result[3] << \" \" << result[4] << endl;\n    }\n    return 0;\n}\n",
                "Contributor": "jtuyls",
                "Difficulty": "easy",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=643&page=show_problem&problem=1601",
                "Name": "Citizen Attention Offices",
                "Note": "",
                "Session": "1",
                "Solution": "10660.cpp"
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "easy",
                "Link": "https://open.kattis.com/problems/permutationdescent",
                "Name": "Permutation Descent Counts",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "//Problem @ http://codeforces.com/problemset/problem/1051/D\n//#dp\n#include<iostream>\nusing namespace std;\n#define ll long long\nconst int M = 998244353;\nll BBWW[1005][2018]; //BBWW[row#][# of components] = # of ways w/ bb or ww as last col\nll BWWB[1005][2018]; //BWWB[row#][# of components] = # of ways w/ bw or wb as last col\nint main(){\n    int n,k;\n    cin >> n >> k;\n    BBWW[1][1] = 2; //having 1 column with 1 compent has two options, either bb or ww\n    BWWB[1][2] = 2; // having 1 column with 2 compoent is only possible with bw or wb\n\n    for(int col = 2; col <= n; col++){\n        for(int j = 1; j <= 2*col; j++){ //2*col is the maximum number of components\n            //BBWW can only have BB or WW as last column.\n            //  so adding BB or WW to a BBWW can either increase the components by 1\n            //  or don't change the number of components.\n            //Adding BB or WW to a BWWB will always increase the # of comps by 1\n            //  hence, 2 options for every BWWB\n            BBWW[col][j] = (BBWW[col - 1][j - 1] + BBWW[col - 1][j] + 2* BWWB[col - 1][j]) % M;\n\n            //BWWB can only have BW or WB as the last column\n            //Adding BB or WW will increase the # of comps by 1\n            //Adding WB or BW can either increase the # of comps by 2 or none\n            BWWB[col][j] = (BWWB[col - 1][j] + BWWB[col - 1][j -2] + 2 * BBWW[col - 1][j - 1]) % M;\n        }\n    }\n\n    cout<< (BBWW[n][k] + BWWB[n][k]) % M << endl;\n\n    return 0;\n}\n",
                "Contributor": "pooyak",
                "Difficulty": "hard",
                "Link": "http://codeforces.com/problemset/problem/1051/D",
                "Name": "Bicolorings",
                "Note": "",
                "Session": "1",
                "Solution": "cf_1051D.cpp"
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "announcement",
                "Link": "We’ve sent the list of people to Pattis for registration & Meridianlink for the shirts. Be on the lookout.",
                "Name": "ICPC",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "codealong",
                "Link": "https://www.hackerrank.com/challenges/journey-to-the-moon/problem",
                "Name": "Journey to the Moon",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "// https://leetcode.com/problems/first-bad-version/description/\n\n// Forward declaration of isBadVersion API.\nbool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int low = 1, high = n;\n        while (low < high)\n        {\n            int mid =  low + (high - low) / 2;\n            if (isBadVersion(mid))\n                high = mid;\n            else\n                low = mid + 1;\n        }\n        return low;\n    }\n};\n",
                "Contributor": "timothy4",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/first-bad-version/description/ ",
                "Name": "First Bad Version",
                "Note": "",
                "Session": "2",
                "Solution": "First_Bad_Version.cpp"
            },
            {
                "Code": "#include <iostream>\nusing namespace std;\n\nint main () {\n    int k; scanf(\"%d\", &k);\n    while (k != 0) {\n\n        int arr[k];\n        for (int i = 0; i < k; ++i) {\n            scanf(\"%d\", &arr[i]);\n        }\n\n        for (int i = 0; i < k - 5; ++i) {\n            for (int j = i + 1; j < k - 4; ++j) {\n                for (int z = j + 1; z < k - 3; ++z) {\n                    for (int x = z + 1; x < k - 2; ++x) {\n                        for (int y = x + 1; y < k - 1; ++y) {\n                            for (int q = y + 1; q < k; ++q) {\n                                cout << arr[i] << \" \" << arr[j] << \" \" << arr[z] << \" \" << arr[x] << \" \" << arr[y] << \" \" << arr[q] << endl;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        scanf(\"%d\", &k);\n        if (k != 0) cout << endl;\n    }\n    return 0;\n}\n",
                "Contributor": "jtuyls",
                "Difficulty": "med",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=642&page=show_problem&problem=382",
                "Name": "Lotto",
                "Note": "",
                "Session": "2",
                "Solution": "441.cpp"
            },
            {
                "Code": "## Problem @ http://codeforces.com/problemset/problem/1060/D\n## #greedy #math\nn = int(input())\nleft = []\nright = []\nfor i in range(n):\n    a,b = map(int, input().split())\n    left.append(a)\n    right.append(b)\nprint(n + sum(map(max, sorted(left), sorted(right))))\n",
                "Contributor": "pooyak",
                "Difficulty": "med",
                "Link": "https://codeforces.com/problemset/problem/1060/D",
                "Name": "Social Circles",
                "Note": "",
                "Session": "2",
                "Solution": "cf_1060D.py"
            },
            {
                "Code": "'''The first line of the input gives the number of test cases, T.\nT test cases follow. Each test case consists of two lines. The first line of a\ntest case contains a single integer N, the total number of kids in the class.\nThe second line of a test case contains N integers F1, F2, ...,\nFN, where Fi is the student ID number of the BFF of the kid with student ID i.\n'''\nimport sys\nsys.setrecursionlimit(5000)\nopen_file = open(input())\nnum_test = int(open_file.readline())\n\ndef store(open_file,friend_map):\n    num = int(open_file.readline().strip())\n    for index,i in enumerate(open_file.readline().strip().split(),1):\n        to_int = int(i)\n        if index not in friend_map:\n            friend_map[index] = {'ind':set(),'outd': 0, 'len':1}\n        friend_map[index]['outd'] = to_int\n        if to_int not in friend_map:\n            friend_map[to_int] = {'ind':set([index]),'outd':0,'len':1}\n        else:\n            friend_map[to_int]['ind'].add(index);\n    return num\n\ndef process(friend:dict,traveled:set, number:int):\n    clargest= 0\n    nclargest = 0\n    #addable = 0\n    for to_tra in range(1,number + 1):\n        if to_tra not in traveled:\n            cycle_queue = []\n            index = 0\n            cyclic = False\n            while(to_tra != friend[friend[to_tra]['outd']]['outd']):\n                if to_tra in cycle_queue:\n                    for n,i in enumerate(cycle_queue,0):\n                        if to_tra == i:\n                            index = n\n                            break\n                    cycle_queue = cycle_queue[index:]\n                    cyclic = True\n                    break\n                cycle_queue.append(to_tra)\n                to_tra = friend[to_tra]['outd'] #find the reciprocal node to start\n            if cyclic:\n                component = len(cycle_queue)\n                cyclic_recur(friend, cycle_queue[0], traveled)\n                if clargest < component:\n                    clargest = component\n            else:\n                a = find_num(friend,to_tra,0,traveled)\n                b = find_num(friend,friend[to_tra]['outd'],0,traveled)\n                component = a + b\n                nclargest += component\n\n    return (clargest,nclargest)\n\ndef cyclic_recur(friend:dict, to_recur:int, traveled:set):\n    if friend[to_recur]['ind'] == set():\n        traveled.add(to_recur)\n        return\n    for i in friend[to_recur]['ind']:\n        if i not in traveled:\n            traveled.add(i)\n            cyclic_recur(friend, i , traveled)\n\ndef find_num(friend: dict, to_recur: int,lar:int,traveled:set):\n    if friend[to_recur]['ind'] == set():\n        traveled.add(to_recur)\n        return 1\n    lolar = 0\n    for i in friend[to_recur]['ind']:\n        traveled.add(i)\n        if i == friend[to_recur]['outd']:\n            cmp = 0\n        else:\n            cmp = find_num(friend, i , lar, traveled)\n        if cmp > lolar:\n            lolar = cmp\n    return lolar+1\n\nif __name__ == '__main__':\n    for _ in range(num_test):\n        largest = 1\n        friend_map = dict()\n        traveled= set()\n        num = store(open_file,friend_map)\n        clargest,nclargest = process(friend_map, traveled, num)\n        if nclargest  > clargest:\n            largest = nclargest\n        else:\n            largest = clargest\n        print(\"Case #\" + str(_+1)+ ': ' + str(largest))\n    open_file.close()\n",
                "Contributor": "renjied",
                "Difficulty": "med",
                "Link": "https://code.google.com/codejam/contest/4304486/dashboard#s=p2",
                "Name": "BFFs",
                "Note": "",
                "Session": "2",
                "Solution": "largest_BFF.py"
            },
            {
                "Code": "from collections import defaultdict\n\ns = int(input())\n\nfirst_breads = list(map(int,input().strip().split()))\nnext_breads = list(map(int,input().strip().split()))\n\nlookup = {first_breads[i]:next_breads[i] for i in range(s)}\n\neven_cycles = 0\n\nvisited = set()\nfor b in first_breads:\n    if b not in visited:\n        size = 0\n        next = lookup[b]\n        while next not in visited:\n            visited.add(next)\n            size+=1\n            next = lookup[next]\n        if size%2 == 0:\n            even_cycles +=1\n        visited.add(b)\n#print(\"even cycles: {}\".format(even_cycles))\nprint(\"Possible\" if even_cycles%2==0 else \"Impossible\")\n",
                "Contributor": "craut",
                "Difficulty": "hard",
                "Link": "https://open.kattis.com/problems/bread",
                "Name": "Bread Sorting",
                "Note": "",
                "Session": "2",
                "Solution": "bread.py"
            }
        ],
        [
            null,
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "announcement",
                "Link": "We are going to cover Binary Search this week",
                "Name": "Note",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "announcement",
                "Link": "We are going to cover Binary Search this week",
                "Name": "Note",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "n,t = map(int,input().split())\nmin_c = -1e10\nmax_c = 1e10\n\ncurr_c = lambda: (max_c+min_c)/2\n\nsegments = []\n\nfor a in range(n):\n    d,s = map(int,input().split())\n    segments.append((d,s))\n\ndef calc_total_time(c):\n    return 1e10 if min([s for d,s in segments])+c <= 0 else sum([d/(s+c) for d,s in segments])\n\nwhile max_c-min_c > 10**-7:\n    curr_c = (max_c+min_c)/2\n    tmp = calc_total_time(curr_c)\n    if tmp < t:\n        max_c = curr_c\n    else:\n        min_c = curr_c\n\nprint('{:.7f}'.format((max_c+min_c)/2))\n",
                "Contributor": "craut",
                "Difficulty": "easy",
                "Link": "https://open.kattis.com/problems/speed",
                "Name": "Need for Speed",
                "Note": "",
                "Session": "1",
                "Solution": "speed.py"
            },
            {
                "Code": "import math\n\nd,s = map(int,input().split())\n\nmin_a = 0.0\nmax_a = 10**10\n\ndef calc(a):\n    tmp = math.e**(d/a)\n    return s-(a*.5*((tmp+1)/(tmp**.5))-a)\n\n\nwhile abs(calc((max_a+min_a)/2)) > 10**-6:\n    if calc((max_a+min_a)/2) < 0:\n        min_a = (max_a+min_a)/2\n    else:\n        max_a = (max_a+min_a)/2\na = (max_a+min_a)/2\nprint(2*a*math.sinh(d/(2*a)))\n",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/suspensionbridges",
                "Name": "Suspension Bridges",
                "Note": "",
                "Session": "1",
                "Solution": "bridges.py"
            },
            {
                "Code": "",
                "Contributor": "craut",
                "Difficulty": "codealong",
                "Link": "https://www.geeksforgeeks.org/painters-partition-problem-set-2/",
                "Name": "Painter’s Partition 2",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "craut",
                "Difficulty": "codealong",
                "Link": "https://www.geeksforgeeks.org/painters-partition-problem/",
                "Name": "Painter’s Partition",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/millionairemadness",
                "Name": "Millionaire Madness",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "import math\n\nn = int(input())\npts = []\n\nfor i in range(n):\n    x,y = map(int,input().strip().split())\n    pts.append((x,y))\n\ndef gen_vertices(sides, pos_leg):\n    vertices = [(pos_leg,0)]\n    jmp = 2*math.pi/sides\n    cur = jmp\n    while 2*math.pi-cur > 10**-7:\n        vertices.append((pos_leg*math.cos(cur),pos_leg*math.sin(cur)))\n        cur += jmp\n    return vertices\n\npts_dist = lambda a,b: ((b[1]-a[1])**2+(b[0]-a[0])**2)**0.5\n\ndef tri_area(tri):\n    a = pts_dist(tri[0],tri[1])\n    b = pts_dist(tri[1],tri[2])\n    c = pts_dist(tri[0],tri[2])\n    s = (a+b+c)/2.0\n    return (s*(s-a)*(s-b)*(s-c))**0.5\n\ndef triangle_contained(tri,pt):\n    pt_pairs = [(0,1),(1,2),(0,2)]\n    pt_area = 0\n    for v1,v2 in pt_pairs:\n        pt_area+=tri_area([pt,tri[v1],tri[v2]])\n    return abs(pt_area - tri_area(tri)) < 10**-3\n\ndef contained(n,radii,pt):\n    pt_angle = (math.atan2(pt[1],pt[0])%(2*math.pi))\n    cw_vert = int(pt_angle//(2*math.pi/n))\n    pt_dist_to_cent = pts_dist((0,0),pt)\n    vert_angle = 2*math.pi/n*cw_vert\n    opp_angle = math.pi*(n-2)/(2*n)\n    angle_diff = pt_angle-vert_angle\n    remaining_angle = math.pi-angle_diff-opp_angle\n    return math.sin(opp_angle)*radii>=pt_dist_to_cent*math.sin(remaining_angle)\n\ndef poly_area(sides,rad):\n    return 0.5*rad**2*sides*math.sin(2*math.pi/sides)\n\ndef bs_outer(beg,end,err,sides,pts):\n    mid = lambda : (beg+end)/2.0\n    while end-beg > err:\n        if all([contained(sides,mid(),pt) for pt in pts]):\n            end = mid()\n        else:\n            beg = mid()\n    return mid()\n\ndef bs_inner(beg,end,err,sides,pts):\n    mid = lambda : (beg+end)/2.0\n    while end-beg > err:\n        if any([contained(sides,mid(),pt) for pt in pts]):\n            end = mid()\n        else:\n            beg = mid()\n    return mid()\n\nhigh_score = (0,0)\n\nfor num_sides in range(3,9):\n    outer_radii = bs_outer(0,10**7,10**-8,num_sides,pts)\n    inner_radii = bs_inner(0,10**7,10**-8,num_sides,pts)\n\n    score = poly_area(num_sides,inner_radii)/poly_area(num_sides,outer_radii)\n    if score > high_score[0]:\n        high_score = (score,num_sides)\n\nprint(high_score[1],high_score[0])\n",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/glyphrecognition",
                "Name": "Glyph Recognition",
                "Note": "",
                "Session": "1",
                "Solution": "glyph_recog.py"
            },
            {
                "Code": "import math\n\nn = int(input())\npts = []\n\nfor i in range(n):\n    x,y = map(int,input().strip().split())\n    pts.append((x,y))\n\ndef gen_vertices(sides, pos_leg):\n    vertices = [(pos_leg,0)]\n    jmp = 2*math.pi/sides\n    cur = jmp\n    while 2*math.pi-cur > 10**-7:\n        vertices.append((pos_leg*math.cos(cur),pos_leg*math.sin(cur)))\n        cur += jmp\n    return vertices\n\npts_dist = lambda a,b: ((b[1]-a[1])**2+(b[0]-a[0])**2)**0.5\n\ndef tri_area(tri):\n    a = pts_dist(tri[0],tri[1])\n    b = pts_dist(tri[1],tri[2])\n    c = pts_dist(tri[0],tri[2])\n    s = (a+b+c)/2.0\n    return (s*(s-a)*(s-b)*(s-c))**0.5\n\ndef triangle_contained(tri,pt):\n    pt_pairs = [(0,1),(1,2),(0,2)]\n    pt_area = 0\n    for v1,v2 in pt_pairs:\n        pt_area+=tri_area([pt,tri[v1],tri[v2]])\n    return abs(pt_area - tri_area(tri)) < 10**-3\n\ndef contained(n,radii,pt):\n    pt_angle = (math.atan2(pt[1],pt[0])%(2*math.pi))\n    cw_vert = int(pt_angle//(2*math.pi/n))\n    pt_dist_to_cent = pts_dist((0,0),pt)\n    vert_angle = 2*math.pi/n*cw_vert\n    opp_angle = math.pi*(n-2)/(2*n)\n    angle_diff = pt_angle-vert_angle\n    remaining_angle = math.pi-angle_diff-opp_angle\n    return math.sin(opp_angle)*radii>=pt_dist_to_cent*math.sin(remaining_angle)\n\ndef poly_area(sides,rad):\n    return 0.5*rad**2*sides*math.sin(2*math.pi/sides)\n\ndef bs_outer(beg,end,err,sides,pts):\n    mid = lambda : (beg+end)/2.0\n    while end-beg > err:\n        if all([contained(sides,mid(),pt) for pt in pts]):\n            end = mid()\n        else:\n            beg = mid()\n    return mid()\n\ndef bs_inner(beg,end,err,sides,pts):\n    mid = lambda : (beg+end)/2.0\n    while end-beg > err:\n        if any([contained(sides,mid(),pt) for pt in pts]):\n            end = mid()\n        else:\n            beg = mid()\n    return mid()\n\nhigh_score = (0,0)\n\nfor num_sides in range(3,9):\n    outer_radii = bs_outer(0,10**7,10**-8,num_sides,pts)\n    inner_radii = bs_inner(0,10**7,10**-8,num_sides,pts)\n\n    score = poly_area(num_sides,inner_radii)/poly_area(num_sides,outer_radii)\n    if score > high_score[0]:\n        high_score = (score,num_sides)\n\nprint(high_score[1],high_score[0])\n",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/glyphrecognition",
                "Name": "Glyph Recognition",
                "Note": "",
                "Session": "2",
                "Solution": "glyph_recog.py"
            },
            {
                "Code": "import math\n\nn,p,s,v = (map(float,input().split()))\n\ndef fun(c):\n    result = (math.log(n)/math.log(2))**((2**.5)*c)\n    result*= n\n    result /= (p*(10**9))\n    result += (s/v)\n    result += (s/(v*c))\n    return result\n\nmin = .1\nmax = 200\nwhile max-min > 10**-6:\n    third = (max-min)/3\n    low = min+third\n    high = max-third\n    l_r = fun(low)\n    h_r = fun(high)\n    #print(l_r,h_r)\n    if l_r < h_r:\n        max = high\n    else:\n        min = low\n\nc = (max+min)/2\nprint(fun(c),c)\n",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/contests/bqfu9s/problems/euclideantsp",
                "Name": "Euclidean TSP",
                "Note": "",
                "Session": "2",
                "Solution": "euclideantsp.py"
            },
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Leetcode) 300\n\n// O(n^2) solution\nclass Solution {\n public:\n  int lengthOfLIS(vector<int>& nums) {\n    if (nums.size() == 0) return 0;\n\n    vector<int> dp(nums.size(), 0);\n    dp[0] = 1;\n    for (int i = 1; i < nums.size(); ++i) {\n      int max_len = 0;\n      for (int j = 0; j < i; ++j) {\n        if (nums[j] < nums[i]) max_len = max(dp[j], max_len);\n      }\n      dp[i] = max_len + 1;\n    }\n    int res = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n      res = max(res, dp[i]);\n    }\n    return res;\n  }\n};\n\n// O(n log n) solution\nclass Solution {\n public:\n  int lengthOfLIS(vector<int>& nums) {\n    if (nums.size() == 0) return 0;\n\n    vector<int> dp(1, nums[0]);\n    for (int i = 1; i < nums.size(); ++i) {\n      auto loc = lower_bound(dp.begin(), dp.end(), nums[i]);\n      if (loc == dp.end()) {\n        dp.push_back(nums[i]);\n      } else {\n        *loc = nums[i];\n      }\n    }\n    return dp.size();\n  }\n};\n",
                "Contributor": "btjanaka",
                "Difficulty": "icpc",
                "Link": "https://leetcode.com/problems/longest-increasing-subsequence/",
                "Name": "LIS",
                "Note": "",
                "Session": "2",
                "Solution": "leetcode300.cpp"
            },
            {
                "Code": "",
                "Contributor": "renjied",
                "Difficulty": "icpc",
                "Link": "http://codeforces.com/problemset/problem/842/C",
                "Name": "Ilya and the Tree",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "a,b,c,d = map(int,input().split())\n\nlookup = {0:-1}\ncur = 0\nfor i in range(1,10**5+10):\n    cur+=i\n    lookup[cur]=i+1\n\nif a not in lookup or d not in lookup:\n    print(\"impossible\")\n    exit(0)\n\nnum0 = lookup[a]\nnum1 = lookup[d]\n\nif num0 == -1:\n    num0 = 1 if b+c > 0 else 0\nif num1 == -1:\n    num1 = 1 if b+c > 0 else 0\n\ntot_len = num0+num1\nif a+b+c+d == 0:\n    print(\"1\")\n    exit(0)\n\nif (tot_len*(tot_len-1))/2 != a+b+c+d:\n    #print(num0,num1)\n    print(\"impossible\")\n    exit(0)\n\nif num0 == 0 or num1 == 0:\n    print(\"0\"*num0+\"1\"*num1)\n    exit(0)\n\nf1 = c//num0\nl1 = b//num0\n\nif f1+l1 == num1:\n    print(\"1\"*f1+\"0\"*num0+\"1\"*l1)\nelif f1+l1 == num1-1:\n    f0 = b%num0\n    print(\"1\"*f1+\"0\"*f0+\"1\"+\"0\"*(num0-f0)+\"1\"*l1)\nelse:\n    exit(1)\n",
                "Contributor": "craut",
                "Difficulty": "icpc",
                "Link": "http://codeforces.com/gym/101933/problem/J",
                "Name": "Jumbled String",
                "Note": "",
                "Session": "2",
                "Solution": "jumbled_str.py"
            }
        ],
        [
            null,
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "icpc",
                "Link": "https://open.kattis.com/problems/atlantis",
                "Name": "Atlantis",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "icpc",
                "Link": "https://open.kattis.com/problems/lostmap",
                "Name": "Lost Map",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "icpc",
                "Link": "https://open.kattis.com/problems/pokemongogo",
                "Name": "Pokemon Go Go",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "icpc",
                "Link": "https://open.kattis.com/problems/racingalphabet",
                "Name": "Racing Around the Alphabet",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "icpc",
                "Link": "https://open.kattis.com/problems/smootharray",
                "Name": "Smooth Array",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "icpc",
                "Link": "https://open.kattis.com/problems/stoichiometry",
                "Name": "Stoichiometry",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "icpc",
                "Link": "https://open.kattis.com/problems/urbandesign",
                "Name": "Urban Design",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "icpc",
                "Link": "https://open.kattis.com/problems/zebrasocelots",
                "Name": "Zebras and Ocelots",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "event",
                "Link": "",
                "Name": "ACM Social",
                "Note": "",
                "Session": "2",
                "Solution": ""
            }
        ],
        [
            null,
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "easy",
                "Link": "https://www.hackerrank.com/challenges/binary-search-tree-lowest-common-ancestor/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=trees",
                "Name": "Lowest Common Ancestor",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "med",
                "Link": "https://www.hackerrank.com/challenges/ctci-is-binary-search-tree/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=trees",
                "Name": "Trees",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "med",
                "Link": "https://www.hackerrank.com/challenges/torque-and-development/problem",
                "Name": "Roads and Libraries",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\nimport heapq\n\n#\n# Complete the 'kruskals' function below.\n#\n# The function is expected to return an INTEGER.\n# The function accepts WEIGHTED_INTEGER_GRAPH g as parameter.\n#\n\n#\n# For the weighted graph, <name>:\n#\n# 1. The number of nodes is <name>_nodes.\n# 2. The number of edges is <name>_edges.\n# 3. An edge exists between <name>_from[i] and <name>_to[i]. The weight of the edge is <name>_weight[i].\n#\n#\n\ndef kruskals(g_nodes, g_from, g_to, g_weight):\n    edges = []\n    for i in range(len(g_from)):\n        edges.append((g_weight[i],g_from[i],g_to[i]))\n    heapq.heapify(edges)\n    reached = []\n    num_edges = 0\n    size = 0\n    while num_edges+1 != g_nodes:\n        w,t,f = heapq.heappop(edges)\n        t_r = -1\n        f_r = -1\n        for i in range(len(reached)):\n            if t in reached[i]:\n                t_r = i\n            if f in reached[i]:\n                f_r = i\n        if t_r == -1 and f_r == -1:\n            reached.append({t,f})\n            size+=w\n            num_edges+=1\n        elif t_r == f_r:\n            continue\n        elif t_r == -1:\n            reached[f_r].add(t)\n            size+=w\n            num_edges+=1\n        elif f_r == -1:\n            reached[t_r].add(f)\n            size+=w\n            num_edges+=1\n        else:\n            low = min(t_r,f_r)\n            high = max(t_r,f_r)\n            reached[low] = reached[low]|reached[high]\n            del reached[high]\n            size+=w\n            num_edges+=1\n\n    return size\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    g_nodes, g_edges = map(int, input().rstrip().split())\n\n    g_from = [0] * g_edges\n    g_to = [0] * g_edges\n    g_weight = [0] * g_edges\n\n    for i in range(g_edges):\n        g_from[i], g_to[i], g_weight[i] = map(int, input().rstrip().split())\n\n    res = kruskals(g_nodes, g_from, g_to, g_weight)\n\n    # Write your code here.\n    fptr.write(\"{}\".format(res))\n\n    fptr.close()\n",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://www.hackerrank.com/challenges/kruskalmstrsub/problem",
                "Name": "Kruskal MST",
                "Note": "",
                "Session": "1",
                "Solution": "kruskalmstrsub.py"
            },
            {
                "Code": "#!/bin/python3\n\nimport os\nimport sys\nfrom collections import defaultdict\n\n\n#\n# Complete the rustMurdered function below.\n#\ndef rustMurderer(n, roads, src):\n    dists = [1]*n\n    edges = defaultdict(set)\n    for s,d in roads:\n        edges[s].add(d)\n        edges[d].add(s)\n    to_visit = edges[src]\n    cur_dist = 2\n    while len(to_visit) > 0:\n        new_reach = set()\n        for node in to_visit:\n            if len(edges[node]|to_visit) != n:\n                dists[node-1] = cur_dist\n                new_reach.add(node)\n        to_visit = to_visit-new_reach\n        cur_dist+=1\n\n    del dists[src-1]\n    return dists\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    t = int(input())\n\n    for t_itr in range(t):\n        nm = input().split()\n\n        n = int(nm[0])\n\n        m = int(nm[1])\n\n        roads = []\n\n        for _ in range(m):\n            roads.append(list(map(int, input().rstrip().split())))\n\n        s = int(input())\n\n        result = rustMurderer(n, roads, s)\n\n        fptr.write(' '.join(map(str, result)))\n        fptr.write('\n')\n\n    fptr.close()\n",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://www.hackerrank.com/challenges/rust-murderer/problem",
                "Name": "Rust & Murderer",
                "Note": "",
                "Session": "1",
                "Solution": "rust_murder.py"
            },
            {
                "Code": "'''\n    Bertwon Subway (recursion ver)\n    A side note about this recursion version of solution is that this\n    solution might exit when input number gets too large while using iterative\n    method would not cause this problem. Python is weak of recursion, switch to\n    Java or C++ when you find runtime error with large input\n    Source: http://codeforces.com/problemset/problem/884/C\n'''\nfrom math import factorial\nimport sys\nsys.setrecursionlimit(100000)\ndef solve(subway):\n    max1,max2 =0,0\n    explored = set()\n    summation = 0\n    for i in subway:\n        temp = dfs(subway,explored,i)\n        if temp > max1:\n            if max2 != 0:\n                max2 = max1\n            max1 = temp\n        elif temp > max2:\n            max2 = temp\n\n        summation += temp*temp\n        #print(temp)\n\n    summation -= max1*max1\n    summation -= max2*max2\n    summation += (max1 + max2)**2\n    #print(max1,max2,conp_list)\n    print(summation)\ndef dfs(subway,explored,node):\n    if node in explored:\n        return 0\n    explored.add(node)\n    return 1 + dfs(subway,explored,subway[node])\n\nif __name__ == '__main__':\n    num = int(input().strip())\n    subway = dict()\n    num_list = input().strip().split()\n    for index,i in enumerate(num_list,1):\n        subway[index] = int(i)\n    solve(subway)\n\n\n",
                "Contributor": "renjied",
                "Difficulty": "med",
                "Link": "http://codeforces.com/problemset/problem/884/C",
                "Name": "Bertown Subway",
                "Note": "",
                "Session": "2",
                "Solution": "884C.py"
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/lostmap",
                "Name": "Lost Map",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "'''\n    Peculiar apple-tree\n    Source: http://codeforces.com/problemset/problem/931/D\n'''\nfrom collections import defaultdict\ndef solve(tree):\n    summation = 1\n    to_count = [1]\n    while to_count != []:\n        temp = []\n        for i in to_count:\n            temp += tree[i]\n        summation += len(temp)%2\n        to_count = temp\n    return summation\n\nif __name__ == '__main__':\n    num = int(input().strip())\n    tree = defaultdict(list)\n    for index,parent in enumerate(input().strip().split(),2):\n        tree[int(parent)].append(index)\n    print(solve(tree))\n",
                "Contributor": "renjied",
                "Difficulty": "med",
                "Link": "https://codeforces.com/problemset/problem/930/A",
                "Name": "Peculiar Apple-Tree",
                "Note": "",
                "Session": "2",
                "Solution": "931D.py"
            },
            {
                "Code": "",
                "Contributor": "junliw1",
                "Difficulty": "hard",
                "Link": "https://codeforces.com/problemset/problem/796/D",
                "Name": "Police Stations",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "announcement",
                "Link": "First two problems on trees. Next three problems on graphs. Come and ask questions on how to implement graph and some algorithms for it.",
                "Name": "Note",
                "Note": "",
                "Session": "1",
                "Solution": ""
            }
        ],
        [
            null,
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "thanksgiving",
                "Link": "",
                "Name": "",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "thanksgiving",
                "Link": "",
                "Name": "",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "event",
                "Link": "https://www.facebook.com/events/330113671053378/",
                "Name": "Alumni Seminar",
                "Note": "",
                "Session": "2",
                "Solution": ""
            }
        ],
        [
            null,
            {
                "Code": "",
                "Contributor": "timothy4",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/house-robber/description/",
                "Name": "House Robber",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n\n  int t,n;\n  cin >> t;\n  while(t--){\n    bool c=true;\n    cin >> n;\n    vector<int> v(n+1);\n    for(int i=0; i<n; i++){\n      cin >> v[i+1];\n    }\n\n    for(int i=1; i<=n; i++){\n      int ct=1,j=i;\n      while(v[j]!=i){\n        int temp = j;\n        j = v[j];\n        ct++;\n        v[temp] = temp;\n      }\n      v[j]=j;\n      int x = 0;\n      while((ct | 1<<x) != ct){\n        x++;\n      }\n\n      if((ct ^ (1<<x)) != 0){\n        cout << \"Some starve.\" << endl;\n        c = false;\n        break;\n      }\n    }\n    if(c){\n      cout << \"All can eat.\" << endl;\n    }\n\n  }\n  return 0;\n}\n",
                "Contributor": "mnovitia",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/partygame",
                "Name": "Party Game",
                "Note": "",
                "Session": "1",
                "Solution": "partygame.cpp"
            },
            {
                "Code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <cmath>\n#include <type_traits>\nusing namespace std;\n\nint main () {\n    double k;\n    while (scanf(\"%lf\n\", &k) != EOF) {\n        vector<pair<double, pair<double, double> > > sol;\n        set<double> included;\n        double x = k + 1;\n        double end = 1/(1/k - 1/x);\n        int counter = 0;\n        while (x <= end) {\n            double y = (k * x)/(x - k);\n            end = y;\n            if (y == floor(y)) {\n                sol.push_back(make_pair(k, make_pair(x, y)));\n                included.insert(y);\n                ++counter;\n            }\n            ++x;\n        }\n\n        cout << counter << endl;\n        for (auto p: sol) {\n            int k = p.first;\n            int x = p.second.first;\n            int y = p.second.second;\n            printf(\"1/%d = 1/%d + 1/%d\n\", k, y, x);\n        }\n    }\n    return 0;\n}\n",
                "Contributor": "jtuyls",
                "Difficulty": "easy",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=640&page=show_problem&problem=1917",
                "Name": "Fractions Again?!",
                "Note": "",
                "Session": "1",
                "Solution": "10976.cpp"
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "hard",
                "Link": "",
                "Name": "2-SAT (Ask Karthik)",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "hard",
                "Link": "https://leetcode.com/problems/profitable-schemes/",
                "Name": "Profitable Schemes",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/longest-mountain-in-array/",
                "Name": "Longest Mountain in Array",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "'''\n    Bertwon Subway (recursion ver)\n    A side note about this recursion version of solution is that this\n    solution might exit when input number gets too large while using iterative\n    method would not cause this problem. Python is weak of recursion, switch to\n    Java or C++ when you find runtime error with large input\n    Source: http://codeforces.com/problemset/problem/884/C\n'''\nfrom math import factorial\nimport sys\nsys.setrecursionlimit(100000)\ndef solve(subway):\n    max1,max2 =0,0\n    explored = set()\n    summation = 0\n    for i in subway:\n        temp = dfs(subway,explored,i)\n        if temp > max1:\n            if max2 != 0:\n                max2 = max1\n            max1 = temp\n        elif temp > max2:\n            max2 = temp\n\n        summation += temp*temp\n        #print(temp)\n\n    summation -= max1*max1\n    summation -= max2*max2\n    summation += (max1 + max2)**2\n    #print(max1,max2,conp_list)\n    print(summation)\ndef dfs(subway,explored,node):\n    if node in explored:\n        return 0\n    explored.add(node)\n    return 1 + dfs(subway,explored,subway[node])\n\nif __name__ == '__main__':\n    num = int(input().strip())\n    subway = dict()\n    num_list = input().strip().split()\n    for index,i in enumerate(num_list,1):\n        subway[index] = int(i)\n    solve(subway)\n\n\n",
                "Contributor": "renjied",
                "Difficulty": "med",
                "Link": "https://codeforces.com/problemset/problem/884/C",
                "Name": "Bertown Subway",
                "Note": "",
                "Session": "2",
                "Solution": "884C.py"
            },
            {
                "Code": "'''\n    Algorithm category: Binary search + greedy\n    Problem explaination: Using O(n^2) solution would lead to getting a TLE(Time\n    limit exceeded) error by comparing each P with the rest of P.\n    However, it is not hard to test if 100, for example, is one of the solutions(may\n    not be the optimal one). if 100 can not be one of the solution, how about 100/2?\n    This intuition give us a clue to use binary search on the answer and use\n    greedy algorithm to check if this answer is correct or not\n    Side Note: The online judge accept my Pyhton 2.7 solution but give TLE error\n    for my Python3's. There are places in this solution that can be optimized.\n    Try to come up and pass the online judge using Python3 if interested.\n'''\ndef solve(field,size,answer):\n    star_pos = -1\n    p_pos = -1\n    for i in range(size):\n        #print(p_pos,star_pos)\n        if field[i] == \"*\":\n            if star_pos != -1:\n                if p_pos != -1:\n                    if star_pos < p_pos and i > p_pos: #*...P.*.* star on both side of P\n                        if min(2*(p_pos-star_pos)+(i-p_pos),2*(i-p_pos)+\\n                               (p_pos-star_pos)) > answer:\n                            star_pos = i\n                            p_pos = -1\n                            continue\n                    elif i-p_pos > answer: #..P..*P when star on the right of P\n                        star_pos = i\n                        p_pos = -1\n                        continue\n            else:\n                if p_pos != -1: #P..*.P\n                    if i - p_pos > answer:\n                        p_pos = -1\n                star_pos = i\n\n        if field[i] == \"P\":\n            if p_pos != -1:\n                star_pos = -1\n            if star_pos != -1:\n                #print(\"star_pos:\",star_pos,\"current pos\",i)\n                if i - star_pos > answer:\n                    return -1\n            p_pos = i\n\n    if p_pos == -1:\n        return -1\n    return 1\n\n\n\n\nif __name__ == \"__main__\":\n    size = int(input().strip()) #Change this statement in to int(raw_input().strip()) in Python 2.7\n    field = input().strip() # Change this statement into raw_input().strip() in Python 2.7\n    first = 1\n    last = 2*size\n    best = last + 1\n    while first <= last:\n        mid = int(first + (last - first)/2)\n        if solve(field,size,mid) == -1:\n            first = mid + 1\n        else:\n            best = mid\n            last = mid - 1\n    print(best)\n\n",
                "Contributor": "renjied",
                "Difficulty": "med",
                "Link": "https://codeforces.com/problemset/problem/847/E",
                "Name": "Packmen",
                "Note": "",
                "Session": "2",
                "Solution": "cf_packman.py"
            }
        ],
        [
            null,
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "event",
                "Link": "https://www.facebook.com/events/288178678473859/",
                "Name": "MOVIE NIGHT",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "event",
                "Link": "https://www.facebook.com/events/276047016386197/",
                "Name": "HOLIDAY BASH",
                "Note": "",
                "Session": "2",
                "Solution": ""
            }
        ],
        [
            null,
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "finals",
                "Link": "",
                "Name": "",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "finals",
                "Link": "",
                "Name": "",
                "Note": "",
                "Session": "2",
                "Solution": ""
            }
        ]
    ],
    "Fall 2019": {
        "temp": 0
    },
    "Spring 2019": [
        null,
        {
            "-LbOyaWeonT0m5Y7Hzgk": {
                "Code": "# https://code.google.com/codejam/contest/5304486/dashboard#s=p0\r\nt = int(input())\r\nfor test in range(1,t+1):\r\n    r,c = map(int,input().split())\r\n    cake = []\r\n    for i in range(r):\r\n        line = list(input())\r\n        for j in range(1,c):\r\n            if line[j] == '?' and line[j-1] != '?':\r\n                line[j] = line[j-1]\r\n        for j in range(c-2,-1,-1):\r\n            if line[j] == '?' and line[j+1] != '?':\r\n                line[j] = line[j+1]\r\n        line = \"\".join(line)\r\n        if line == '?'*c and len(cake) > 0:\r\n            cake.append(cake[-1])\r\n        else:\r\n            cake.append(line)\r\n    for i in range(r-2,-1,-1):\r\n        if cake[i] == \"?\"*c:\r\n            cake[i] = cake[i+1]\r\n    print(\"Case #{}:\\n{}\".format(test,\"\\n\".join(cake)))\r\n\r\n\r\n",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://code.google.com/codejam/contest/5304486/dashboard#s=p0",
                "Name": "Alphabet Cake",
                "Note": "most important insight \"no initial appears more than once on the cake\"",
                "Session": "1",
                "Solution": "alphabet_cake.py",
                "SubmitDate": "Mon Apr 01 2019 08:41:28 GMT-0700 (Pacific Daylight Time)"
            },
            "-LbOyb4Sa_Yy4dC-VTB3": {
                "Code": "# https://code.google.com/codejam/contest/5304486/dashboard#s=p1\r\nfrom math import floor,ceil\r\nfrom functools import reduce\r\nget_range = lambda r,q: (ceil(10/11*q/r),floor(10/9*q/r))\r\nupdate_range = lambda x,y: (max(x[0],y[0]),min(x[1],y[1]))\r\nvalid_range = lambda r: r[1]>=r[0]\r\n\r\n\r\ncases = int(input())\r\nfor test in range(1,cases+1):\r\n    n,p = map(int,input().split())\r\n    ingred_req = list(map(int,input().split()))\r\n    ingred_ranges = [] # keep track of multiples of servings each ingredient package can make\r\n    for i in range(n):\r\n        ingred_ranges.append(sorted(get_range(ingred_req[i],q) for q in map(int,input().split())))\r\n    kits = 0\r\n    avail = [0]*n\r\n    # now overlapping intersection problem, can be solved using greedy in this case (but not always)\r\n    smallest_upper_ingred = 0\r\n    while all(map(lambda x: x<p,avail)):\r\n        ranges_considering = [ingred_ranges[i][avail[i]] for i in range(n)]\r\n        most_restrictive,_ = min(enumerate(ranges_considering),key=lambda x:(x[1][1],x[1][0],x[0]))\r\n        ending_range = reduce(update_range,ranges_considering)\r\n        if valid_range(ending_range):\r\n            for j in range(n):\r\n                avail[j]+=1\r\n            kits+=1\r\n        else:\r\n            avail[most_restrictive]+=1\r\n\r\n    print(\"Case #{}: {}\".format(test,kits))",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://code.google.com/codejam/contest/5304486/dashboard#s=p1",
                "Name": "Ratatouille",
                "Note": "more greedy",
                "Session": "1",
                "Solution": "ratatouille.py",
                "SubmitDate": "Mon Apr 01 2019 08:43:05 GMT-0700 (Pacific Daylight Time)"
            },
            "-LbQ22PmkPK8Cs8rvfsR": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (LeetCode) 101\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\n public:\n  bool mirror(TreeNode* left, TreeNode* right) {\n    if (left == nullptr ^ right == nullptr) return false;\n    if (left == nullptr & right == nullptr) return true;\n    return left->val == right->val && mirror(left->left, right->right) &&\n           mirror(left->right, right->left);\n  }\n\n  bool isSymmetric(TreeNode* root) {\n    if (root == nullptr) return true;\n    return mirror(root->left, root->right);\n  }\n};\n",
                "Contributor": "btjanaka",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/symmetric-tree",
                "Name": "Symmetric Tree",
                "Note": "",
                "Session": "1",
                "Solution": "101.cpp",
                "SubmitDate": "Tue Mar 19 2019 02:22:34 GMT-0700 (Pacific Daylight Time)"
            },
            "-LbQAzj5su73cvw07coc": {
                "Code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n    int t;\n    long n,num;\n    cin >> t;\n    for(int j = 0; j< t; j++){\n        cout << \"Case #\" << j+1 << \": \";\n        cin >> n;\n        vector <long long> v[2];\n        for(int i=0; i<n; i++){\n            cin >> num;\n            v[i%2].push_back(num);\n        }\n        sort(v[0].begin(), v[0].end());\n        sort(v[1].begin(), v[1].end());\n\n        int i=0;\n        bool found = false;\n        while(i<(n-1)/2 && !found){\n            if(v[0][i]>v[1][i]){\n                cout << i*2 << endl;\n                found = true;\n            }\n            else if(v[0][i+1]<v[1][i]){\n                cout << i*2+1 << endl;\n                found = true;\n            }\n            i++;\n        }\n        if(!(n%2) && !found){\n            if(v[0][n/2-1]>v[1][n/2-1]){\n                cout<< n-2 << endl;\n                found = true;\n            }\n        }\n        if(!found){\n            cout << \"OK\" << endl;\n        }\n    }\n    return 0;\n}\n",
                "Contributor": "mnovitia",
                "Difficulty": "med",
                "Link": "https://codingcompetitions.withgoogle.com/codejam/round/00000000000000cb/00000000000079cb",
                "Name": "Trouble Sort",
                "Note": "Like sorting 2 separate arrays",
                "Session": "1",
                "Solution": "TroubleSort.cpp",
                "SubmitDate": "Mon Apr 01 2019 16:13:27 GMT-0700 (PDT)"
            },
            "-LbRUD9Ko25Sp6t_exDF": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Google Code Jam) Cruise Control\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\n// Theory: Simply find the time t_max that it takes for any horse to get to the\n// end. Then the max speed you can go is d / t_max, as you will reach the end at\n// the same time as that slow horse.\n\nint main() {\n  int ca;\n  GET(ca);\n  for (int caa = 1; caa <= ca; ++caa) {\n    int d, n;\n    GET(d);\n    GET(n);\n    vector<ii> h(n);\n    for (int i = 0; i < n; ++i) {\n      GET(h[i].first);   // k\n      GET(h[i].second);  // s\n    }\n\n    // sort the horses by distance from the end\n    sort(h.begin(), h.end());\n\n    // find the max time to get to the end\n    double t_max = 0.0;\n    for (int i = n - 1; i >= 0; --i) {\n      double t_i = double(d - h[i].first) / double(h[i].second);\n      t_max = max(t_i, t_max);\n    }\n\n    double res = double(d) / t_max;\n\n    printf(\"Case #%d: %lf\\n\", caa, res);\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "easy",
                "Link": "https://code.google.com/codejam/contest/dashboard?c=8294486",
                "Name": "Cruise Control",
                "Note": "zoom",
                "Session": "1",
                "Solution": "A.cpp",
                "SubmitDate": "Mon Apr 01 2019 22:19:10 GMT-0700 (Pacific Daylight Time)"
            },
            "-Lb_eUyhBxNRUlT-awF7": {
                "Code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nvector<int> adj[300010];\r\nint indegree[300010];\r\nint dp[300010][30];\r\nint largest[30];\r\n\r\nint main()\r\n{\r\n    int n,m;\r\n    int u,v;\r\n    string str;\r\n    queue<int> q;\r\n    cin >> n >> m >> str;\r\n    for(int i=0;i<m;i++)\r\n    {\r\n        cin >> u >> v;\r\n        adj[u-1].push_back(v-1);\r\n        indegree[v-1]++;\r\n    }\r\n    int visit_cnt=0;\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        if(indegree[i]==0)\r\n        {\r\n            q.push(i);\r\n            visit_cnt++;\r\n            dp[i][str[i]-'a'] = 1;\r\n            //cout << \"in:\" << i << endl;\r\n        }\r\n    }\r\n    while(!q.empty())\r\n    {\r\n        u = q.front();\r\n        q.pop();\r\n        for(int i=0;i<adj[u].size();i++)\r\n        {\r\n            v = adj[u][i];\r\n            //cout << u << \" \" << v << endl;\r\n            indegree[v]--;\r\n            if(indegree[v]==0)\r\n            {\r\n                q.push(v);\r\n                visit_cnt++;\r\n            }\r\n            for(int j=0;j<26;j++)\r\n            {\r\n                dp[v][j] = max(dp[v][j], dp[u][j] + (j==str[v]-'a' ? 1 : 0) );\r\n                largest[j] = max(largest[j],dp[v][j]);\r\n            }\r\n        }\r\n    }\r\n    if(visit_cnt<n)\r\n    {\r\n        printf(\"-1\\n\");\r\n    }\r\n    else\r\n    {\r\n        int result = 0;\r\n        for(int i=0;i<26;i++)\r\n        {\r\n            result = max(result,largest[i]);\r\n        }\r\n        printf(\"%d\\n\",result);\r\n    }\r\n    return 0;\r\n}\r\n",
                "Contributor": "zhonghas",
                "Difficulty": "hard",
                "Link": "https://codeforces.com/contest/919/problem/D",
                "Name": "Substring",
                "Note": "Graph theory: topological sort/memorized dfs ",
                "Session": "2",
                "Solution": "919D.cpp",
                "SubmitDate": "Sun Mar 17 2019 14:09:12 GMT-0700 (北美太平洋夏令时间)"
            },
            "-Lb_fBK9jooUkUmcfcEs": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (CodeForces) 727c\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\nint response(int i, int j) {\n  printf(\"? %d %d\\n\", i, j);\n  fflush(stdout);\n  int x;\n  GET(x);\n  return x;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> res(n + 1);\n\n  // Group the first 3 together; if you have the equations:\n  //   a + b = s1\n  //   b + c = s2\n  //   a + c = s3\n  // You can solve for a, b, and c in terms of s (this derivation is trivial and\n  // is left as an exercise to the reader ;D)\n  int s[4];\n  s[1] = response(1, 2);\n  s[2] = response(2, 3);\n  s[3] = response(1, 3);\n  res[1] = (s[1] - s[2] + s[3]) / 2;\n  res[2] = (s[1] + s[2] - s[3]) / 2;\n  res[3] = (-s[1] + s[2] + s[3]) / 2;\n\n  // with some elements determined, the rest are trivial\n  for (int i = 4; i <= n; ++i) {\n    res[i] = response(1, i) - res[1];\n  }\n\n  // final output\n  printf(\"!\");\n  for (int i = 1; i <= n; ++i) printf(\" %d\", res[i]);\n  printf(\"\\n\");\n  fflush(stdout);\n\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://codeforces.com/contest/727/problem/C",
                "Name": "Guess the Array",
                "Note": "- interactive\n- work it out on paper first",
                "Session": "2",
                "Solution": "727c.cpp",
                "SubmitDate": "Wed Apr 03 2019 17:07:21 GMT-0700 (Pacific Daylight Time)"
            },
            "-Lb_fZnLODKaQdGr0zdi": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 429\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nint bfs(const string& start, const string& end,\n        unordered_map<string, unordered_set<string>>& g) {\n  unordered_set<string> visit;\n  visit.insert(start);\n  unordered_set<string> visited;\n  visited.insert(start);\n  unordered_map<string, int> dists;\n  dists[start] = 0;\n\n  int dist = 0;\n  for (dist = 0; !visit.empty(); ++dist) {\n    unordered_set<string> next_visit;\n    for (const string& u : visit) {\n      if (u == end) return dist;\n      for (const string& v : g[u]) {\n        if (visited.find(v) == visited.end()) {\n          next_visit.insert(v);\n          visited.insert(v);\n        }\n      }\n    }\n    visit = std::move(next_visit);\n  }\n\n  return dist;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  int ca;\n  cin >> ca;\n  cin.get();\n  cin.get();\n  string s;\n\n  while (ca--) {\n    // graph input\n    vector<string> words;\n    unordered_map<string, unordered_set<string>> g;\n    while (getline(cin, s) && s != \"*\") {\n      words.push_back(s);\n      g[s] = {};\n    }\n    for (int i = 0; i < words.size(); ++i) {\n      for (int j = i + 1; j < words.size(); ++j) {\n        if (words[i].size() != words[j].size()) continue;\n        int diff = 0;\n        for (int k = 0; k < words[i].size(); ++k) {\n          diff += words[i][k] != words[j][k];\n        }\n        if (diff == 1) {\n          g[words[i]].insert(words[j]);\n          g[words[j]].insert(words[i]);\n        }\n      }\n    }\n\n    // queries\n    string start, end;\n    while (getline(cin, s) && s != \"\") {\n      stringstream ss(s);\n      ss >> start >> end;\n\n      printf(\"%s %s %d\\n\", start.c_str(), end.c_str(), bfs(start, end, g));\n    }\n\n    if (ca) printf(\"\\n\");\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=370",
                "Name": "Word Transformation",
                "Note": "BFS",
                "Session": "2",
                "Solution": "429.cpp",
                "SubmitDate": "Sat Mar 02 2019 14:54:45 GMT-0800 (Pacific Standard Time)"
            },
            "-LbaAzDY3X7x7py6_CXb": {
                "Code": "\n\nt = int(input())\nfor tc in range(t):\n    r,c = (int(x) for x in input().split())\n    grid = [input() for _ in range(r)]\n    \n    # BFS on each '1' node\n    # find highest distance, place node there\n    # run BFS on new noded\n    # final is max of all distances\n    \n    distance = [[-1 for _ in range(c)] for _ in range(r)]\n    \n    for x in range(r):\n        for y in range(c):\n            if grid[x][y]=='1':\n                queue = [(x,y)]\n                distance[x][y]=0\n                \n                while(len(queue)):\n                    i,j = queue.pop(0)\n                    if i>0:\n                        if distance[i-1][j]==-1 or distance[i-1][j]>distance[i][j]+1:\n                            distance[i-1][j]=distance[i][j]+1\n                            queue.append((i-1,j))\n                    if i<r-1:\n                        if distance[i+1][j]==-1 or distance[i+1][j]>distance[i][j]+1:\n                            distance[i+1][j]=distance[i][j]+1\n                            queue.append((i+1,j))\n                    if j>0:\n                        if distance[i][j-1]==-1 or distance[i][j-1]>distance[i][j]+1:\n                            distance[i][j-1]=distance[i][j]+1 \n                            queue.append((i,j-1))\n                    if j<c-1:\n                        if distance[i][j+1]==-1 or distance[i][j+1]>distance[i][j]+1:\n                            distance[i][j+1]=distance[i][j]+1  \n                            queue.append((i,j+1))\n                        \n    \"\"\"\n    mx = 0    \n    l = []\n    \n    #for d in distance : print(d)\n    for x in range(r):\n        for y in range(c):\n            if distance[x][y]>mx:\n                mx = distance[x][y]\n                l = [(x,y)]\n            elif distance[x][y]==mx:\n                l.append((x,y))\"\"\"\n    \n    copy = [list(x) for x in distance]\n    mn = 5000\n    for x in range(r):\n        for y in range(c):\n            mxx = 0\n            queue = [(x,y)]\n            distance = [list(l) for l in copy]\n            distance[x][y]=0\n            \n            while(len(queue)):\n                i,j = queue.pop(0)\n                if i>0:\n                    if distance[i-1][j]==-1 or distance[i-1][j]>distance[i][j]+1:\n                        distance[i-1][j]=distance[i][j]+1\n                        queue.append((i-1,j))\n                if i<r-1:\n                    if distance[i+1][j]==-1 or distance[i+1][j]>distance[i][j]+1:\n                        distance[i+1][j]=distance[i][j]+1\n                        queue.append((i+1,j))\n                if j>0:\n                    if distance[i][j-1]==-1 or distance[i][j-1]>distance[i][j]+1:\n                        distance[i][j-1]=distance[i][j]+1 \n                        queue.append((i,j-1))\n                if j<c-1:\n                    if distance[i][j+1]==-1 or distance[i][j+1]>distance[i][j]+1:\n                        distance[i][j+1]=distance[i][j]+1  \n                        queue.append((i,j+1))\n            \n            for a in range(r):\n                for b in range(c):\n                    if distance[a][b]>mxx:\n                        mxx = distance[a][b]\n            #for d in distance : print(d)\n            #print(mxx)\n            mn = min(mxx, mn)\n                            \n\n    print(\"Case #\"+str(tc+1)+\": \"+str(mn))",
                "Contributor": "mnovitia",
                "Difficulty": "med",
                "Link": "https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050e01/000000000006987d",
                "Name": "Parcels",
                "Note": "BFS everywhere\nMy solution would not pass the large test case though (TLE) XD",
                "Session": "2",
                "Solution": "Parcels.py",
                "SubmitDate": "Thu Apr 04 2019 15:29:11 GMT-0700 (Pacific Daylight Time)"
            },
            "-LbaAznBgWZ2aLTmfy_I": {
                "Code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n    int t,n,p;\n    long long mn, x;\n    cin >> t;\n    for(int tc=0; tc<t; tc++){\n        cin >> n >> p;\n        vector<long long> s;\n        vector<long long> sm;\n        for(int i=0; i<n; i++){\n            cin >> x;\n            s.push_back(x);\n        }\n        sort(s.begin(), s.end());\n        \n        // cumulative sums\n        sm.push_back(0);\n        for(int i=1; i<=n; i++){\n            sm.push_back(sm[i-1]+s[i-1]);\n        }\n        \n        // Diff between sums is total skills available\n        // among p players.\n        \n        // s[i]*p = total skills needed\n        \n        // difference of total skills and skills needed \n        // is training hours needed\n        \n        mn = 1000000000;\n        for(int i=p-1; i<n; i++){\n            mn = min(mn,(s[i]*p)-(sm[i+1]-sm[i-p+1]));\n        }\n        cout << \"Case #\" << tc+1 << \": \" << mn << endl;\n    }\n    \n}",
                "Contributor": "mnovitia",
                "Difficulty": "easy",
                "Link": "https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050e01/00000000000698d6",
                "Name": "Training",
                "Note": "Cumulative Sums\nBig area minus small area",
                "Session": "2",
                "Solution": "Training.cpp",
                "SubmitDate": "Wed Apr 03 2019 18:01:48 GMT-0700 (PDT)"
            }
        },
        {
            "-LbfvvcbAnZyeGGHPT3O": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (LeetCode) 96\nclass Solution {\n public:\n  int count(int n, vector<int>& dp) {\n    if (dp[n] != -1) return dp[n];\n    dp[n] = 0;\n    for (int i = 1; i <= n; ++i) dp[n] += count(i - 1, dp) * count(n - i, dp);\n    return dp[n];\n  }\n\n  int numTrees(int n) {\n    vector<int> dp(n + 1, -1);\n    dp[0] = dp[1] = 1;\n    return count(n, dp);\n  }\n};\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/unique-binary-search-trees",
                "Name": "Unique Binary Search Trees",
                "Note": "Binary _Search_ Trees, not just Binary Trees - think about how the two children of a node are related",
                "Session": "2",
                "Solution": "96.cpp",
                "SubmitDate": "Thu Apr 04 2019 22:12:35 GMT-0700 (Pacific Daylight Time)"
            },
            "-Lbfvwqf16WwIccuuwiS": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (LeetCode) 210\nclass Solution {\n private:\n  static constexpr int UNVISIT = 0;\n  static constexpr int ON_PATH = 1;\n  static constexpr int VISITED = 2;\n\n public:\n  // returns whether there was a cycle (i.e. failure) - otherwise performs topo\n  // sort by adding to the result\n  bool dfs(int start, vector<int>& state, vector<vector<int>>& g,\n           vector<int>& res) {\n    if (state[start] == ON_PATH) return false;\n    state[start] = ON_PATH;\n\n    for (int v : g[start]) {\n      if (state[v] != VISITED) {\n        if (!dfs(v, state, g, res)) return false;\n      }\n    }\n\n    state[start] = VISITED;\n    res.push_back(start);\n    return true;\n  }\n\n  vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\n    vector<int> res;\n    vector<vector<int>> g(numCourses);\n    for (pair<int, int>& p : prerequisites) {\n      g[p.second].push_back(p.first);\n    }\n\n    bool ok = true;\n    vector<int> state(numCourses, UNVISIT);\n    for (int i = 0; i < numCourses; ++i) {\n      if (state[i] != VISITED) {\n        if (!dfs(i, state, g, res)) {\n          ok = false;\n          break;\n        }\n      }\n    }\n\n    if (!ok) return {};\n    for (int i = 0; i < numCourses / 2; ++i)\n      swap(res[i], res[numCourses - i - 1]);\n    return res;\n  }\n};\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/course-schedule-ii",
                "Name": "Course Schedule II",
                "Note": "",
                "Session": "2",
                "Solution": "210.cpp",
                "SubmitDate": "Tue Mar 19 2019 03:31:58 GMT-0700 (Pacific Daylight Time)"
            },
            "-LbfvyMvLHvkkk6Qctb6": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (LeetCode) 66\nclass Solution {\n  public int[] plusOne(int[] digits) {\n    boolean extra = false;\n    for (int i = digits.length - 1; i >= 0; --i) {\n      if (digits[i] == 9) {\n        digits[i] = 0;\n        if (i == 0)\n          extra = true;\n      } else {\n        ++digits[i];\n        break;\n      }\n    }\n    if (extra) {\n      int[] res = new int[digits.length + 1];\n      res[0] = 1;\n      for (int i = 1; i < res.length; ++i) {\n        res[i] = digits[i - 1];\n      }\n      return res;\n    }\n    return digits;\n  }\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/plus-one",
                "Name": "Plus One",
                "Note": "",
                "Session": "2",
                "Solution": "66.java",
                "SubmitDate": "Thu Apr 04 2019 20:26:19 GMT-0700 (Pacific Daylight Time)"
            },
            "-Lbg9B5Gt1Vrqc_dxANd": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (LeetCode) 95\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\n public:\n  // dp keeps track of a list of trees for given mn and mx values for the tree -\n  // this way we don't have to reconstruct existing trees (and it's ok to reuse\n  // them since we are ok with sharing memory here)\n  //\n  // construct trees by constructing ones with given mn and mx values - see each\n  // tree as consisting of:\n  //\n  //                  i\n  //         /                 \\\n  //  nodes in [mn,i)    nodes in (i, mx]\n  //\n  vector<TreeNode*> generateTrees(int mn, int mx,\n                                  vector<vector<vector<TreeNode*>>>& dp) {\n    if (mx < mn) return {nullptr};\n    if (mn == mx) return {new TreeNode(mn)};\n    if (dp[mn][mx].size() != 0) return dp[mn][mx];\n\n    vector<TreeNode*>& result = dp[mn][mx];\n    for (int i = mn; i <= mx; ++i) {\n      vector<TreeNode*> left = generateTrees(mn, i - 1, dp);\n      vector<TreeNode*> right = generateTrees(i + 1, mx, dp);\n      for (TreeNode* L : left) {\n        for (TreeNode* R : right) {\n          result.push_back(new TreeNode(i));\n          result.back()->left = L;\n          result.back()->right = R;\n        }\n      }\n    }\n    return result;\n  }\n\n  vector<TreeNode*> generateTrees(int n) {\n    if (n == 0) return {};\n    vector<vector<vector<TreeNode*>>> dp(n + 1,\n                                         vector<vector<TreeNode*>>(n + 1));\n    return generateTrees(1, n, dp);\n  }\n};\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/unique-binary-search-trees-ii",
                "Name": "Unique Binary Search Trees - The Sequel",
                "Note": "Look at Unique Binary Search Trees from last week",
                "Session": "2",
                "Solution": "95.cpp",
                "SubmitDate": "Thu Apr 04 2019 23:21:18 GMT-0700 (Pacific Daylight Time)"
            },
            "-LbzkicDi_dcugPM6GDY": {
                "Code": "# https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881de\r\nimport sys\r\nmin_calls = 4 # note we can get away with 4 calls as max only 15 workers will be broke\r\n# make blocks of 16 workers & we know we can never have an entire block fail\r\n\r\nnums_to_16 = [bin(i)[2:].zfill(4) for i in range(2**4)]\r\nstr_block_to_send = [''.join(nums_to_16[i][c] for i in range(2**4)) for c in range(4)]\r\n\r\nt = int(raw_input())\r\nfor case in range(t):\r\n    n,b,f = map(int,raw_input().split())\r\n    str_to_send = lambda s: s*(n//(2**4))+s[:n%(2**4)]\r\n    resp_str = []\r\n    for i in range(4):\r\n        print(str_to_send(str_block_to_send[i]))\r\n        sys.stdout.flush()\r\n        resp_str.append(raw_input())\r\n    worker_resp = [int(''.join(resp_str[j][i] for j in range(4)),2) for i in range(n-b)]\r\n    mal = []\r\n    exp = 0\r\n    blk = 0\r\n    i = 0\r\n    while i < n-b:\r\n        if worker_resp[i] == exp:\r\n            i+=1\r\n        else:\r\n            mal.append(str((2**4)*blk + exp))\r\n        exp = (exp+1)%(2**4)\r\n        if exp == 0:\r\n            blk+=1\r\n    while (2**4)*blk + exp != n:\r\n        mal.append(str((2**4)*blk + exp))\r\n        exp = (exp+1)%(2**4)\r\n        if exp == 0:\r\n            blk+=1\r\n    print(\" \".join(mal))\r\n    sys.stdout.flush()\r\n    verdict = raw_input()\r\n    if verdict != \"1\":\r\n        exit()",
                "Contributor": "craut",
                "Difficulty": "hard",
                "Link": "https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881de",
                "Name": "Dat Bae",
                "Note": "test case 1 can be done with enough BS ;)\n\ntest case 2 is way tougher ... look at what u did for the 1st test case and why it works. Then carefully look at the problem constraints again. U can actually get away with 1 less query. Why?",
                "Session": "2",
                "Solution": "bae.py",
                "SubmitDate": "Sun Apr 07 2019 03:32:36 GMT-0700 (Pacific Daylight Time)"
            },
            "eventuipath": {
                "Code": "",
                "Contributor": "",
                "Difficulty": "event",
                "Link": "https://www.facebook.com/events/2135534889896941/",
                "Name": "UiPath Recruiting Event",
                "Note": "ACM@UCI will be hosting a recruitment session with UiPath for new Full-time employees and Summer Interns.\nUiPath is a leading Robotic Process Automation vendor providing a complete software platform to help organizations efficiently automate business processes. They are also a Unicorn.\nBring your resume and questions! Dinner🍕🍕 will be provided!!! Please rsvp on facebook to guarantee food.",
                "Session": "1",
                "Solution": ""
            }
        },
        {
            "1": {
                "Code": "",
                "Contributor": "",
                "Difficulty": "announcement",
                "Link": " Added 2 extra problems as UVa is down",
                "Name": "Note",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            "2": {
                "Code": "",
                "Contributor": "craut",
                "Difficulty": "announcement",
                "Link": " Google Games (April 25) and Big 4 Workshop (May 14 @ 5PM) coming up, so sign up!",
                "Name": "Upcoming",
                "Note": "Should receive email from Neha about Google Games, sign up for a chance to win great prizes like a Google Backpack!\nYou can find out about interning and working in big tech companies in the Big 4 workshop.",
                "Session": "2",
                "Solution": ""
            },
            "-LcUINPG6Zawcls08msW": {
                "Code": "# https://www.hackerrank.com/challenges/queens-attack-2/problem\r\nn,k = map(int,input().strip().split())\r\nq_pos = tuple(map(int,input().strip().split()))\r\nobstacles = set(tuple(map(int,input().strip().split())) for i in range(k))\r\n\r\nv = [-1,0,1]\r\nh = [-1,0,1]\r\n\r\nsq = 0\r\n\r\ndef isValid(pos):\r\n    return not (pos[0] <= 0 or pos[1] <= 0 or pos[0] > n or pos[1] > n or pos in obstacles)\r\n\r\nfor vd in v:\r\n    for hd in h:\r\n        cur = (q_pos[0]+vd,q_pos[1]+hd)\r\n        if cur != q_pos:\r\n            while isValid(cur):\r\n                sq+=1\r\n                cur = (cur[0]+vd,cur[1]+hd)\r\n# derp solution, but whatever :P\r\n# sometimes it pays off to read the constraints...\r\nprint(sq)",
                "Contributor": "craut",
                "Difficulty": "easy",
                "Link": "https://www.hackerrank.com/challenges/queens-attack-2/problem",
                "Name": "Queens Attack II",
                "Note": "",
                "Session": "1",
                "Solution": "queens_attack-2.py",
                "SubmitDate": "Tue Feb 26 2019 12:55:16 GMT-0800 (Pacific Standard Time)"
            },
            "-LcVLAScBhx8CFiXZ2uo": {
                "Code": "#!/bin/python3\r\n\r\nimport os\r\nimport sys\r\nfrom collections import defaultdict\r\n\r\ndef get_k_dict(nums,k):\r\n    result = defaultdict(int)\r\n    for n in nums:\r\n        result[n%k]+=1\r\n    return result\r\n\r\n#\r\n# Complete the nonDivisibleSubset function below.\r\n#\r\ndef nonDivisibleSubset(k, S):\r\n    k_dict = get_k_dict(S,k)\r\n    tot = int(0 in k_dict)\r\n    for i in range(1,k//2+1):\r\n        end = k-i\r\n        if i == end:\r\n            tot+=int(i in k_dict)\r\n        else:\r\n            tot+=max(k_dict[i],k_dict[end])\r\n    return tot\r\n\r\nif __name__ == '__main__':\r\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\r\n\r\n    nk = input().split()\r\n\r\n    n = int(nk[0])\r\n\r\n    k = int(nk[1])\r\n\r\n    S = list(map(int, input().rstrip().split()))\r\n\r\n    result = nonDivisibleSubset(k, S)\r\n\r\n    fptr.write(str(result) + '\\n')\r\n\r\n    fptr.close()",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://www.hackerrank.com/challenges/non-divisible-subset/problem",
                "Name": "Non-Divisible Subset",
                "Note": "",
                "Session": "1",
                "Solution": "non-divisible_subset.py",
                "SubmitDate": "Tue Feb 19 2019 23:13:02 GMT-0800 (Pacific Standard Time)"
            },
            "-LcVLZGX3k4IzKQm8Ux7": {
                "Code": "#!/bin/python3\n\nimport os\nimport sys\n\n#\n# Complete the summingSeries function below.\n#\ndef summingSeries(n):\n    #\n    # Write your code here.\n    #\n    return (n * n) % 1000000007\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    t = int(input())\n\n    for t_itr in range(t):\n        n = int(input())\n\n        result = summingSeries(n)\n\n        fptr.write(str(result) + '\\n')\n\n    fptr.close()\n\n",
                "Contributor": "aphilipe",
                "Difficulty": "easy",
                "Link": "https://www.hackerrank.com/challenges/summing-the-n-series",
                "Name": "Summing the N series",
                "Note": "",
                "Session": "1",
                "Solution": "series.py",
                "SubmitDate": "Sat Apr 06 2019 15:22:06 GMT-0700 (PDT)"
            },
            "-LcVLi3r3l5qjgjs8KoN": {
                "Code": "\nimport sys\n\nnums = [5, 7, 9, 11, 13, 16, 17]\n\ncases, nights, max_g = map(int, input().strip().split())\n\nfor case in range(cases):\n    l = []\n    for num in nums:\n        q = ((str(num) + ' ') * 18).strip()\n        print(q)\n        sys.stdout.flush()\n        response = map(int, input().strip().split())\n        l.append(sum(response))\n    complete = False\n    one, two = len(nums) - 1, len(nums) - 2\n    \n    while l[one] != l[two]:\n        if l[one] < l[two]:\n            l[one] += nums[one]\n        else:\n            l[two] += nums[two]\n                \n    while not complete:      \n        complete = True\n        for i in range(len(l)):\n            diff = l[-1] - l[i]\n            if diff < 0 or diff % nums[i] != 0:\n                complete = False\n                break\n        if not complete:\n            l[-1] += (nums[-1] * nums[-2])\n            l[-2] = l[-1]\n    print(l[-1])\n    sys.stdout.flush()\n    response = input()\n    if response == -1:\n        break\n        ",
                "Contributor": "bbui3",
                "Difficulty": "hard",
                "Link": "https://codingcompetitions.withgoogle.com/codejam/round/0000000000051635/0000000000104f1a",
                "Name": "Golf Gophers",
                "Note": "",
                "Session": "1",
                "Solution": "golf_gophers.py",
                "SubmitDate": "Fri Apr 12 2019 21:01:18 GMT-0700 (Pacific Daylight Time)"
            },
            "-LcVLm7LJjySbj7-jy7W": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (LeetCode) 56\n/**\n * Definition for an interval.\n * struct Interval {\n *     int start;\n *     int end;\n *     Interval() : start(0), end(0) {}\n *     Interval(int s, int e) : start(s), end(e) {}\n * };\n */\nclass Solution {\n public:\n  vector<Interval> merge(vector<Interval>& intervals) {\n    // first: position of event\n    // second: 0 for start, 1 for end\n    vector<pair<int, int>> events;\n    for (Interval x : intervals) {\n      events.push_back({x.start, 0});\n      events.push_back({x.end, 1});\n    }\n\n    // sort the events - note that starts at the same pos end up before the ends\n    sort(events.begin(), events.end());\n\n    // now we can just iterate through and check whenever we have no intervals\n    // active\n    vector<Interval> res;\n    int active = 0;  // number of active intervals\n    for (const pair<int, int>& e : events) {\n      if (e.second == 0) {  // start an interval\n        if (active == 0) {\n          res.push_back(Interval(e.first, 0));\n        }\n        ++active;\n      } else {  // end an interval\n        --active;\n        if (active == 0) {\n          res.back().end = e.first;\n        }\n      }\n    }\n\n    return res;\n  }\n};\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/merge-intervals",
                "Name": "Merge Intervals",
                "Note": "",
                "Session": "1",
                "Solution": "56.cpp",
                "SubmitDate": "Sat Apr 13 2019 10:15:07 GMT-0700 (Pacific Daylight Time)"
            },
            "-LcVME7AYlY9WGScNNni": {
                "Code": "\nfrom collections import defaultdict\n\ncases = int(input().strip())\n\ndef get_matches(one, two):\n    j = 0\n    matches = 0\n    while j < len(one) and j < len(two) and one[j] == two[j]:\n        matches += 1\n        j += 1\n    return matches\n\nfor case in range(1, cases + 1):\n    n = int(input().strip())\n    words = []\n    for _ in range(n):\n        words.append(input().strip()[::-1])\n    words.sort(reverse = True)\n    count = 0\n    matched = True\n    s = defaultdict(set)\n    while matched and len(words) > 1:\n        matched = False\n        one, two = 0, 1\n        i = 0\n        most = 0\n        while i < len(words) - 1:\n            o, t = i, i + 1\n            matches = get_matches(words[o], words[t])\n            if matches > most:\n                most = matches\n                one, two = o, t\n            i += 1\n        if most > 0:\n            matched = True\n            t = (words.pop(one), words.pop(one))\n            s[most].add(t)\n    rhymes = set()\n    if len(s) > 0:\n        for i in range(max(s), 0, -1):\n            while len(s[i]) > 0:\n                match = s[i].pop()\n                if match[0][:i] in rhymes:\n                    s[i - 1].add(match)\n                    continue\n                rhymes.add(match[0][:i])\n                count += 2\n    print('Case #{}: {}'.format(case, count))",
                "Contributor": "bbui3",
                "Difficulty": "med",
                "Link": "https://codingcompetitions.withgoogle.com/codejam/round/0000000000051635/0000000000104e05",
                "Name": "Alien Rhyme",
                "Note": "",
                "Session": "2",
                "Solution": "alien_rhyme.py",
                "SubmitDate": "Fri Apr 12 2019 21:02:51 GMT-0700 (Pacific Daylight Time)"
            },
            "-LcVMQJtGLZhSYifOuoY": {
                "Code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int t; scanf(\"%d\", &t);\n    for (int i = 1; i <= t; ++i) {\n      int shy_max; char shy_arr[2000];\n      scanf(\"%d %s\", &shy_max, shy_arr);\n\n      if (shy_max == 0) {\n        cout << \"Case #\" << i << \": \" << 0 << endl;\n        continue;\n      }\n\n      // get number of peeps already there \n      int already_there = ((int) (shy_arr[0] - '0'));\n      int friends = 0;\n      for (int j = 1; j <= shy_max; ++j) {\n        int shy_factor = (int) (shy_arr[j] - '0');\n        if (shy_factor > 0) {\n          if (already_there < j) {\n            friends += (j - already_there);\n            already_there += ((j - already_there) + shy_factor);\n          } else {\n            already_there += shy_factor;\n          }\n        }\n      }\n\n      if (shy_max - already_there >= 0)\n        cout << \"Case #\" << i << \": \" << shy_max - already_there + friends << endl;\n      else \n        cout << \"Case #\" << i << \": \" << friends << endl;\n    }\n    return 0;\n}",
                "Contributor": "jtuyls",
                "Difficulty": "med",
                "Link": "https://code.google.com/codejam/contest/6224486/dashboard",
                "Name": "Standing Ovation",
                "Note": "Tricky implementation",
                "Session": "2",
                "Solution": "main.cpp",
                "SubmitDate": "Sun Apr 14 2019 21:20:55 GMT-0700 (PDT)"
            },
            "-LcVMkg4Bk9-Nzzm0guD": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 10048\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\nstruct UnionFind {\n  vector<int> p, rank;\n  UnionFind(int n) : p(n), rank(n, 0) { iota(p.begin(), p.end(), 0); }\n  int find(int i) { return i == p[i] ? i : (p[i] = find(p[i])); }\n  bool same(int i, int j) { return find(i) == find(j); }\n  bool join(int i, int j) {\n    if (!same(i, j)) {\n      int x = find(i), y = find(j);\n      if (rank[x] < rank[y]) {\n        p[x] = y;\n      } else {\n        p[y] = x;\n        if (rank[x] == rank[y]) ++rank[x];\n      }\n      return true;\n    }\n    return false;\n  }\n};\n\nstruct edge {\n  int c1, c2, d;\n  bool operator<(const edge& rhs) { return d < rhs.d; }\n};\n\n// returns max edge cost along path from cur to tgt\npair<int, bool> dfs(const vector<vector<ii>>& g, int cur, int tgt,\n                    vector<bool>& visited) {\n  visited[cur] = true;\n  if (cur == tgt) {\n    return {INT_MIN, true};\n  }\n\n  bool found = false;\n  int mx = INT_MIN;\n  for (ii v : g[cur]) {\n    if (visited[v.first]) continue;\n    pair<int, bool> next = dfs(g, v.first, tgt, visited);\n    if (next.second) {\n      found = true;\n      mx = max(v.second, next.first);\n      break;\n    }\n  }\n\n  return {mx, found};\n}\n\nint main() {\n  int c, s, q;\n  bool first = true;\n  for (int ca = 1; GET(c) && GET(s) && GET(q) && (c || s || q); ++ca) {\n    vector<edge> edges;\n    for (int i = 0; i < s; ++i) {\n      edge e;\n      GET(e.c1);\n      GET(e.c2);\n      GET(e.d);\n      edges.push_back(e);\n    }\n    sort(edges.begin(), edges.end());\n\n    if (first)\n      first = false;\n    else\n      printf(\"\\n\");\n    printf(\"Case #%d\\n\", ca);\n\n    // minimum spanning tree with Kruskal's\n    UnionFind uf(c + 1);\n    vector<edge> used;\n    for (int i = 0; i < edges.size(); ++i) {\n      if (uf.join(edges[i].c1, edges[i].c2)) {\n        used.push_back(edges[i]);\n      }\n    }\n\n    vector<vector<ii>> g(c + 1);\n    for (edge e : used) {\n      g[e.c1].push_back({e.c2, e.d});\n      g[e.c2].push_back({e.c1, e.d});\n    }\n\n    // take in each query and find max edge between them\n    for (int _ = 0; _ < q; ++_) {\n      int c1, c2;\n      GET(c1);\n      GET(c2);\n      vector<bool> visited(c + 1, false);\n      pair<int, bool> cost = dfs(g, c1, c2, visited);\n      if (!cost.second) {\n        printf(\"no path\\n\");\n      } else {\n        printf(\"%d\\n\", cost.first);\n      }\n    }\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=989",
                "Name": "Audiophobia",
                "Note": "MST",
                "Session": "2",
                "Solution": "10048.cpp",
                "SubmitDate": "Tue Mar 12 2019 11:25:50 GMT-0700 (Pacific Daylight Time)"
            },
            "-LcVMnZeASePzwGayr1h": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 11367\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nstruct node {\n  int x;\n  int fuel;\n  int price;\n\n  node(int x_, int fuel_, int price_) : x(x_), fuel(fuel_), price(price_) {}\n  bool operator<(const node& rhs) const { return price < rhs.price; }\n  bool operator>(const node& rhs) const { return price > rhs.price; }\n};\n\nint main() {\n  int n, m;\n  while (GET(n) > 0) {\n    GET(m);\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i) GET(p[i]);\n\n    vector<vector<ii>> g(n);\n    for (int i = 0; i < m; ++i) {\n      int u, v, d;\n      GET(u);\n      GET(v);\n      GET(d);\n      g[u].push_back({v, d});\n      g[v].push_back({u, d});\n    }\n\n    int q;\n    GET(q);\n    for (int i = 0; i < q; ++i) {\n      int s, e, c;\n      GET(c);\n      GET(s);\n      GET(e);\n\n      // construct a \"state-space\" graph where the state is represented by the\n      // (node, fuel) - then there are 0-weight edges between two states\n      // (x, fuel_x) and (y, fuel_x - dist(x, y)), as well as p[x]-weight edges\n      // between (x, fuel_x) and (x, fuel_x + 1)\n      vector<vector<vector<node>>> states(n, vector<vector<node>>(c + 1));\n      for (int x = 0; x < n; ++x) {\n        for (int fuel = 0; fuel <= c; ++fuel) {\n          if (fuel != c) {\n            states[x][fuel].push_back(node(x, fuel + 1, p[x]));\n          }\n          for (ii child : g[x]) {\n            int y = child.first, d = child.second;\n            if (fuel - d >= 0) {\n              states[x][fuel].push_back(node(y, fuel - d, 0));\n            }\n          }\n        }\n      }\n\n      // use dijkstra to see whether the end is reachable\n      vector<vector<int>> price(n, vector<int>(c + 1, -1));\n      price[s][0] = 0;\n      priority_queue<node, vector<node>, greater<node>> pq;\n      pq.push(node(s, 0, 0));\n      while (!pq.empty()) {\n        node x = pq.top();\n        pq.pop();\n        if (x.price > price[x.x][x.fuel] && price[x.x][x.fuel] != -1) continue;\n        for (node y : states[x.x][x.fuel]) {\n          if (price[x.x][x.fuel] + y.price < price[y.x][y.fuel] ||\n              price[y.x][y.fuel] == -1) {\n            price[y.x][y.fuel] = price[x.x][x.fuel] + y.price;\n            pq.push(node(y.x, y.fuel, price[y.x][y.fuel]));\n          }\n        }\n      }\n\n      // final output\n      if (all_of(price[e].begin(), price[e].end(),\n                 [](int i) { return i == -1; })) {\n        printf(\"impossible\\n\");\n      } else {\n        int min_price = INT_MAX;\n        for (int i = 0; i <= c; ++i) {\n          // printf(\"%d %d\\n\", i, price[e][i]);\n          if (price[e][i] < min_price && price[e][i] != -1) {\n            min_price = price[e][i];\n          }\n        }\n        printf(\"%d\\n\", min_price);\n      }\n    }\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "hard",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=0&problem=2352&mosmsg=Submission+received+with+ID+22918702",
                "Name": "Full Tank?",
                "Note": "Think about bigger graphs you can create",
                "Session": "2",
                "Solution": "11367.cpp",
                "SubmitDate": "Thu Mar 07 2019 02:19:05 GMT-0800 (Pacific Standard Time)"
            },
            "-LcVNGG7-DCzOi-6Ado-": {
                "Code": "class Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        int n = s.size();\r\n        unordered_set <char> cur;\r\n        int l = 0, r = 0;\r\n        int ans = 0;\r\n        int tmp =0;\r\n        \r\n        for (int l = 0;l<n;++l)\r\n        {\r\n            \r\n            while (true)\r\n            {\r\n                if (r==n) break;\r\n                auto a = cur.insert(s[r]);\r\n                if (a.second ==false)\r\n                    break;\r\n                \r\n                ++r;\r\n            }\r\n            ans = max(ans, r-l);\r\n            \r\n            cur.erase(s[l]);\r\n            //ans--;\r\n            \r\n        }\r\n        return ans;\r\n    }\r\n};",
                "Contributor": "junliw1",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/longest-substring-without-repeating-characters",
                "Name": "Longest Substring Without Repeating Characters",
                "Note": "",
                "Session": "2",
                "Solution": "sol.cpp",
                "SubmitDate": "Sun Apr 14 2019 20:01:56 GMT-0700 (Pacific Daylight Time)"
            },
            "-LcnL330mNXQVFZemD3d": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (LeetCode) 775\nclass Solution {\n public:\n  int countLocalInversions(vector<int>& A) {\n    int res = 0;\n    for (int i = 0; i < A.size() - 1; ++i) res += A[i] > A[i + 1];\n    return res;\n  }\n\n  // Use mergesort to count inversions\n  // L and R are inclusive\n  int countGlobalInversions(vector<int>& A, vector<int>& buf, int L, int R) {\n    if (L == R || R < L) return 0;\n\n    int res = countGlobalInversions(A, buf, L, (L + R) / 2) +\n              countGlobalInversions(A, buf, (L + R) / 2 + 1, R);\n\n    for (int i = L; i <= R; ++i) buf[i] = A[i];\n\n    int A_i = L, L_i = L, R_i = (L + R) / 2 + 1;\n    while (A_i <= R) {\n      if (L_i <= (L + R) / 2 && R_i <= R) {\n        if (buf[L_i] <= buf[R_i]) {\n          A[A_i++] = buf[L_i];\n          ++L_i;\n        } else {\n          res += (L + R) / 2 - L_i + 1;\n          A[A_i++] = buf[R_i];\n          ++R_i;\n        }\n      } else if (R_i <= R) {\n        A[A_i++] = buf[R_i];\n        ++R_i;\n      } else {\n        A[A_i++] = buf[L_i];\n        ++L_i;\n      }\n    }\n\n    return res;\n  }\n\n  bool isIdealPermutation(vector<int>& A) {\n    vector<int> sorted = A;  // because countGlobal modifies in place\n    vector<int> buf = sorted;\n    int local = countLocalInversions(A);\n    int global = countGlobalInversions(sorted, buf, 0, A.size() - 1);\n    return local == global;\n  }\n};\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/global-and-local-inversions",
                "Name": "Global and Local Inversions",
                "Note": "",
                "Session": "2",
                "Solution": "775.cpp",
                "SubmitDate": "Tue Apr 16 2019 01:10:14 GMT-0700 (Pacific Daylight Time)"
            },
            "-LcnM0RCdnh3yheDCiof": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (HackerRank) climbing-the-leaderboard\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\nint main() {\n  int n, m, x;\n  vector<ii> board;\n\n  // input\n  GET(n);\n  for (int i = 0; i < n; ++i) {\n    GET(x);\n    x = -x;\n    int rank;\n    if (i == 0) {\n      rank = 1;\n    } else {\n      if (x == board.back().first) {\n        rank = board.back().second;\n      } else {\n        rank = board.back().second + 1;\n      }\n    }\n    board.push_back({x, rank});\n  }\n\n  // output\n  GET(m);\n  int alice;\n  for (int i = 0; i < m; ++i) {\n    GET(alice);\n    auto it =\n        lower_bound(board.begin(), board.end(), make_pair(-alice, 100),\n                    [](const ii& a, const ii& b) { return a.first < b.first; });\n    if (it == board.end()) {\n      printf(\"%d\\n\", board.back().second + 1);\n    } else {\n      printf(\"%d\\n\", it->second);\n    }\n  }\n\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "easy",
                "Link": "https://www.hackerrank.com/challenges/climbing-the-leaderboard/problem",
                "Name": "Climbing the Leaderboard",
                "Note": "m log n",
                "Session": "2",
                "Solution": "climbing-the-leaderboard.cpp",
                "SubmitDate": "Wed Apr 17 2019 01:06:52 GMT-0700 (Pacific Daylight Time)"
            }
        },
        {
            "-Ld2usMrlB4zz2B_Bd7U": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Leetcode) 215\n\n// Solution 1: Quick-select - O(n)\nclass Solution {\n public:\n  // Implementation of quick-select with O(n) extra memory (for simplicity)\n  // L and R are inclusive\n  int findKthLargest(vector<int>& nums, vector<int>& buf, int k, int L, int R) {\n    if (L == R) return nums[L];\n    int pivot = nums[L + rand() % (R - L + 1)];\n\n    int L_i = L, R_i = R;\n    for (int i = L; i <= R; ++i) {\n      if (nums[i] > pivot) {\n        buf[L_i++] = nums[i];\n      } else if (nums[i] < pivot) {\n        buf[R_i--] = nums[i];\n      }\n    }\n\n    for (int i = L; i <= R; ++i) nums[i] = buf[i];\n\n    if (k < L_i) return findKthLargest(nums, buf, k, L, L_i - 1);\n    if (k > R_i) return findKthLargest(nums, buf, k, R_i + 1, R);\n    return pivot;\n  }\n\n  int findKthLargest(vector<int>& nums, int k) {\n    srand(time(NULL));\n    vector<int> buf(nums.size());\n    return findKthLargest(nums, buf, k - 1, 0, nums.size() - 1);\n  }\n};\n\n// Solution 2: Priority Queue - O(n log n)\nclass Solution {\n public:\n  int findKthLargest(vector<int>& nums, int k) {\n    priority_queue<int> pq;\n    for (int num : nums) {\n      pq.push(num);\n    }\n    for (int i = 0; i < k - 1; ++i) pq.pop();\n    return pq.top();\n  }\n};\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/kth-largest-element-in-an-array",
                "Name": "Kth Largest Element",
                "Note": "The O(n log n) solution is trivial. What about the O(n)?",
                "Session": "1",
                "Solution": "215.cpp",
                "SubmitDate": "Tue Apr 16 2019 01:36:40 GMT-0700 (Pacific Daylight Time)"
            },
            "-Ld8IBeCGYN429z325eV": {
                "Code": "#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nvoid getTree(int l[1000][1000], string arr[], int i, int j, long n, int r, int c);\r\n\r\nint main(){\r\n    int r,c;\r\n    long n=0;\r\n    cin >> r >> c;\r\n\r\n    string arr[r];\r\n    int l[1000][1000];\r\n    string line;\r\n\r\n    for(int i=0; i<r; i++){\r\n        cin >> arr[i];\r\n        for(int j=0; j<c; j++){\r\n            l[i][j]=0;\r\n        }\r\n    }\r\n\r\n    for(int i=0; i<r; i++){\r\n        for(int j=0; j<c; j++){\r\n            if(l[i][j]==0){\r\n                n++;\r\n                getTree(l, arr, i, j, n, r, c);\r\n            }\r\n        }\r\n    }\r\n\r\n    int num, a1, a2, b1, b2;\r\n    cin >> num;\r\n    for(int i=0; i<num; i++){\r\n        cin >> a1 >> a2 >> b1 >> b2;\r\n        if(l[a1-1][a2-1]==l[b1-1][b2-1]){\r\n            if(arr[a1-1][a2-1]=='1'){\r\n                cout << \"decimal\" << endl;\r\n            }else{\r\n                cout << \"binary\" << endl;\r\n            }\r\n        }else{\r\n            cout << \"neither\" << endl;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n\r\n}\r\n\r\nvoid getTree(int l[1000][1000], string arr[], int i, int j, long n, int r, int c){\r\n    if(l[i][j]==0){\r\n        l[i][j]=n;\r\n        if(i!=0){\r\n            if(arr[i][j]==arr[i-1][j]){\r\n                getTree(l, arr, i-1, j, n, r, c);\r\n            }\r\n        }\r\n        if(i!=(r)-1){\r\n            if(arr[i][j]==arr[i+1][j]){\r\n                getTree(l, arr, i+1, j, n, r, c);\r\n            }\r\n        }\r\n        if(j!=0){\r\n            if(arr[i][j]==arr[i][j-1]){\r\n                    getTree(l, arr, i, j-1, n, r, c);\r\n            }\r\n        }\r\n        if(j!=c-1){\r\n            if(arr[i][j]==arr[i][j+1]){\r\n                    getTree(l, arr, i, j+1, n, r, c);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
                "Contributor": "mnovitia",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/10kindsofpeople",
                "Name": "10 Kinds of People",
                "Note": "BFS/DFS",
                "Session": "1",
                "Solution": "10kindsofpeople.cpp",
                "SubmitDate": "Mon Apr 22 2019 13:34:03 GMT-0700 (PDT)"
            },
            "-Ld8II-DwJ3D_rlI55rn": {
                "Code": "#include <stdio.h>\r\n\r\nint ifprime[1010];\r\nint primelist[1010];\r\n\r\nint main()\r\n{\r\n    int i,j,k = 0;\r\n    int n;\r\n    int count = 0;\r\n    for(i=2;i<1010;i++)\r\n    {\r\n        if(ifprime[i]==0)\r\n        {\r\n            for(j=2;i*j<1010;j++)\r\n            {\r\n                ifprime[i*j] = 1;\r\n            }\r\n            primelist[k] = i;\r\n            k++;\r\n        }\r\n    }\r\n    scanf(\"%d\",&n);\r\n    for(i=0;i<1000&&primelist[i]!=0;i++)\r\n    {\r\n        k = primelist[i];\r\n        while(k<=n)\r\n        {\r\n            count++;\r\n            k *= primelist[i];\r\n        }\r\n    }\r\n\r\n    if(n==1)\r\n    {\r\n        printf(\"0\\n\");\r\n    }\r\n    else\r\n    {\r\n        printf(\"%d\\n\",count);\r\n        for(i=0;i<1000&&primelist[i]!=0;i++)\r\n        {\r\n            k = primelist[i];\r\n            while(k<=n)\r\n            {\r\n                printf(\"%d \",k);\r\n                k *= primelist[i];\r\n            }\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n    return 0;\r\n}\r\n",
                "Contributor": "zhonghas",
                "Difficulty": "med",
                "Link": "http://codeforces.com/problemset/problem/577/C",
                "Name": "How to Mod",
                "Note": "number theory. ",
                "Session": "1",
                "Solution": "577C.cpp",
                "SubmitDate": "Sun Apr 21 2019 23:14:01 GMT-0700 (北美太平洋夏令时间)"
            },
            "-Ld8IJ4jsn1GWAQFR09J": {
                "Code": "#include <cstdio>\r\n\r\nusing namespace std;\r\n\r\ndouble fastpow(int a)\r\n{\r\n    double x = 1.000000011;\r\n    double result = 1.0;\r\n    while(a)\r\n    {\r\n        if(a&1)\r\n        {\r\n            result *= x;\r\n        }\r\n        x = x * x;\r\n        a >>= 1;\r\n    }\r\n    return result;\r\n}\r\n\r\nint main()\r\n{\r\n    int n,t;\r\n    scanf(\"%d%d\",&n,&t);\r\n    printf(\"%.7lf\\n\",n*fastpow(t));\r\n    return 0;\r\n}\r\n",
                "Contributor": "zhonghas",
                "Difficulty": "easy",
                "Link": "http://codeforces.com/problemset/problem/630/B",
                "Name": "Fast pow",
                "Note": "number theory, Fast power in double",
                "Session": "1",
                "Solution": "630B.cpp",
                "SubmitDate": "Sun Apr 21 2019 23:15:44 GMT-0700 (北美太平洋夏令时间)"
            },
            "-Ld8IPYA7ilXv4X8zMef": {
                "Code": "import bisect,math\r\nleft,right = map(int,input().strip().split())\r\nif left == 1 and right == 1:\r\n    print(1)\r\nelse:\r\n    \r\n    to_mod = 1000000007 \r\n    ans = 0\r\n    range_list = [1,2]\r\n    left_num = [1,2]\r\n    temp = 4\r\n    while temp < right:\r\n        range_list.append(temp)\r\n        left_num.append(left_num[-2]+temp//2)\r\n        temp *= 2\r\n    range_list.append(temp)\r\n    left_num.append(left_num[-2]+temp//2)\r\n\r\n    def next_range(left):\r\n        nx = bisect.bisect_right(range_list,left)\r\n        #print(range_list[nx])\r\n        return range_list[nx]\r\n\r\n    def in_same_range(left,right):\r\n        return bisect.bisect(range_list,left) == bisect.bisect(range_list,right)\r\n\r\n    def index_to_num(left):\r\n        index = bisect.bisect(range_list,left) - 1\r\n        #print(index,left_num[index],left)\r\n        return left_num[index] + 2*(left - range_list[index])\r\n\r\n    def cal_sum(left_num,right_num):\r\n        right_seq,left_seq = right_num//2 + (1 if right_num%2!=0 else 0),left_num//2 - \\\r\n                             (1 if right_num%2==0 else 0)\r\n        #print(right_seq,left_seq)\r\n        result = right_seq**2 - left_seq**2\r\n        if left_num%2 == 0:\r\n            result = result - left_seq + right_seq\r\n        return result\r\n\r\n    def cal_left_to_right(left):\r\n        #print(range_list,left)\r\n        add_index = bisect.bisect(range_list,left)-1\r\n        add = range_list[add_index]\r\n        return left_num[add_index] + 2*(add - 1)\r\n\r\n    while left <= right:\r\n        if in_same_range(left,right):\r\n            left_number = index_to_num(left)\r\n            right_number = index_to_num(right)\r\n            ans += cal_sum(left_number,right_number)%to_mod\r\n            break\r\n        else:\r\n            left_number = index_to_num(left)\r\n            right_number = cal_left_to_right(left)\r\n            ans += cal_sum(left_number,right_number)%to_mod\r\n            left = next_range(left)\r\n\r\n    print(ans%to_mod)\r\n\r\n",
                "Contributor": "renjied",
                "Difficulty": "hard",
                "Link": "https://codeforces.com/contest/1151/problem/C",
                "Name": "Problem for Nazar",
                "Note": "Pure math, number series",
                "Session": "1",
                "Solution": "C.py",
                "SubmitDate": "Thu Apr 18 2019 21:09:49 GMT-0700 (Pacific Daylight Time)"
            },
            "-Ld8Icdg1ENXFAheJQ0e": {
                "Code": "/**\n * @param {number} n\n * @return {number}\n */\nvar magicalString = function(n) {\n    // String from the problem description\n    string = [1, 2, 2, 1,\n              1, 2, 1, 2, \n              2, 1, 2, 2, \n              1, 1, 2, 1, \n              1, 2, 2];\n    // Index of the numer of next occurances\n    index = 12;\n    // Expand string to needed length\n    while (string.length < n) {\n        last = string[string.length - 1];\n        next = (last == 1) ? 2 : 1;\n        string.push(next);\n        if (string[index] == 2) string.push(next);\n        index++;\n    }\n    // Count occurances of 1\n    c = 0;\n    for (i = 0; i < n; i++) {\n        if (string[i] != 1) continue;\n        c++;\n    }\n    return c;\n};\n",
                "Contributor": "aphilipe",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/magical-string",
                "Name": "Magical String",
                "Note": "",
                "Session": "2",
                "Solution": "MagicalString.js",
                "SubmitDate": "Tue Apr 16 2019 14:22:23 GMT-0700 (PDT)"
            },
            "-LdCCH-el8OyJtG11ICb": {
                "Code": "print('gn'[input()>input()]+'o')",
                "Contributor": "mnovitia",
                "Difficulty": "easy",
                "Link": "https://open.kattis.com/problems/aaah",
                "Name": "Aaah! (Code Golf challenge: 32 bytes)",
                "Note": "Code Golf: Try to beat 32 bytes :)",
                "Session": "2",
                "Solution": "aaah.py",
                "SubmitDate": "Mon Apr 22 2019 14:08:00 GMT-0700 (PDT)"
            },
            "-LdLdDk-CrWSkkUPC85Y": {
                "Code": "#!/bin/python3\r\n\r\nimport os\r\nimport sys\r\nimport heapq\r\nfrom collections import defaultdict,deque\r\n\r\n# pretty involved problem, but solution comes down to 4 concepts:\r\n## 1) prove why shortest path has to be on mst (distinct edge wts & powers of 2 only)\r\n## 2) implement mst using union-find -> amortized O(M log M)\r\n## 3) count how many paths each edge of mst is part of between 2 nodes\r\n###  i) Find # of each nodes in a given direction for each edge (leaves form base cases)\r\n###  ii) DP + DFS -> O(N)\r\n## 4) fast way to compute final sum at end using << (binary digits will be in 10**5...)\r\n\r\n# concept 2\r\ndef mst(e,n):\r\n    faction_arr = list(range(n+1)) # union-find tree\r\n    edges = sorted([(e[k],k[0],k[1]) for k in e]) # smallest edges 1st\r\n\r\n    def find_parent(node): # find updates parent so subsequent finds become O(1)\r\n        root = node\r\n        while faction_arr[root] != root:\r\n            root = faction_arr[root]\r\n        faction_arr[node] = root\r\n        return faction_arr[node]\r\n    \r\n    i=0\r\n    mst_edges = {}\r\n    while len(mst_edges)< n-1: # n-1 edges in mst\r\n        w,s,d = edges[i]\r\n        if find_parent(s) != find_parent(d):\r\n            faction_arr[find_parent(d)] = find_parent(s) # absorb to smaller node\r\n            mst_edges[(s,d)] = w\r\n        i+=1\r\n    return mst_edges\r\n\r\n# concept 3\r\ndef get_edge_cnts(e): \r\n    g = defaultdict(dict) # dp \"table\", stores # nodes in that direction of the tree\r\n    for s,d in e:\r\n        g[s][d] = -1\r\n        g[d][s] = -1\r\n    n = len(g)\r\n    visited = set()# not really necessary, but reduces operations from 2N -> N (why is left as an exercise to the reader 😉)\r\n    for node in range(1,n+1):\r\n        if node not in visited:# note if node has gone through the while all its edges are properly labeled & shouldn't be processed again\r\n            q = deque()\r\n            q.append((0,node)) # q stores parent & node to investigate\r\n            while len(q) > 0:\r\n                p,cur = q.pop()\r\n                if len(g[cur]) == 1: # base case\r\n                    for dest in g[cur]: # *should* only loop once\r\n                        g[cur][dest] = n-1\r\n                        g[dest][cur] = 1\r\n                else:# worst case this step will go through entire graph but it only does that once as then all nodes become visited & don't get visited again\r\n                    unk = set()\r\n                    n_other_child = 0\r\n                    for dest in set(g[cur])-{p}:# check to see if all edges except for parent are known\r\n                        if g[cur][dest] == -1:\r\n                            unk.add(dest)\r\n                        else:\r\n                            n_other_child+=g[cur][dest]\r\n                    if len(unk) == 0: # parent is source edge, can be calculated only if all other edge values are known\r\n                        g[p][cur] = n_other_child+1\r\n                        g[cur][p] = n - g[p][cur]\r\n                    else:# if unknown edges exist, they need to be computed 1st. Since this is tree -> no cycles\r\n                        q.append((p,cur))# recompute this one later\r\n                        for d in unk:\r\n                            q.append((cur,d))# compute children (dfs crawl)\r\n                visited.add(cur)\r\n    return {(s,d):g[s][d]*g[d][s] for s in g for d in g[s] if s<d}\r\n    \r\nif __name__ == '__main__':\r\n    n,m = map(int,input().split())\r\n    edges = {}\r\n    for i in range(m):\r\n        s,d,c = map(int,input().split())\r\n        if s>d:\r\n            s,d = d,s\r\n        if (s,d) not in edges or c < edges[(s,d)]:# NOTE: can have multiple edges between the same nodes\r\n            edges[(s,d)] = c\r\n    edges = mst(edges,n)\r\n    edge_cnts = get_edge_cnts(edges)\r\n    tot_sum = 0\r\n    # concept 4\r\n    for s,d in edges:\r\n        tot_sum+= edge_cnts[(s,d)]<<edges[(s,d)]# note c*2^w == (...((c*2)*2)...*2)\r\n    print(bin(tot_sum)[2:])# python magic \\o/\r\n",
                "Contributor": "craut",
                "Difficulty": "hard",
                "Link": "https://www.hackerrank.com/challenges/johnland/problem",
                "Name": "Roads in Hackerland",
                "Note": "note that each edge has a DISTINCT weight & the weights can only be powers of 2...",
                "Session": "2",
                "Solution": "johnland.py",
                "SubmitDate": "Thu Apr 25 2019 00:00:07 GMT-0700 (Pacific Daylight Time)"
            }
        },
        {
            "-Ldjb_JRadModMivofvW": {
                "Code": "package main\n\nimport \"fmt\"\n\nfunc test(z int) {\n\tvar p, q int\n\tfmt.Scan(&p, &q)\n\n\txs := make([]int, p)\n\tys := make([]int, p)\n\tds := make([]string, p)\n\tfor i := 0; i < p; i++ {\n\t\tvar x, y int\n\t\tvar s string\n\t\tfmt.Scan(&x, &y, &s)\n\t\txs[i] = x\n\t\tys[i] = y\n\t\tds[i] = s\n\t}\n\n\txvotes := make(map[int]int, p)\n\tyvotes := make(map[int]int, p)\n\txvotes[0] = 0\n\tyvotes[0] = 0\n\txvotes[q] = 0\n\tyvotes[q] = 0\n\n\tfor i := 0; i < p; i++ {\n\t\tx := xs[i]\n\t\ty := ys[i]\n\t\ts := ds[i]\n\t\tif s == \"N\" {\n\t\t\tyvotes[y+1] = 0\n\t\t} else if s == \"S\" {\n\t\t\tyvotes[y-1] = 0\n\t\t} else if s == \"E\" {\n\t\t\txvotes[x+1] = 0\n\t\t} else if s == \"W\" {\n\t\t\txvotes[x-1] = 0\n\t\t}\n\t}\n\tfor i := 0; i < p; i++ {\n\t\tx := xs[i]\n\t\ty := ys[i]\n\t\ts := ds[i]\n\t\tif s == \"N\" {\n\t\t\tfor a := range yvotes {\n\t\t\t\tif a > y {\n\t\t\t\t\tyvotes[a]++\n\t\t\t\t}\n\t\t\t}\n\t\t} else if s == \"S\" {\n\t\t\tfor a := range yvotes {\n\t\t\t\tif a < y {\n\t\t\t\t\tyvotes[a]++\n\t\t\t\t}\n\t\t\t}\n\t\t} else if s == \"E\" {\n\t\t\tfor a := range xvotes {\n\t\t\t\tif a > x {\n\t\t\t\t\txvotes[a]++\n\t\t\t\t}\n\t\t\t}\n\t\t} else if s == \"W\" {\n\t\t\tfor a := range xvotes {\n\t\t\t\tif a < x {\n\t\t\t\t\txvotes[a]++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmaxX := 0\n\tmaxY := 0\n\tfor y, c := range yvotes {\n\t\tif c > yvotes[maxY] {\n\t\t\tmaxY = y\n\t\t} else if c == yvotes[maxY] && maxY > y {\n\t\t\tmaxY = y\n\t\t}\n\t}\n\tfor x, c := range xvotes {\n\t\tif c > xvotes[maxX] {\n\t\t\tmaxX = x\n\t\t} else if c == xvotes[maxX] && maxX > x {\n\t\t\tmaxX = x\n\t\t}\n\t}\n\tfmt.Printf(\"Case #%d: %d %d\\n\", z, maxX, maxY)\n}\n\nfunc main() {\n\tvar t int\n\tfmt.Scan(&t)\n\tfor i := 0; i < t; i++ {\n\t\ttest(i + 1)\n\t}\n}\n",
                "Contributor": "aphilipe",
                "Difficulty": "med",
                "Link": "https://codingcompetitions.withgoogle.com/codejam/round/0000000000051706/000000000012295c",
                "Name": "Manhattan Crepe Cart",
                "Note": "",
                "Session": "1",
                "Solution": "mcc.go",
                "SubmitDate": "Sun Apr 28 2019 11:49:58 GMT-0700 (PDT)"
            },
            "-LdjbiC8MYfpbHwp7ReJ": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (LeetCode) 79\nclass Solution {\n public:\n  int dr[4] = {-1, 0, 1, 0};\n  int dc[4] = {0, -1, 0, 1};\n\n  bool dfs(int r, int c, int i, const vector<vector<char>>& board,\n           const string& word, vector<vector<bool>>& visited) {\n    if (i == word.size()) return true;\n    if (!(r < board.size() && r >= 0 && c < board[0].size() && c >= 0) ||\n        visited[r][c])\n      return false;\n    visited[r][c] = true;\n\n    bool ok = false;\n    if (word[i] == board[r][c]) {\n      for (int j = 0; j < 4; ++j) {\n        if (!ok) ok |= dfs(dr[j] + r, dc[j] + c, i + 1, board, word, visited);\n      }\n    }\n    visited[r][c] = false;\n    return ok;\n  }\n\n  bool exist(vector<vector<char>>& board, const string& word) {\n    int rows = board.size();\n    int cols = board[0].size();\n    if (word.size() > rows * cols) return false;\n    vector<vector<bool>> visited(rows, vector<bool>(cols, false));\n    for (int r = 0; r < rows; ++r) {\n      for (int c = 0; c < cols; ++c) {\n        if (board[r][c] == word[0]) {\n          if (dfs(r, c, 0, board, word, visited)) return true;\n        }\n      }\n    }\n    return false;\n  }\n};\n",
                "Contributor": "btjanaka",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/word-search",
                "Name": "Word Search",
                "Note": "DFS",
                "Session": "1",
                "Solution": "79.cpp",
                "SubmitDate": "Sun Apr 21 2019 23:50:12 GMT-0700 (Pacific Daylight Time)"
            },
            "-LdjcijwlQqX9WuYKI8b": {
                "Code": "#include <stdio.h>\r\n\r\nint main()\r\n{\r\n    long long x1,y1,x2,y2;\r\n    long long result;\r\n    scanf(\"%I64d%I64d%I64d%I64d\",&x1,&y1,&x2,&y2);\r\n    if((y2-y1)%2==0)\r\n    {\r\n        result = ((y2-y1)/2+1) * ((x2-x1)/2+1) + ((y2-y1)/2) * ((x2-x1)/2);\r\n    }\r\n    else\r\n    {\r\n        result = ((y2-y1+1)/2) * (x2-x1+1);\r\n    }\r\n    printf(\"%I64d\\n\",result);\r\n    return 0;\r\n}\r\n",
                "Contributor": "zhonghas",
                "Difficulty": "easy",
                "Link": "http://codeforces.com/problemset/problem/630/E",
                "Name": "A rectangle",
                "Note": "finding formula",
                "Session": "1",
                "Solution": "630E.cpp",
                "SubmitDate": "Sun Apr 21 2019 23:23:15 GMT-0700 (北美太平洋夏令时间)"
            },
            "-LdjmWbVabyufcH2yy-Z": {
                "Code": "#const = 10**13\r\nif __name__ == '__main__':\r\n    file = open(\"Alarge.in\",'r')\r\n    write_file = open('output.txt','w')\r\n    T = int(file.readline().strip())\r\n    pi = 3.1415926535\r\n    for k in range(1,T+1):\r\n        r,t = map(int,file.readline().strip().split())\r\n        radius = r+1\r\n        count = 0\r\n        #print(r,t)\r\n        left = 1; right = 1000000000000\r\n        best = 0\r\n        while left <= right:\r\n            mid = left + (right - left)//2\r\n            result = 2*mid*r + mid*((4*(mid-1)+2)//2)\r\n            #print(k,mid,result,left,right)\r\n            if result > t:\r\n                right = mid - 1\r\n            else:\r\n                best = mid\r\n                left = mid + 1\r\n        write_file.write(\"Case #{}: {}\\n\".format(k, best))\r\n\r\n    file.close()\r\n    write_file.close()\r\n",
                "Contributor": "renjied",
                "Difficulty": "med",
                "Link": "https://code.google.com/codejam/contest/2418487/dashboard",
                "Name": "Bullseye",
                "Note": "math,binary search",
                "Session": "1",
                "Solution": "A.py",
                "SubmitDate": "Thu Apr 18 2019 21:19:36 GMT-0700 (Pacific Daylight Time)"
            },
            "-LdmdQjgnOpIPf3tLgQJ": {
                "Code": "# Author: btjanaka (Bryon Tjanaka)\n# Problem: (Google Code Jam) Draupnir\n# (small input only)\nimport numpy as np\nimport sys\n\ndef grab(i):\n    print(i)\n    sys.stdout.flush()\n    return int(input())\n\nt,w = map(int, input().split())\nfor _ in range(t):\n    d = [grab(i) for i in range(1, 7)]\n    matrix = np.array([\n        [2, 1, 1, 1, 1, 1],\n        [4, 2, 1, 1, 1, 1],\n        [8, 2, 2, 1, 1, 1],\n        [16, 4, 2, 2, 1, 1],\n        [32, 4, 2, 2, 2, 1],\n        [64, 8, 4, 2, 2, 2],\n    ])\n    sol = np.linalg.solve(matrix, np.array(d))\n    print(d)\n    print(' '.join([str(int(round(x))) for x in sol]))\n    sys.stdout.flush()\n    if int(input()) == -1: break\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://codingcompetitions.withgoogle.com/codejam/round/0000000000051706/0000000000122837",
                "Name": "Draupnir",
                "Note": "",
                "Session": "2",
                "Solution": "draupnir.py",
                "SubmitDate": "Tue Apr 30 2019 18:55:38 GMT-0700 (Pacific Daylight Time)"
            },
            "-Ldmdfoe-mNELKLf-T9Q": {
                "Code": "package main\n\nimport \"fmt\"\n\ntype vec [2]int\ntype line [2]vec\n\n// Represent lines from a to b with base point c and vector m\n// Reduce m, s.t. m[0] >= 0\n// and m[0] and m[1] are coprime e.g. (12, 8) -> (3, 2)\nfunc makeLine(a, b vec) line {\n\tdx := a[0] - b[0]\n\tdy := a[1] - b[1]\n\tif dx < 0 {\n\t\tdx *= -1\n\t\tdy *= -1\n\t}\n\tfor d := 2; d <= dx && d <= dy; d++ {\n\t\tfor dx%d == 0 && dy%d == 0 {\n\t\t\tdx /= d\n\t\t\tdy /= d\n\t\t}\n\t}\n\tif dx > 1 && dy%dx == 0 {\n\t\tdy /= dx\n\t\tdx = 1\n\t}\n\tif (dy > 1 || dy < -1) && dx%dy == 0 {\n\t\tdx /= dy\n\t\tdy = 1\n\t} else if dx == 0 {\n\t\tdy = 1\n\t}\n\tm := vec{dx, dy}\n\tc := a\n\tfor m[0] > 0 && c[0] > 0 {\n\t\tc[0] -= m[0]\n\t\tc[1] -= m[1]\n\t}\n\tfor m[0] > 0 && c[0] < 0 {\n\t\tc[0] += m[0]\n\t\tc[1] += m[1]\n\t}\n\tif m[0] == 0 {\n\t\tc[1] = 0\n\t}\n\treturn line{m, c}\n}\n\nfunc maxPoints(points [][]int) int {\n\tif len(points) == 0 {\n\t\treturn 0\n\t}\n\t// Count occurances of the same point\n\t// Remeber which indicies are first occurances\n\t// Find num of occurances of most common point\n\tpMax := 1\n\tpCounts := make(map[vec]int)\n\tpStarts := make(map[vec]int)\n\tfor i, p := range points {\n\t\ta := vec{p[0], p[1]}\n\t\tif pCounts[a] == 0 {\n\t\t\tpStarts[a] = i\n\t\t}\n\t\tpCounts[a]++\n\t\tif pCounts[a] > pMax {\n\t\t\tpMax = pCounts[a]\n\t\t}\n\t}\n\n\t// Make lines from each point to each other point\n\t// Count duplicate lines\n\t// Skip duplicate points\n\tlines := make(map[line]int)\n\tlineStarters := make(map[line]int)\n\tfor i, p := range points {\n\t\ta := vec{p[0], p[1]}\n\t\tif pStarts[a] != i {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor j, q := range points[i+1:] {\n\t\t\tb := vec{q[0], q[1]}\n\t\t\tif pStarts[b] != i+1+j {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tl := makeLine(a, b)\n\t\t\tif lines[l] == 0 {\n\t\t\t\tlines[l] += pCounts[a]\n\t\t\t\tlines[l] += pCounts[b]\n\t\t\t\tlineStarters[l] = i\n\t\t\t} else if lineStarters[l] == i {\n\t\t\t\tlines[l] += pCounts[b]\n\t\t\t}\n\t\t}\n\t}\n\n\t// Count line with most occurances\n\t// Equal points always lie on the same line\n\tc := pMax\n\tfor _, x := range lines {\n\t\tif x > c {\n\t\t\tc = x\n\t\t}\n\t}\n\treturn c\n}\n",
                "Contributor": "aphilipe",
                "Difficulty": "hard",
                "Link": "https://leetcode.com/problems/max-points-on-a-line",
                "Name": "Max Points on a Line",
                "Note": "Avoid floats, represent slopes as vectors\nFind common line representation, use hash table",
                "Session": "2",
                "Solution": "pol.go",
                "SubmitDate": "Tue Apr 16 2019 13:23:38 GMT-0700 (PDT)"
            },
            "-Ldmdpq5f2AGaEynw4_Q": {
                "Code": "#include<iostream>\r\nusing namespace std;\r\nint main(){\r\n\tint k,n,w,t;\r\n\tcin>>k>>n>>w;\r\n\tt = (w * (w+1) / 2) * k;\r\n\tt -= n;\r\n\tif(t > 0)\r\n\t\tcout<<t;\r\n\telse\r\n\t\tcout<<\"0\";\r\n\treturn 0;\r\n}",
                "Contributor": "pooyak",
                "Difficulty": "easy",
                "Link": "http://codeforces.com/problemset/problem/546/A",
                "Name": "Soldier and Bananas",
                "Note": "good for code golfing",
                "Session": "2",
                "Solution": "546A.cpp",
                "SubmitDate": "Mon Apr 15 2019 16:39:40 GMT-0700 (Pacific Daylight Time)"
            },
            "-LdpkVPEATQCW13npcNe": {
                "Code": "# Author: btjanaka (Bryon Tjanaka)\n# Problem: (UVa) 247\n\nimport sys\nfrom collections import defaultdict\n\n\ndef kosaraju(g, g_rev):\n    order = []\n    visited = set()\n\n    def visit(u):\n        visited.add(u)\n        for v in g[u]:\n            if v not in visited:\n                visit(v)\n        order.append(u)\n\n    for u in g:\n        if u not in visited: visit(u)\n\n    components = []\n    visited.clear()\n\n    def build_comp(u):\n        components[-1].append(u)\n        visited.add(u)\n        for v in g_rev[u]:\n            if v not in visited:\n                build_comp(v)\n\n    for u in order[::-1]:\n        if u not in visited:\n            components.append([])\n            build_comp(u)\n\n    return components\n\n\ndef main():\n    case = 1\n    while True:\n        # input\n        n, m = map(int, input().split())\n        if n == 0 and m == 0: break\n        g, g_rev = defaultdict(set), defaultdict(set)\n        for _ in range(m):\n            u, v = input().strip().split()\n            g[u].add(v)\n            g[v]\n            g_rev[v].add(u)\n            g_rev[u]\n\n        # output\n        if case != 1: print()\n        print(f\"Calling circles for data set {case}:\")\n        for c in kosaraju(g, g_rev):\n            print(\", \".join(c))\n\n        case += 1\n\n\nmain()\n",
                "Contributor": "btjanaka",
                "Difficulty": "easy",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=0&problem=183",
                "Name": "Calling Circles",
                "Note": "",
                "Session": "2",
                "Solution": "247.py",
                "SubmitDate": "Wed May 01 2019 16:36:24 GMT-0700 (Pacific Daylight Time)"
            }
        },
        {
            "-LeBJ4zPJH3iQ54xc6UT": {
                "Code": "def maxSubsetSum(arr):\r\n    \r\n    dp = [0 for i in range(len(arr))]\r\n    dp[0] = arr[0]\r\n    dp[1] = max(arr[0],arr[1])\r\n    currmax = dp[1]\r\n    for i in range(2,len(arr)):\r\n        dp[i] = max(arr[i],currmax,dp[i-2]+arr[i])\r\n        \r\n        currmax = dp[i]\r\n\r\n    return dp[-1]",
                "Contributor": "bwakasa",
                "Difficulty": "easy",
                "Link": "https://www.hackerrank.com/challenges/max-array-sum/problem",
                "Name": "Max Array Sum",
                "Note": "",
                "Session": "1",
                "Solution": "maxarraysum.py",
                "SubmitDate": "Sun Apr 28 2019 13:12:36 GMT-0700 (Pacific Daylight Time)"
            },
            "-LeBJ93Te8bEw-bhMI6j": {
                "Code": "# Author: btjanaka (Bryon Tjanaka)\n# Problem: (Google Code Jam) Power Arrangers\n\nimport sys\nfrom collections import defaultdict\n\n# Main idea:\n# - if we look at all the first letters we know what first letter is lacking, and\n#   we can then determine the first letter of the missing permutation\n# - then from the one with that first letter, we can look for the second letter,\n#   and then third\n# - fourth is a bit of a special case since you only need 1 piece of info then\n#\n# Query count: 119 for A1, 23 for A2, 5 for A3, 1 for A4 - 148 total\n\n\ndef query(k):\n    print(k)\n    sys.stdout.flush()\n    return input().strip()\n\n\nt, f = map(int, input().split())\nfor ca in range(t):\n    perms = [\"\" for _ in range(119)]\n    ans = \"\"\n    used = {'A', 'B', 'C', 'D', 'E'}\n\n    # progressively narrow down remaining letters\n    for j in range(1, 5):\n        letters = defaultdict(int)\n        for i in range(119):\n            if perms[i] == ans:\n                q = query(5 * i + j)\n                perms[i] += q\n                letters[q] += 1\n        a = min(letters, key=lambda x: letters[x])\n        used.remove(a)\n        if j == 4: ans += list(used)[0]\n        ans += a\n\n    print(ans)\n    sys.stdout.flush()\n\n    if input() == 'N': break\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://codingcompetitions.withgoogle.com/codejam/round/00000000000516b9/0000000000134e91#",
                "Name": "Power Arrangers",
                "Note": "How can you narrow down the possibilities in the last permutation?",
                "Session": "2",
                "Solution": "power-arrangers.py",
                "SubmitDate": "Sat May 04 2019 04:42:09 GMT-0700 (Pacific Daylight Time)"
            },
            "-LeBKFpPLgHSeFx4TRXD": {
                "Code": "#include <bits/stdc++.h>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nlong long result = 0;\r\nlong long n;\r\nstring num;\r\n\r\nset<string> visited[20];\r\n\r\nlong long get_prod(string str)\r\n{\r\n    long long prod = 1;\r\n    for(int i=0;i<str.length();i++)\r\n    {\r\n        prod *= (long long)(str[i]-'0');\r\n    }\r\n    return prod;\r\n}\r\n\r\nvoid dfs(string str, int sub)\r\n{\r\n    if(sub>str.length())\r\n    {\r\n        return;\r\n    }\r\n    if(str[0]=='1' && sub==0)\r\n    {\r\n        //dfs(num.substr(1),0);\r\n    }\r\n    if(visited[sub].find(str)==visited[sub].end())\r\n    {\r\n        //cout << str << endl;\r\n        visited[sub].insert(str);\r\n        long long x = atoll(str.c_str());\r\n        if(x<=n)\r\n        {\r\n            //cout << str << \" \" << x << \" \" << result << endl;\r\n            result = max(result,get_prod(str));\r\n        }\r\n\r\n\r\n        dfs(str,sub+1);\r\n        if(str[sub]>'1')\r\n        {\r\n            str[sub] = str[sub]-1;\r\n            dfs(str,sub+1);\r\n        }\r\n        str[sub] = '9';\r\n        dfs(str,sub+1);\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n\r\n    cin >> num;\r\n    n = atoi(num.c_str());\r\n    dfs(num,0);\r\n    //printf(\"%d\\n\",n);\r\n    if(num[0]=='1')\r\n    {\r\n        dfs(num.substr(1),0);\r\n    }\r\n    cout << result << endl;\r\n    return 0;\r\n}\r\n",
                "Contributor": "zhonghas",
                "Difficulty": "med",
                "Link": "https://codeforces.com/contest/1143/problem/B",
                "Name": "Nirvana",
                "Note": "math, brute force",
                "Session": "1",
                "Solution": "B.cpp",
                "SubmitDate": "Sun Apr 07 2019 22:06:37 GMT-0700 (北美太平洋夏令时间)"
            },
            "-LeNzJQQb6gHo5G4XLPT": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (LeetCode) 10\n// Idea: simulate with an NFA\nclass Solution {\n public:\n  bool isMatch(string s, string p) {\n    // separate into tokens - easier to parse\n    vector<pair<char, bool>> regex;\n    for (int i = 0; i < p.size(); ++i) {\n      bool star = false;\n      if (i + 1 < p.size() && p[i + 1] == '*') star = true;\n      regex.push_back({p[i], star});\n      if (star) ++i;\n    }\n\n    // initial states - include any stars at the beginning of the string\n    unordered_set<int> states = {0};\n    for (int i = 1; i <= regex.size() && regex[i - 1].second; ++i) {\n      states.insert(i);\n    }\n\n    // simulate the NFA\n    for (char ch : s) {\n      // debugging\n      // printf(\"%c:\", ch);\n      // for(int cur : states) printf(\" %d\", cur);\n      // printf(\"\\n\");\n\n      // find the next set of states\n      unordered_set<int> next;\n      for (int cur : states) {\n        if (cur == regex.size()) continue;  // the last state is a dead state\n        bool star = regex[cur].second;\n        if (regex[cur].first == '.' || regex[cur].first == ch) {\n          next.insert(cur + 1);\n          if (star) next.insert(cur);\n        }\n      }\n\n      // add in epsilon transitions\n      unordered_set<int> next_with_epsilon;\n      for (int cur : next) {\n        next_with_epsilon.insert(cur);\n        for (int i = cur + 1; i <= regex.size() && regex[i - 1].second; ++i) {\n          next_with_epsilon.insert(i);\n        }\n      }\n\n      states = move(next_with_epsilon);\n    }\n\n    return states.find(regex.size()) != states.end();\n  }\n};\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/regular-expression-matching",
                "Name": "RegEx Matching",
                "Note": "Simulate an NFA (Nondeterministic Finite Automaton)",
                "Session": "2",
                "Solution": "10.cpp",
                "SubmitDate": "Wed May 08 2019 00:20:48 GMT-0700 (Pacific Daylight Time)"
            },
            "-LeNzTBzhfZ4OSzEhQj6": {
                "Code": "n, m = map(int,input().strip().split())\r\nmatrix1 = []\r\nmatrix2 = []\r\nfor i in range(n):\r\n    matrix1.append([int(i) for i in input().strip().split()])\r\n\r\nfor i in range(n):\r\n    matrix2.append([int(i) for i in input().strip().split()])\r\n\r\ndef check_row(matrix):\r\n    for i in range(n):\r\n        for j in range(1,m):\r\n            if matrix[i][j] <= matrix[i][j-1]:\r\n                return False\r\n    return True\r\n\r\ndef check_col(matrix):\r\n    for j in range(m):\r\n        for i in range(n - 1):\r\n            if matrix[i + 1][j] <= matrix[i][j]:\r\n                return False\r\n    return True\r\n\r\ndef is_quare_sorted(left_up,right_up,left_down,right_down):\r\n    return left_up<right_up and left_up < left_down \\\r\n           and right_up < right_down and left_down < right_down\r\n\r\nis_sorted = True\r\nif n == 1:\r\n    for j in range(1,m):\r\n        if matrix1[0][j] <= matrix1[0][j-1]:\r\n            temp = matrix1[0][j]\r\n            matrix1[0][j] = matrix2[0][j]\r\n            matrix2[0][j] = temp\r\nelif m == 1:\r\n    for j in range(n - 1):\r\n        if matrix1[j][0] >= matrix1[j + 1][0]:\r\n            temp = matrix1[j][0]\r\n            matrix1[j][0] = matrix2[j][0]\r\n            matrix2[j][0] = temp\r\nelse:\r\n    for i in range(n - 1):\r\n        for j in range(1,m):\r\n            if not is_quare_sorted(matrix1[i][j-1],matrix1[i][j],matrix1[i+1][j-1],matrix1[i+1][j]):\r\n                hold1 = matrix1[i][j-1]\r\n                hold2 = matrix2[i][j-1]\r\n                #print(1)\r\n                if is_quare_sorted(hold2,matrix1[i][j],\\\r\n                    matrix1[i+1][j-1],matrix1[i+1][j]) and \\\r\n                    is_quare_sorted(hold1,matrix2[i][j],\\\r\n                    matrix2[i+1][j-1],matrix2[i+1][j]):\r\n                    #print(2)\r\n                    matrix1[i][j-1] = hold2\r\n                    matrix2[i][j-1] = hold1\r\n                    continue\r\n                else:\r\n                    hold1 = matrix1[i][j]\r\n                    hold2 = matrix2[i][j]\r\n                    if is_quare_sorted(matrix1[i][j-1],hold2,\\\r\n                        matrix1[i+1][j-1],matrix1[i+1][j]) and \\\r\n                        is_quare_sorted(matrix2[i][j-1],hold1,\\\r\n                        matrix2[i+1][j-1],matrix2[i+1][j]):\r\n                        #print(3)\r\n                        matrix1[i][j] = hold2\r\n                        matrix2[i][j] = hold1\r\n                        continue\r\n                    else:\r\n                        hold1 = matrix1[i + 1][j - 1]\r\n                        hold2 = matrix2[i + 1][j - 1]\r\n                        if is_quare_sorted(matrix1[i][j-1],matrix1[i][j],\\\r\n                            hold2,matrix1[i+1][j]) and \\\r\n                            is_quare_sorted(matrix2[i][j-1],matrix2[i][j],\\\r\n                            hold1,matrix2[i+1][j]):\r\n                            #print(4)\r\n                            matrix1[i + 1][j - 1] = hold2\r\n                            matrix2[i + 1][j - 1] = hold1\r\n                            continue\r\n                        else:\r\n                            hold1 = matrix1[i + 1][j]\r\n                            hold2 = matrix2[i + 1][j]\r\n                            if is_quare_sorted(matrix1[i][j-1],matrix1[i][j],\\\r\n                                matrix1[i+1][j-1],hold2) and \\\r\n                                is_quare_sorted(matrix2[i][j-1],matrix2[i][j],\\\r\n                                matrix2[i+1][j-1],hold1):\r\n                                #print(5)\r\n                                matrix1[i + 1][j - 1] = hold2\r\n                                matrix2[i + 1][j - 1] = hold1\r\n                                continue\r\n                            else:\r\n                                hold1 = matrix1[i][j]\r\n                                hold2 = matrix2[i][j]\r\n                                hold3 = matrix1[i + 1][j - 1]\r\n                                hold4 = matrix2[i + 1][j - 1]\r\n                                if is_quare_sorted(matrix1[i][j-1],hold2,\\\r\n                                    hold4,matrix1[i+1][j]) and \\\r\n                                    is_quare_sorted(matrix2[i][j-1],hold1,\\\r\n                                    hold3,matrix2[i+1][j]):\r\n                                    #print(6)\r\n                                    matrix1[i][j] = hold2\r\n                                    matrix2[i][j] = hold1\r\n                                    matrix1[i + 1][j - 1] = hold4\r\n                                    matrix2[i + 1][j - 1] = hold3\r\n                                    continue\r\n                                else:\r\n                                    is_sorted = False\r\n                                    break\r\n\r\n\r\n\r\nif not check_row(matrix1) or not check_col(matrix1):\r\n    #print(7)\r\n    is_sorted = False\r\nif not check_row(matrix2) or not check_col(matrix2):\r\n    #print(8)\r\n    is_sorted = False\r\nif is_sorted:\r\n    print(\"Possible\")\r\nelse:\r\n    print(\"Impossible\")\r\n",
                "Contributor": "renjied",
                "Difficulty": "easy",
                "Link": "https://codeforces.com/contest/1162/problem/B",
                "Name": "Double Matrix",
                "Note": "",
                "Session": "2",
                "Solution": "B.py",
                "SubmitDate": "Tue May 07 2019 17:56:39 GMT-0700 (Pacific Daylight Time)"
            }
        },
        {
            "-LepY14L1JEZzG_A7AP5": {
                "Code": "class Solution:\r\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\r\n        dp = [False for _ in range(len(s)+1)]\r\n        wordDict = set(wordDict)\r\n        dp[0] = True\r\n        for i in range(len(s)):\r\n            for j in range(i,len(s)):\r\n                if dp[i] and s[i:j+1] in wordDict:\r\n                    dp[j+1] = True\r\n                    \r\n        \r\n        return dp[-1]",
                "Contributor": "bwakasa",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/word-break/submissions",
                "Name": "Word Break",
                "Note": "",
                "Session": "1",
                "Solution": "word_break.py",
                "SubmitDate": "Mon May 13 2019 16:38:49 GMT-0700 (Pacific Daylight Time)"
            },
            "-LepZ1MBudBSK6cS3q4n": {
                "Code": "#https://www.hackerrank.com/challenges/sam-and-substrings/problem\r\n# implementation, mod-rules, math\r\nM=10**9+7\r\nb=1\r\ns=0\r\nl=list(enumerate(input()))\r\nfor i,c in l[::-1]:\r\n    s+=int(c)*(i+1)*(b)\r\n    b=(10*b+1)%M\r\nprint(s%M)",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://www.hackerrank.com/challenges/sam-and-substrings/problem",
                "Name": "Sam and Substrings",
                "Note": "more of a math problem, implementation is what makes it tricky",
                "Session": "1",
                "Solution": "sam_and_substrings.py",
                "SubmitDate": "Mon May 13 2019 19:52:26 GMT-0700 (Pacific Daylight Time)"
            },
            "-LeuMz3TzF3dG-VJ9Pav": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (LeetCode) 787\n// Link: https://leetcode.com/problems/cheapest-flights-within-k-stops/\n// Idea: Perform a BFS that only goes K layers deep, and if dst is reached\n// within that search, you can return its distance.\n// Difficulty: medium\n// Tags: BFS, graph\nclass Solution {\n public:\n  int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst,\n                        int K) {\n    vector<vector<pair<int, int>>> g(n);\n    for (vector<int> f : flights) {\n      g[f[0]].push_back({f[1], f[2]});\n    }\n\n    int d = -1;\n    queue<tuple<int, int, int>> q;\n    q.push({src, 0, 0});\n    while (!q.empty()) {\n      int u, stops, dist;\n      tie(u, stops, dist) = q.front();\n      q.pop();\n\n      for (pair<int, int> v : g[u]) {\n        if (v.first == dst) {\n          if (d == -1 || dist + v.second < d) {\n            d = dist + v.second;\n          }\n        } else {\n          // Don't add in the node if it exceeds the distance or number of\n          // stops.\n          if (stops < K && (d == -1 || dist + v.second < d)) {\n            q.push({v.first, stops + 1, dist + v.second});\n          }\n        }\n      }\n    }\n\n    return d;\n  }\n};\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/cheapest-flights-within-k-stops",
                "Name": "Cheapest Flights Within K Stops",
                "Note": "",
                "Session": "2",
                "Solution": "787.cpp",
                "SubmitDate": "Tue May 14 2019 01:57:38 GMT-0700 (Pacific Daylight Time)"
            },
            "-LeuN-85Flu61SWeAYUz": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Kattis) kingofthewaves\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\nvoid dfs(int cur, int n, vector<string>& g, vector<int>& res,\n         vector<bool>& visited) {\n  if (visited[cur]) return;\n  visited[cur] = true;\n\n  for (int i = 0; i < n; ++i) {\n    if (g[cur][i] == '1') {\n      dfs(i, n, g, res, visited);\n    }\n  }\n\n  res.push_back(cur);\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  int n;\n  while (cin >> n) {\n    vector<string> g(n);\n    cin.get();\n    for (int i = 0; i < n; ++i) {\n      cin >> g[i];\n    }\n\n    vector<int> res;\n    vector<bool> visited(n, false);\n    dfs(0, n, g, res, visited);\n    if (res.size() == n) {\n      for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", res[i], i == n - 1 ? '\\n' : ' ');\n      }\n    } else {\n      printf(\"impossible\\n\");\n    }\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/kingofthewaves",
                "Name": "King of the Waves",
                "Note": "Graphs...",
                "Session": "2",
                "Solution": "kingofthewaves.cpp",
                "SubmitDate": "Tue May 07 2019 20:27:36 GMT-0700 (Pacific Daylight Time)"
            },
            "-LeuN4HDgL3Hm78YKS2l": {
                "Code": "class Solution:\r\n    def solve(self, board: List[List[str]]) -> None:\r\n        \"\"\"\r\n        Using union-find\r\n        \"\"\"\r\n        if len(board) == 0: # edge case\r\n            return\r\n        factions = [[(i,j) for j in range(len(board[i]))] for i in range(len(board))]\r\n        def get_root(r,c):\r\n            rr,rc = factions[r][c]\r\n            while (rr,rc) != factions[rr][rc]:\r\n                rr,rc = factions[rr][rc]\r\n            factions[r][c] = (rr,rc)\r\n            return (rr,rc)\r\n        # walk along edges doing union-find for each faction\r\n        for i in range(len(board)-1):\r\n            for j in range(len(board[i])-1):\r\n                crr,crc = get_root(i,j)\r\n                if board[i][j] == board[i+1][j]:\r\n                    lrr,lrc = get_root(i+1,j)\r\n                    factions[lrr][lrc] = (crr,crc)\r\n                if board[i][j] == board[i][j+1]:\r\n                    rrr,rrc = get_root(i,j+1)\r\n                    factions[rrr][rrc] = (crr,crc)\r\n        edgy_factions = set()\r\n        edgy_factions.update({get_root(i,0) for i in range(len(board))})\r\n        edgy_factions.update({get_root(i,-1) for i in range(len(board))})\r\n        edgy_factions.update({get_root(0,i) for i in range(len(board[0]))})\r\n        edgy_factions.update({get_root(-1,i) for i in range(len(board[0]))})\r\n        for i in range(len(board)):\r\n            for j in range(len(board[i])):\r\n                if get_root(i,j) not in edgy_factions:\r\n                    board[i][j] = 'X'",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/surrounded-regions",
                "Name": "Surrounded Regions",
                "Note": "",
                "Session": "2",
                "Solution": "surrounded_regions.py",
                "SubmitDate": "Sat May 11 2019 14:08:29 GMT-0700 (Pacific Daylight Time)"
            }
        },
        {
            "-LepZL26g-WXHu4mmlea": {
                "Code": "#include <stdio.h>\r\n\r\nlong long c(long long a,long long b)\r\n{\r\n    if(b>a)\r\n    {\r\n        return 0;\r\n    }\r\n    long long result = 1;\r\n    int i;\r\n    for(i=0;i<b;i++)\r\n    {\r\n        result *= (a-i);\r\n        result /= (i+1);\r\n    }\r\n    return result;\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    long long a,b;\r\n    //printf(\"%I64d\",c(5,6));\r\n    scanf(\"%d\",&n);\r\n    if(n==1)\r\n    {\r\n        a = 1;\r\n        b = 1;\r\n    }\r\n    else if(n==2)\r\n    {\r\n        a = 6;\r\n        b = 4;\r\n    }\r\n    a = c(n,1) + c(n,2)*4 + c(n,3)*6 + c(n,4)*4 + c(n,5);\r\n    b = c(n,1) + c(n,2)*2 + c(n,3);\r\n    printf(\"%I64d\\n\",a*b);\r\n\r\n    return 0;\r\n}\r\n",
                "Contributor": "zhonghas",
                "Difficulty": "med",
                "Link": "http://codeforces.com/problemset/problem/630/G",
                "Name": "Challenge Pennants",
                "Note": "number theory, combination numbers",
                "Session": "2",
                "Solution": "630G.cpp",
                "SubmitDate": "Sun Apr 21 2019 23:20:20 GMT-0700 (北美太平洋夏令时间)"
            },
            "-LeuN-85Flu61SWeAYUz": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Kattis) kingofthewaves\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\nvoid dfs(int cur, int n, vector<string>& g, vector<int>& res,\n         vector<bool>& visited) {\n  if (visited[cur]) return;\n  visited[cur] = true;\n\n  for (int i = 0; i < n; ++i) {\n    if (g[cur][i] == '1') {\n      dfs(i, n, g, res, visited);\n    }\n  }\n\n  res.push_back(cur);\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  int n;\n  while (cin >> n) {\n    vector<string> g(n);\n    cin.get();\n    for (int i = 0; i < n; ++i) {\n      cin >> g[i];\n    }\n\n    vector<int> res;\n    vector<bool> visited(n, false);\n    dfs(0, n, g, res, visited);\n    if (res.size() == n) {\n      for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", res[i], i == n - 1 ? '\\n' : ' ');\n      }\n    } else {\n      printf(\"impossible\\n\");\n    }\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/kingofthewaves",
                "Name": "King of the Waves",
                "Note": "Graphs...",
                "Session": "2",
                "Solution": "kingofthewaves.cpp",
                "SubmitDate": "Tue May 07 2019 20:27:36 GMT-0700 (Pacific Daylight Time)"
            },
            "-LfRfNyjT9KvQsNzM82a": {
                "Code": "class Solution {\n    // Dynamic Programming\n    // Store solutions:\n    var maxProd = mutableListOf(0, 1, 1)\n    \n    fun integerBreak(n: Int): Int {\n        // Look up solution if possible\n        if (maxProd.size > n) {\n            return maxProd[n]\n        }\n        \n        // Try all n = i + j\n        var m = 1\n        for (i in 1..n/2) {\n            var j = n - i\n            var a = integerBreak(i)\n            var b = integerBreak(j)\n            if (a < i) a = i\n            if (b < j) b = j\n            var p = a * b\n            if (p > m) m = p\n        }\n        maxProd.add(m)\n        return m\n    }\n}\n",
                "Contributor": "aphilipe",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/integer-break",
                "Name": "Integer Break",
                "Note": "Dynamic Programming",
                "Session": "2",
                "Solution": "IntegerBreak.kt",
                "SubmitDate": "Tue Apr 16 2019 14:54:52 GMT-0700 (PDT)"
            },
            "internalcomps19": {
                "Code": "",
                "Contributor": "",
                "Difficulty": "event",
                "Link": "https://open.kattis.com/contests/y6ycsy/standings ",
                "Name": "Internal Competition",
                "Note": "We'll be having an internal competition today!! Anyone is welcome to compete, there will be prizes :)))\nCONTEST LINK: https://open.kattis.com/contests/y6ycsy/standings ",
                "Session": "1",
                "Solution": ""
            }
        },
        {
            "-Lg0DNTLpQ31Hxwn4d5z": {
                "Code": "from collections import defaultdict\r\na,b,c,d = map(int,input().strip().split())\r\ndef find_root(num):\r\n    check = num<<1\r\n    lower = 0\r\n    upper = check\r\n    while lower < upper:\r\n        mid = (lower + upper) //2\r\n        result = mid*(mid-1)\r\n        if result == check:\r\n            return mid\r\n        elif result < check:\r\n            lower = mid + 1\r\n        else:\r\n            upper = mid\r\n    if lower * (lower - 1) == check:\r\n        return lower\r\n    else:\r\n        return -1\r\n\r\ndef find_seq_num(a,b,d):\r\n    total = a * d\r\n    if b > total:\r\n        return -1\r\n    one_dict = defaultdict(int)\r\n    total_sum = 0\r\n    total_num = 0\r\n    remain = b\r\n    for i in range(a):\r\n        #print(total_sum)\r\n        num = remain//(a-i)\r\n        total_sum += num*(a-i)\r\n        one_dict[i] = num\r\n        total_num += num\r\n        remain -= num*(a-i)\r\n    if total_sum == b:\r\n        one_dict[a] = d - total_num\r\n        return one_dict\r\n    else:\r\n        return -1\r\n\r\ndef count_zero_one(ans):\r\n    ones,zeros = 0,0\r\n    result = 0\r\n    for i in ans:\r\n        if i == 1:\r\n            ones += 1\r\n            result += zeros\r\n        if i == 0:\r\n            zeros += 1\r\n        \r\n    return result\r\n\r\nzero_num = find_root(a)\r\none_num = find_root(d)\r\nif a == 0 and d == 0:\r\n    if b == 0 and c == 0:\r\n        print('0')\r\n    elif b == 1 and c == 0:\r\n        print('01')\r\n    elif b == 0 and c == 1:\r\n        print('10')\r\n    else:\r\n        print('impossible')\r\nelif a == 0:\r\n    if b == 0 and c == 0:\r\n        print('1'*one_num if one_num != -1 else 'impossible')\r\n    else:\r\n        zero_num = 1\r\n        result_dict = find_seq_num(zero_num,c,one_num)\r\n        if result_dict == -1:\r\n            print(\"impossible\")\r\n        else:\r\n            ans = []\r\n            for i in range(result_dict[0]):\r\n                ans.append(1)\r\n            \r\n            for i in range(1,zero_num + 1):\r\n                ans.append(0)\r\n                for j in range(result_dict[i]):\r\n                    ans.append(1)\r\n            \r\n            if count_zero_one(ans) == b:\r\n                print(''.join(str(i) for i in ans))\r\n            else:\r\n                print('impossible')\r\nelif d == 0:\r\n    if b == 0 and c == 0:\r\n        print('0'*zero_num if zero_num != -1 else 'impossible')\r\n    else:\r\n        one_num = 1\r\n        result_dict = find_seq_num(zero_num,c,one_num)\r\n        if result_dict == -1:\r\n            print(\"impossible\")\r\n        else:\r\n            ans = []\r\n            for i in range(result_dict[0]):\r\n                ans.append(1)\r\n            \r\n            for i in range(1,zero_num + 1):\r\n                ans.append(0)\r\n                for j in range(result_dict[i]):\r\n                    ans.append(1)\r\n                \r\n            if count_zero_one(ans) == b:\r\n                print(''.join(str(i) for i in ans))\r\n            else:\r\n                print('impossible')\r\nelif zero_num == -1 or one_num == -1:\r\n    print('impossible')\r\nelse:\r\n    result_dict = find_seq_num(zero_num,c,one_num)\r\n    if result_dict == -1:\r\n        print(\"impossible\")\r\n    else:\r\n        ans = []\r\n        for i in range(result_dict[0]):\r\n            ans.append(1)\r\n        \r\n        for i in range(1,zero_num + 1):\r\n            ans.append(0)\r\n            for j in range(result_dict[i]):\r\n                ans.append(1)\r\n    \r\n        if count_zero_one(ans) == b:\r\n            print(''.join(str(i) for i in ans))\r\n        else:\r\n            print('impossible')\r\n",
                "Contributor": "renjied",
                "Difficulty": "med",
                "Link": "https://codeforces.com/gym/101933/problem/J",
                "Name": "Jumbled String",
                "Note": "Math",
                "Session": "2",
                "Solution": "JumbledString.py",
                "SubmitDate": "Thu May 23 2019 00:11:59 GMT-0700 (Pacific Daylight Time)"
            },
            "-Lg0DRBwg3iQuX0SLBbb": {
                "Code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Complete the organizingContainers function below.\nstring organizingContainers(vector<vector<int>> container) {\n    vector<int> container_caps;\n    vector<int> ball_totals;\n    for (int i = 0; i < container.size(); ++i) {\n        long long row_total = 0;\n        for (int j = 0; j < container[i].size(); ++j) {\n            row_total += container[i][j];\n        }\n\n        long long col_total = 0;\n        for (int j = 0; j < container[i].size(); ++j) {\n            col_total += container[j][i];\n        }\n\n        container_caps.push_back(row_total);\n        ball_totals.push_back(col_total);\n    }\n\n    sort(container_caps.begin(), container_caps.end());\n    sort(ball_totals.begin(), ball_totals.end());\n\n    if (container_caps == ball_totals)\n        return \"Possible\";\n    else\n        return \"Impossible\";\n}\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    int q;\n    cin >> q;\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n    for (int q_itr = 0; q_itr < q; q_itr++) {\n        int n;\n        cin >> n;\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n        vector<vector<int>> container(n);\n        for (int i = 0; i < n; i++) {\n            container[i].resize(n);\n\n            for (int j = 0; j < n; j++) {\n                cin >> container[i][j];\n            }\n\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n        }\n\n        string result = organizingContainers(container);\n\n        fout << result << \"\\n\";\n    }\n\n    fout.close();\n\n    return 0;\n}\n",
                "Contributor": "jtuyls",
                "Difficulty": "med",
                "Link": "https://www.hackerrank.com/challenges/organizing-containers-of-balls/problem",
                "Name": "Organizing Containers of Balls",
                "Note": "",
                "Session": "1",
                "Solution": "main.cpp",
                "SubmitDate": "Mon May 27 2019 13:36:07 GMT-0700 (PDT)"
            },
            "-Lg0D_Z3KJj1OOUjPswB": {
                "Code": "class Solution:\r\n    def longestPalindrome(self, s: str) -> str:\r\n        l = len(s)\r\n        M = [[0]*l for x in range(l)]\r\n        maximum = 0\r\n        ans = ''\r\n        for i in range(l-1,-1,-1):\r\n            for j in range(l-1,-1,-1):\r\n                if (i==j):\r\n                    M[i][j] = 1\r\n                    if (M[i][j] and (j-i+1>maximum)):\r\n                        ans = s[i:j+1]\r\n                        maximum = j-i+1\r\n                if (i+1==j):\r\n                    M[i][j] = s[i]==s[j]\r\n                    if (M[i][j] and (j-i+1>maximum)):\r\n                        ans = s[i:j+1]\r\n                        maximum = j-i+1\r\n\r\n                elif (j>i):\r\n                    M[i][j] = (M[i+1][j-1]) & (s[i] == s[j])\r\n                    if (M[i][j] and (j-i+1>maximum)):\r\n                        ans = s[i:j+1]\r\n                        maximum = j-i+1\r\n\r\n        return ans\r\n                    ",
                "Contributor": "junliw1",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/3sum",
                "Name": "3sum",
                "Note": "",
                "Session": "1",
                "Solution": "5.py",
                "SubmitDate": "Tue May 21 2019 19:15:03 GMT-0700 (Pacific Daylight Time)"
            },
            "-Lg0DcCqEEPOOt7tEN-G": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (LeetCode) 292\n// Title: Nim Game\n// Link: https://leetcode.com/problems/nim-game/\n// Idea: You can make a slow solution with dp, but try looking at the pattern of\n// who wins as n increases.\n// Difficulty: easy\n// Tags: math\nstruct Solution {\n  bool canWinNim(int n) { return n % 4; }\n};\n",
                "Contributor": "btjanaka",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/nim-game",
                "Name": "Nim Game",
                "Note": "",
                "Session": "1",
                "Solution": "292.cpp",
                "SubmitDate": "Tue May 21 2019 14:01:39 GMT-0700 (Pacific Daylight Time)"
            },
            "-Lg0Dk55SCLyvakTWdNs": {
                "Code": "#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\nfrom collections import defaultdict \n\n# Complete the gameOfThrones function below.\ndef gameOfThrones(s):\n    freq = defaultdict(int)\n    for char in s:\n        freq[char] += 1\n    \n    print(freq)\n    num_odds = 0\n    for num in freq.values():\n        if num % 2 == 1:\n            num_odds += 1\n        if num_odds > 1:\n            return 'NO'\n    \n    return 'YES'\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    s = input()\n\n    result = gameOfThrones(s)\n\n    fptr.write(result + '\\n')\n\n    fptr.close()\n",
                "Contributor": "jtuyls",
                "Difficulty": "easy",
                "Link": "https://www.hackerrank.com/challenges/game-of-thrones/problem",
                "Name": "Game of Thrones I",
                "Note": "Parities ",
                "Session": "1",
                "Solution": "main.py",
                "SubmitDate": "Mon May 27 2019 14:35:56 GMT-0700 (PDT)"
            }
        },
        [
            null,
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "event",
                "Link": "https://www.facebook.com/events/2365884873449837/",
                "Name": "BOARD GAME NIGHT",
                "Note": "",
                "Session": "1",
                "Solution": ""
            }
        ],
        [
            null,
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "finals",
                "Link": "",
                "Name": "",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "finals",
                "Link": "",
                "Name": "",
                "Note": "",
                "Session": "2",
                "Solution": ""
            }
        ]
    ],
    "Winter 2019": [
        null,
        [
            null,
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "easy",
                "Link": "https://www.hackerrank.com/challenges/angry-professor/problem",
                "Name": "Angry Professor",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 10152\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  int ca;\n  cin >> ca;\n  int n;\n  while (ca--) {\n    cin >> n;\n    cin.get();\n    vector<string> cur(n);\n    vector<string> des(n);\n    unordered_map<string, int> destoi;\n    string s;\n    for (int i = 0; i < n; ++i) getline(cin, cur[i]);\n    for (int i = 0; i < n; ++i) getline(cin, des[i]);\n    for (int i = 0; i < n; ++i) destoi[des[i]] = i;\n\n    // find last one that is out of order\n    int last = 0;  // index we are looking for next\n    int out = -1;  // last out of order\n    for (int i = 0; i < n; ++i) {\n      int cur_i = destoi[cur[i]];\n      if (cur_i == last) {\n        ++last;\n      } else if (cur_i > last) {\n        last = cur_i + 1;\n        out = last - 2;\n      }\n      // do nothing if cur_i < last\n    }\n\n    // output\n    for (int i = out; i >= 0; --i) {\n      printf(\"%s\n\", des[i].c_str());\n    }\n    printf(\"\n\");\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=1093",
                "Name": "ShellSort",
                "Note": "",
                "Session": "1",
                "Solution": "10152.cpp"
            },
            {
                "Code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nint main(){\n    string s;\n    cin >> s;\n    long a[s.size()+1];\n    a[0] = 0;\n    for (int i=0; i<s.size(); i++)\n    {\n        if(s[i]=='B'){\n            a[i+1] = a[i]+1;\n        }\n        else{\n            a[i+1] = a[i]-1;\n        }\n    }\n    long m = -100000, m2 = 100000;\n    int k,k2;\n    for (int i=0; i<s.size()+1; i++)\n    {\n        if(m<a[i])\n        {\n            m = a[i];\n            k = i;\n        }\n        if(m2>a[i])\n        {\n            m2 = a[i];\n            k2 = i;\n        }\n    }\n    if(k<k2)\n    {\n        cout << k+1 << \" \" << k2 << endl;\n    }\n    else{\n        cout << k2+1 << \" \" << k << endl;\n    }\n    return 0;\n}\n",
                "Contributor": "mnovitia",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/purplerain",
                "Name": "Purple Rain",
                "Note": "",
                "Session": "1",
                "Solution": "purplerain.cpp"
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "hard",
                "Link": "https://www.hackerrank.com/challenges/cloudy-day/problem",
                "Name": "Cloudy Day",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "hard",
                "Link": "https://www.hackerrank.com/challenges/array-splitting/problem",
                "Name": "Nikita and the Game",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "announcement",
                "Link": "Welcome to ACM for Winter 2019. Since you all are foolish enough to open this document I may as well give a shout out to out seminar series (Free Pizza) on Thursdays from 5-6 on some weeks more updates on Facebook page. You get to listen to interesting talks. Also if you guys are doing problems for interviews and need help with any of the problems don’t feel shy asking any of the board members. They should all be able to help. Promise that problems will get more interesting as quarter progresses.",
                "Name": "Note",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "//https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int min_so_far = 0x0f0f0f0f;\n        int profit = 0;\n        for (auto price : prices) {\n            int profit_today = price - min_so_far;\n            profit = max(profit, profit_today);\n            min_so_far = min(min_so_far, price);\n        }\n        return profit;\n    }\n};\n",
                "Contributor": "timothy4",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
                "Name": "Buy & Sell Stock",
                "Note": "",
                "Session": "2",
                "Solution": "BestTimeToBuyAndSellStock.cpp"
            },
            {
                "Code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<string> split_string(string);\n\n// Complete the unboundedKnapsack function below.\nint unboundedKnapsack(int k, vector<int> arr) {\n    bool sum[k+1];\n    sum[0]=true;\n    for(int i=1; i<=k; i++){\n        sum[i]=false;\n        for(int j=0; j<arr.size(); j++){\n            int k=i-arr[j];\n            if(k>=0){\n                if(sum[k]){\n                    sum[i]=true;\n                    break;\n                }\n            }\n        }\n    }\n    while(!sum[k]){\n        k--;\n    }return k;\n}\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    int t,n,k;\n    cin >> t;\n\n    while(t--){\n\n        cin >> n >> k;\n        vector<int> arr(n,0);\n\n\n        for(int i=0; i<n; i++){\n            cin >> arr[i];\n        }\n\n        fout << unboundedKnapsack(k, arr) << \"\n\";\n    }\n\n    fout.close();\n\n    return 0;\n}\n",
                "Contributor": "kgajulap",
                "Difficulty": "med",
                "Link": "https://www.hackerrank.com/challenges/unbounded-knapsack/problem",
                "Name": "Unbounded Knapsack",
                "Note": "",
                "Session": "2",
                "Solution": "knapsack.cpp"
            },
            {
                "Code": "#!/bin/python3\n\nimport os\nimport sys\ndef binSearch(arr, i, j, offset):\n    goal = arr[j] - offset\n    if(goal%2 == 1):    return -1\n    goal = goal // 2 + offset\n    while i <= j:\n        mid = (i+j) // 2\n        if(arr[mid] >= goal):   j = mid - 1\n        else:                   i = mid + 1\n    if i < len(arr) and arr[i] == goal:  return i\n    return -1\n\n#\n# Complete the arraySplitting function below.\n#\ndef arraySplitting(arr):\n    if(len(arr) == 1):    return 0\n    sumFromLeft = [arr[0] for _ in range(len(arr))]\n    for i in range(1, len(arr)):    sumFromLeft[i] = sumFromLeft[i-1]+arr[i]\n    maxDepth = 0\n    stack = [(0, len(sumFromLeft)-1, 0)]\n\n    while(len(stack) > 0):\n        i, j, depth = stack.pop()\n        if depth > maxDepth:\n            maxDepth = depth\n        if(i == j):  continue\n\n        offset = sumFromLeft[i-1] if (i > 0) else 0\n        split = binSearch(sumFromLeft, i, j, offset)\n        if split == -1:     continue\n        else:\n            stack.append((i, split, depth+1))\n            stack.append((split+1, j, depth+1))\n\n    return maxDepth\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    t = int(input())\n\n    for t_itr in range(t):\n        arr_count = int(input())\n\n        arr = list(map(int, input().rstrip().split()))\n\n        result = arraySplitting(arr)\n\n        fptr.write(str(result) + '\n')\n\n    fptr.close()\n",
                "Contributor": "cdipalma",
                "Difficulty": "hard",
                "Link": "https://www.hackerrank.com/challenges/array-splitting/problem",
                "Name": "Array Splitting",
                "Note": "",
                "Session": "2",
                "Solution": "array_splitting.py"
            },
            {
                "Code": "#!/bin/python3\n\nimport os\nimport sys\n\nfrom collections import defaultdict\n\ndef valueOfFriendsship(n, friendships,m):\n    # 1st get num of connected components, just need to know which sizes occur & number\n    ppl = [0]*(n+1)\n    grp = 1\n    cc = [0]\n    for i in range(1,n+1):\n        if ppl[i] == 0:\n            q = [i]\n            while len(q) > 0:\n                cur = q.pop()\n                if ppl[cur] == 0:\n                    ppl[cur] = grp\n                    for p in friendships[cur]:\n                        if ppl[p] == 0:\n                            q.append(p)\n                    cc[grp-1]+=1\n            grp+=1\n            cc.append(0)\n\n    # get num of redundant edges (edges which don't contribute to any new connected components)\n    grp_sizes = defaultdict(int)\n    for size in cc[:-1]:\n        grp_sizes[size]+=1\n    non_red_edges = sum([(grp_sz-1)*grp_sizes[grp_sz] for grp_sz in grp_sizes])\n    tot = (m-non_red_edges)\n\n    # imp insight! if there are mult connected components, smallest should be dismantled 1st\n    asc_cc = sorted(filter(lambda x: x>1,cc))\n\n    # keep track of how many rounds there are b4 a connected component gets dismantled\n    cc_lifes = [tot]*len(asc_cc)\n    for i in range(1,len(cc_lifes)):\n        cc_lifes[i] = cc_lifes[i-1]+asc_cc[i-1]-1\n\n    # now once we know the connected components and how many rounds they last before they get broken up we add up the friendship value of each \"clique\"\n    tot = 0\n    for i in range(len(cc_lifes)):\n        sz = asc_cc[i]\n        tot+=(cc_lifes[i]*sz*(sz-1))\n        tot+=((sz**3-sz)//3)\n\n    return tot\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    q = int(input())\n    for q_itr in range(q):\n        n,m = map(int,input().split())\n\n        f = defaultdict(list)\n\n\n        for _ in range(m):\n            f1,f2 = map(int, input().split())\n            f[f1].append(f2)\n            f[f2].append(f1)\n\n        ans = valueOfFriendsship(n,f,m)\n\n        fptr.write(str(ans) + '\n')\n\n    fptr.close()\n",
                "Contributor": "craut",
                "Difficulty": "hard",
                "Link": "https://www.hackerrank.com/challenges/value-of-friendship/problem",
                "Name": "Value of Friendship",
                "Note": "",
                "Session": "2",
                "Solution": "val_friend.py"
            },
            {
                "Code": "",
                "Contributor": "kgajulap",
                "Difficulty": "announcement",
                "Link": "Today you get to learn DP. If you have never heard of it now is a great time to learn. Many interview questions ask this and every programming competition has at least 2 DP questions. If you need an introduction to DP I’ll give one in the beginning of class or just come and pester me. If all these problems are too easy come and I shall give you some more challenging problems.",
                "Name": "Topic",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "btjanaka",
                "Difficulty": "announcement",
                "Link": "ACM will be having internal competitions for practice. Those that place in the top 5 will get a shirt and those in top 3 will get some nice other goodies. These competitions will occur weeks 2 4 and 7 on Tuesday from 6-8 PM at ICS 432.",
                "Name": "Internal Competition",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "mnovitia",
                "Difficulty": "event",
                "Link": "https://www.facebook.com/events/558100287990483/",
                "Name": "Girls' Coding Nights",
                "Note": "",
                "Session": "2",
                "Solution": ""
            }
        ],
        [
            null,
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Kattis) beatspread\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\n// simple absolute value:\n// x + y = sum\n// |x - y| = diff\n// just make sure to validate at every step\nint main() {\n  int ca;\n  GET(ca);\n  while (ca--) {\n    int s, d;\n    GET(s);\n    GET(d);\n    int x, y;\n    x = (s + d) / 2;\n    y = s - x;\n    if (x >= 0 && y >= 0 && x + y == s && abs(x - y) == d) {\n      printf(\"%d %d\n\", max(x, y), min(x, y));\n    } else {\n      x = (s - d) / 2;\n      y = s - x;\n      if (x >= 0 && y >= 0 && x + y == s && abs(x - y) == d) {\n        printf(\"%d %d\n\", max(x, y), min(x, y));\n      } else {\n        printf(\"impossible\n\");\n      }\n    }\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "easy",
                "Link": "https://open.kattis.com/problems/beatspread",
                "Name": "Beat the Spread",
                "Note": "",
                "Session": "1",
                "Solution": "beatspread.cpp"
            },
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Kattis) closestsums\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nint a[1010];\n\n// simply try all pairs of numbers and see which pair has the closest sum\nint main() {\n  int n;\n  for (int ca = 1; GET(n) > 0; ++ca) {\n    printf(\"Case %d:\n\", ca);\n\n    for (int i = 0; i < n; ++i) {\n      GET(a[i]);\n    }\n\n    int m;\n    GET(m);\n    while (m--) {\n      int q;\n      GET(q);\n      int res = a[0] + a[1];\n      for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n          if (abs(a[i] + a[j] - q) < abs(res - q)) {\n            res = a[i] + a[j];\n          }\n        }\n      }\n      printf(\"Closest sum to %d is %d.\n\", q, res);\n    }\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "easy",
                "Link": "https://open.kattis.com/problems/closestsums",
                "Name": "Closest Sums",
                "Note": "",
                "Session": "1",
                "Solution": "closestsums.cpp"
            },
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Kattis) acm\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\n// using a class makes it easier to keep track of things\nstruct problem {\n  int penalty;\n  bool solved;\n  problem() : penalty(0), solved(false) {}\n};\n\n// implementation problem, process all input lines and update our problem data\n// gradually\nint main() {\n  int t;\n  vector<problem> problems(26);\n\n  // get each line\n  while (GET(t) && t != -1) {\n    char ch, ans[10];\n    scanf(\" %c %s\", &ch, ans);\n    bool right = strcmp(ans, \"right\") == 0;\n    int prob = ch - 'A';\n\n    // only do something if the problem is not already solved\n    if (problems[prob].solved) {\n      continue;\n    } else {\n      if (right) {\n        problems[prob].penalty += t;\n        problems[prob].solved = true;\n      } else {\n        problems[prob].penalty += 20;\n      }\n    }\n  }\n\n  // find the solution by counting up solved and penalty\n  int tot = 0;    // solved\n  int tot_t = 0;  // penalty time\n  for_each(problems.begin(), problems.end(), [&](problem& p) {\n    if (p.solved) {\n      ++tot;\n      tot_t += p.penalty;\n    }\n  });\n\n  // print out the solution\n  printf(\"%d %d\n\", tot, tot_t);\n\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/acm",
                "Name": "ACM Contest Scoring",
                "Note": "",
                "Session": "1",
                "Solution": "acm.cpp"
            },
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Kattis) exactchange2\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\n// this problem is coin change with limited coins (specifically only one of\n// each)\nint main() {\n  int ca;\n  GET(ca);\n  int dp[20001];\n  int c[110];\n  while (ca--) {\n    // input\n    int p;\n    GET(p);\n    int n;\n    GET(n);\n    for (int i = 0; i < n; ++i) GET(c[i]);\n\n    // generate dp table - go backwards through the values to avoid repeating\n    // coins - i.e. we can only use each coin once\n    memset(dp, -1, sizeof(dp));\n    dp[0] = 0;\n    for (int j = 0; j < n; ++j) {\n      for (int i = 20000; i >= 0; --i) {\n        if (dp[i] == -1) continue;\n        int next = i + c[j];\n        if (next > 20000) continue;\n        if (dp[next] == -1)\n          dp[next] = dp[i] + 1;\n        else\n          dp[next] = min(dp[next], dp[i] + 1);\n      }\n    }\n\n    // find nearest price in our dp array and output it\n    int res;\n    for (res = p; dp[res] == -1; ++res)\n      ;\n    printf(\"%d %d\n\", res, dp[res]);\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/exactchange2",
                "Name": "Exact Change",
                "Note": "",
                "Session": "1",
                "Solution": "exactchange2.cpp"
            },
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Kattis) ith\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\n// type of queen\nenum qtype {\n  Q,   // full queen\n  RO,  // row only\n  UD,  // diagonal going up\n  DD,  // diagonal going down\n};\n\n// idea is to move across the board from left to right while keeping track of\n// which squares would be available - but we also have to add extra\n// \"semi-queens\" to the left of the queens so the squares that the queen affects\n// on its left before actually getting to them\n//\n// namely, we have to add 3 extra queens to the left of each queen:\n// - a row only queen\n// - an \"up diagonal\" queen\n// - a \"down diagonal\" queen\n//\n// DD\n//   \\n//    \\n// RO--Q\n//    /\n//   /\n// UD\nint main() {\n  int rows, cols, n;\n  while (scanf(\"%d %d %d\", &rows, &cols, &n) && (rows || cols || n)) {\n    // gives row and type of queens that are in each column\n    vector<set<pair<int, enum qtype>>> queens(cols);\n\n    // add queens\n    int rk, ck;\n    for (int i = 0; i < n; ++i) {\n      GET(rk);\n      GET(ck);\n      --rk;\n      --ck;\n      queens[ck].insert({rk, Q});  // add the actual queen\n      queens[0].insert({rk, RO});  // add the queen at the beginning of the row\n\n      // add the queen with diagonal going down\n      if (ck > rk)\n        queens[ck - rk].insert({0, DD});\n      else\n        queens[0].insert({rk - ck, DD});\n\n      // add the queen with the diagonal going up\n      int rrem = rows - rk - 1;\n      if (ck > rrem)\n        queens[ck - rrem].insert({rows - 1, UD});\n      else\n        queens[0].insert({rk + ck, UD});\n    }\n\n    // debugging\n    // for (int i = 0; i < cols; ++i) {\n    //   printf(\"%d:\", i);\n    //   for (const pair<int, enum qtype>& p : queens[i]) {\n    //     printf(\" %d(\", p.first);\n    //     switch (p.second) {\n    //       case Q:\n    //         printf(\"Q\");\n    //         break;\n    //       case RO:\n    //         printf(\"RO\");\n    //         break;\n    //       case UD:\n    //         printf(\"UD\");\n    //         break;\n    //       case DD:\n    //         printf(\"DD\");\n    //         break;\n    //     }\n    //     printf(\")\");\n    //   }\n    //   printf(\"\n\");\n    // }\n\n    // vectors store bitsets (DON'T use bools - it's too slow)\n    // 0: full\n    // 1: RO\n    // 2: UD\n    // 3: DD\n\n    // squares that are not affected\n    int tot = 0;\n\n    // two vectors for storing the board - we just switch between them between\n    // iterations instead of having one vector, creating a new one, and copying\n    // the results to it\n    vector<int> cur1(rows, 0);\n    vector<int> cur2(rows, 0);\n\n    // go across the board column by column\n    for (int c = 0; c < cols; ++c) {\n      vector<int>& cur = c % 2 == 0 ? cur1 : cur2;\n      vector<int>& next = c % 2 == 0 ? cur2 : cur1;\n\n      // add in queens that are in the current col\n      bool has_col = false;  // tells if the current column had a full queen\n      for (const pair<int, enum qtype>& p : queens[c]) {\n        int r = p.first;\n        cur[r] |= 1;  // full\n        switch (p.second) {\n          case Q:\n            cur[r] |= (1 << 4) - 1;  // turns on bits 0 to 3\n            has_col = true;\n            break;\n          case RO:\n            cur[r] |= (1 << 1);\n            break;\n          case UD:\n            cur[r] |= (1 << 2);\n            break;\n          case DD:\n            cur[r] |= (1 << 3);\n            break;\n        }\n      }\n\n      // count empty spots in cur - no spots if there are queens in this column\n      if (!has_col) {\n        for (int r = 0; r < rows; ++r) {\n          // no bits on if there is truly nothing here\n          if (!cur[r]) {\n            ++tot;\n          }\n        }\n      }\n\n      // fill next column - each row of the next column is affected by three\n      // cells in the current column\n      // cur \\n      // cur - next\n      // cur /\n      if (c != cols - 1) {\n        for (int r = 0; r < rows; ++r) {\n          next[r] = 0;\n          next[r] |= cur[r] & (1 << 1);                        // row\n          if (r < rows - 1) next[r] |= cur[r + 1] & (1 << 2);  // ud\n          if (r > 0) next[r] |= cur[r - 1] & (1 << 3);         // dd\n          if (next[r]) next[r] |= 1;\n        }\n      }\n    }\n\n    // print result once everything is summed up\n    printf(\"%d\n\", tot);\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "hard",
                "Link": "https://open.kattis.com/problems/ith",
                "Name": "God Save the ith-Queen",
                "Note": "",
                "Session": "1",
                "Solution": "ith.cpp"
            },
            {
                "Code": "",
                "Contributor": "btjanaka",
                "Difficulty": "announcement",
                "Link": "These are the questions/solutions for Internal Series Competition 1",
                "Name": "Competition",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "btjanaka",
                "Difficulty": "event",
                "Link": "https://open.kattis.com/contests/quzbxw",
                "Name": "Internal Competition 1",
                "Note": "",
                "Session": "2",
                "Solution": ""
            }
        ],
        [
            null,
            {
                "Code": "",
                "Contributor": "bwakasa",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/median-of-two-sorted-arrays/",
                "Name": "Median of Two Sorted Arrays",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "mnovitia",
                "Difficulty": "easy",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=979",
                "Name": "Jolly Jumpers",
                "Note": "",
                "Session": "1",
                "Solution": "",
                "SubmitDate": "Sun Mar 10 2019 21:27:46 GMT-0700 (Pacific Daylight Time)"
            },
            {
                "Code": "",
                "Contributor": "junliw1",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/merge-k-sorted-lists/",
                "Name": "Merge k Sorted Lists",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "jtuyls",
                "Difficulty": "easy",
                "Link": "https://www.hackerrank.com/challenges/magic-square-forming/problem?isFullScreen=false",
                "Name": "Forming a Magic Square",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "zhonghas",
                "Difficulty": "med",
                "Link": "http://codeforces.com/contest/1105/problem/C",
                "Name": "Ayoub and Lost Array",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "timothy4",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/sliding-window-maximum/ ",
                "Name": "Sliding Window Maximum",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=24&problem=3926&mosmsg=Submission+received+with+ID+22639424",
                "Name": "Short Story Competition",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "cdipalma",
                "Difficulty": "med",
                "Link": "https://codeforces.com/contest/1096/problem/B",
                "Name": "Substring Removal",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "cdipalma",
                "Difficulty": "med",
                "Link": "https://codeforces.com/contest/1096/problem/C",
                "Name": "Polygon for the Angle",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "announcement",
                "Link": " The problemset will be for the whole week. The difficulty is not accurate and will be updated after Thursday meeting ;)",
                "Name": "Note",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "renjied",
                "Difficulty": "event",
                "Link": "http://clubs.uci.edu/acm/#/events",
                "Name": "Unzipping Your Genes with Machine Learning",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "mnovitia",
                "Difficulty": "event",
                "Link": "https://www.facebook.com/events/558100287990483/",
                "Name": "Girls’ Coding Nights",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "bwakasa",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/median-of-two-sorted-arrays/",
                "Name": "Median of Two Sorted Arrays",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "/*****************************************\n*   UVA #10038 : Jolly Jumpers            *\n*   Labels     : Hashing                  *\n******************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int n;\n  while(cin >> n){\n    bool arr[3001]={};\n    int x,y;\n    string s=\"Jolly\";\n    cin >> x;\n    for(int i=0; i<n-1; i++){\n      y = x;\n      cin >> x;\n      int diff = max(x,y)-min(x,y);\n      if(arr[diff] || diff>n-1 || diff<1){\n        s = \"Not jolly\";\n      }\n      arr[diff]=true;\n    }\n    cout << s << endl;;\n  }\n\n  return 0;\n}\n",
                "Contributor": "mnovitia",
                "Difficulty": "easy",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=979",
                "Name": "Jolly Jumpers",
                "Note": "",
                "Session": "2",
                "Solution": "uva10038.cpp",
                "SubmitDate": "Sun Mar 10 2019 21:30:52 GMT-0700 (Pacific Daylight Time)"
            },
            {
                "Code": "",
                "Contributor": "junliw1",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/merge-k-sorted-lists/",
                "Name": "Merge k Sorted Lists",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool checkMagicSquare(vector<vector<int> > & arr) {\n    int sum = arr[0][0] + arr[0][1] + arr[0][2];\n    return (arr[0][0] + arr[1][0] + arr[2][0] == sum &&\n            arr[0][1] + arr[1][1] + arr[2][1] == sum &&\n            arr[0][2] + arr[1][2] + arr[2][2] == sum &&\n            arr[1][0] + arr[1][1] + arr[1][2] == sum &&\n            arr[2][0] + arr[2][1] + arr[2][2] == sum &&\n            arr[0][0] + arr[1][1] + arr[2][2] == sum &&\n            arr[0][2] + arr[1][1] + arr[2][0] == sum);\n}\n\nset<vector<vector<int> > > generateMagicSquares() {\n    int arr[9] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    set<vector<vector<int> > > magicSquares;\n    vector<vector<int> > tempArr(3, vector<int>(3));\n    do {\n        tempArr = {{arr[0], arr[1], arr[2]}, {arr[3], arr[4], arr[5]}, {arr[6], arr[7], arr[8]}};\n        if (checkMagicSquare(tempArr)) {\n            magicSquares.insert(tempArr);\n        }\n    } while (next_permutation(arr, arr+9));\n    return magicSquares;\n}\n\nint calculateDifference(const vector<vector<int> > & magic, vector<vector<int> > & original) {\n    int diff = 0;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            diff += abs(magic[i][j] - original[i][j]);\n        }\n    }\n    return diff;\n}\n\n// Complete the formingMagicSquare function below.\nint formingMagicSquare(vector<vector<int> > s) {\n    set<vector<vector<int> > > allMagicSquares = generateMagicSquares();\n    int result = 100;\n    for (set<vector<vector<int> > >::iterator it=allMagicSquares.begin(); it!=allMagicSquares.end(); ++it) {\n        result = min(result, calculateDifference(*it, s));\n    }\n    return result;\n}\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    vector<vector<int>> s(3);\n    for (int i = 0; i < 3; i++) {\n        s[i].resize(3);\n\n        for (int j = 0; j < 3; j++) {\n            cin >> s[i][j];\n        }\n\n        cin.ignore(numeric_limits<streamsize>::max(), '\n');\n    }\n\n    int result = formingMagicSquare(s);\n\n    fout << result << \"\n\";\n\n    fout.close();\n\n    return 0;\n}\n",
                "Contributor": "jtuyls",
                "Difficulty": "easy",
                "Link": "https://www.hackerrank.com/challenges/magic-square-forming/problem?isFullScreen=false",
                "Name": "Forming a Magic Square",
                "Note": "",
                "Session": "2",
                "Solution": "magic.cpp"
            },
            {
                "Code": "",
                "Contributor": "zhonghas",
                "Difficulty": "med",
                "Link": "http://codeforces.com/contest/1105/problem/C",
                "Name": "Ayoub and Lost Array",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "timothy4",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/sliding-window-maximum/ ",
                "Name": "Sliding Window Maximum",
                "Note": "",
                "Session": "2",
                "Solution": ""
            },
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 12482\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int N, L, C;\n  string s;\n  while (cin >> N >> L >> C) {\n    int lines = 1;\n    int cur_line = 0;\n    for (int i = 0; i < N; ++i) {\n      cin >> s;\n      if (cur_line + (cur_line != 0) + s.size() > C) {\n        ++lines;\n        cur_line = s.size();\n      } else {\n        cur_line += (cur_line != 0) + s.size();\n      }\n    }\n\n    printf(\"%d\n\", lines / L + (lines % L != 0));\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=24&problem=3926&mosmsg=Submission+received+with+ID+22639424",
                "Name": "Short Story Competition",
                "Note": "",
                "Session": "2",
                "Solution": "uva12482.cpp"
            },
            {
                "Code": "def tri(n):\n\treturn (n*(n+1))//2\n\nfrom collections import Counter\n\ninput()\ns = input()\nct = Counter(s)\nans = 0\n\nif len(ct.most_common(3)) == 1:\n\tans = tri(len(s))\nelse:\n\tleft = 1\n\tright = 1\n\tlc = s[0]\n\trc = s[-1]\n\twhile(s[left] == lc):\n\t\tleft += 1\n\twhile(s[len(s)-1-right] == rc):\n\t\tright += 1\n\t# print(left,right)\n\tif lc == rc:\n\t\tans = (left+1) * (right+1)\n\telse:\n\t\tans = left+right+1\n\nprint(ans % 998244353)\n",
                "Contributor": "cdipalma",
                "Difficulty": "med",
                "Link": "https://codeforces.com/contest/1096/problem/B",
                "Name": "Substring Removal",
                "Note": "",
                "Session": "2",
                "Solution": "codeforces1096b.py"
            },
            {
                "Code": "def gcd(a,b):\n\tif a == 0 or b == 0:\n\t\treturn max(a,b)\n\treturn gcd(b, a%b)\n\nt = int(input())\nfor _ in range(t):\n\tang = int(input())\n\tgc = gcd(180, ang)\n\tn = 180 // gc\n\tif ang // gc + 1 == n:\n\t\tn *= 2\n\tprint(n)\n",
                "Contributor": "cdipalma",
                "Difficulty": "med",
                "Link": "https://codeforces.com/contest/1096/problem/C",
                "Name": "Polygon for the Angle",
                "Note": "",
                "Session": "2",
                "Solution": "codeforces1096c.py"
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "announcement",
                "Link": " The problemset will be for the whole week. The difficulty is not accurate and will be updated after Thursday meeting ;)",
                "Name": "Note",
                "Note": "",
                "Session": "2",
                "Solution": ""
            }
        ],
        [
            null,
            {
                "Code": "# Author: Bryon Tjanaka\n# Problem: (Kattis) arithmetic\nprint(hex(int(input().strip(), base=8))[2:].upper())\n",
                "Contributor": "btjanaka",
                "Difficulty": "easy",
                "Link": "https://open.kattis.com/problems/arithmetic",
                "Name": "Arithmetic",
                "Note": "",
                "Session": "1",
                "Solution": "arithmetic.py"
            },
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Kattis) codecleanups\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nint d[370];\n\nint main() {\n  int n;\n  // allow multiple inputs for debugging\n  while (GET(n) > 0) {\n    for (int i = 0; i < n; ++i) {\n      GET(d[i]);\n      --d[i];\n    }\n    sort(d, d + n);\n\n    // go through days\n    int di = 0;\n    int cur_increase = 0;\n    int cur_d = 0;\n    int res = 0;\n    for (int i = 0; i < 365; ++i) {\n      while (i == d[di]) {\n        ++cur_increase;\n        ++di;\n      }\n      if (cur_d + cur_increase > 19) {\n        ++res;\n        cur_d = 0;\n        cur_increase = 0;\n      }\n      cur_d += cur_increase;\n    }\n    if (cur_increase > 0) ++res;\n\n    printf(\"%d\n\", res);\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "easy",
                "Link": "https://open.kattis.com/problems/codecleanups",
                "Name": "Code Cleanups",
                "Note": "",
                "Session": "1",
                "Solution": "codecleanups.cpp"
            },
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Kattis) bing\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\n// each node tells whether it has a next element for each letter\nstruct node {\n  int count;\n  vector<node*> next;\n  node() : count(0), next(26, nullptr) {}\n};\n\n// this is a classic trie problem (a trie is a type of data structure somewhat\n// similar to a graph)\nstruct Trie {\n  node* head;\n  Trie() : head(new node()) {}\n\n  int count(const string& s) {\n    node* itr = head;\n    for (int i = 0; i < s.size(); ++i) {\n      int ni = s[i] - 'a';\n      if (itr->next[ni] == nullptr) {\n        return 0;\n      }\n      itr = itr->next[ni];\n    }\n    return itr->count;\n  }\n\n  void insert(const string& s) {\n    node* itr = head;\n    for (int i = 0; i < s.size(); ++i) {\n      int ni = s[i] - 'a';\n      if (itr->next[ni] == nullptr) {\n        itr->next[ni] = new node();\n      }\n      ++itr->count;\n      itr = itr->next[ni];\n    }\n    ++itr->count;\n  }\n};\n\nint main() {\n  Trie tr;\n  int n;\n  GET(n);\n  string s;\n  while (n--) {\n    cin >> s;\n    printf(\"%d\n\", tr.count(s));\n    tr.insert(s);\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/bing",
                "Name": "Bing It On",
                "Note": "",
                "Session": "1",
                "Solution": "bing.cpp"
            },
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Kattis) trip\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nint c[10010];\n\nint main() {\n  int n;\n  while (GET(n) && n) {\n    int tot = 0;\n    for (int i = 0; i < n; ++i) {\n      int b, d;\n      scanf(\"%d.%d\", &b, &d);\n      c[i] = b * 100 + d;\n      tot += c[i];\n    }\n    int avg = tot / n;\n    int rem =\n        tot - avg * n;  // tells number of people who will have an extra cent\n    sort(c, c + n);  // IMPORTANT! - this way everyone who loses money will be\n                     // at the end\n\n    // greedily remove as much money as we can from the people who have above\n    // average - first remove from people who will have an extra cent and then\n    // from people who will not\n    int res = 0;\n    for (int i = n - 1; i >= n - rem; --i) {\n      if (c[i] > (avg + 1)) res += c[i] - (avg + 1);\n    }\n    for (int i = n - rem - 1; i >= 0; --i) {\n      if (c[i] > avg) res += c[i] - avg;\n    }\n    printf(\"$%d.%02d\n\", res / 100, res % 100);\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/trip",
                "Name": "The Trip",
                "Note": "",
                "Session": "1",
                "Solution": "trip.cpp"
            },
            {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Kattis) beepers\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\n// this solution uses TSP (traveling salesperson) but the input is small enough\n// that you can just go through all permutations of the beeper orderings and\n// find the one that requires the least traveling\n\nint n;\nint dist[15][15];\nint dp[15][1 << 15];\nint pos[15][2];\n\n// cur is a bitset which tells which pos we have already visited\nint tsp(int pos, int cur) {\n  // if all nodes are visited the distance is just the distance to pos 0\n  if (cur == (1 << n) - 1) return dist[pos][0];\n  if (dp[pos][cur] != -1) return dp[pos][cur];  // check dp table\n\n  // find minimum distance when going through rest of positions\n  dp[pos][cur] = INT_MAX;\n  for (int nxt = 0; nxt < n; ++nxt) {\n    if (!(cur & (1 << nxt)))\n      dp[pos][cur] =\n          min(dp[pos][cur], dist[pos][nxt] + tsp(nxt, cur | (1 << nxt)));\n  }\n  return dp[pos][cur];\n}\n\nint main() {\n  int ca;\n  GET(ca);\n  while (ca--) {\n    int x, y;\n    GET(x);\n    GET(y);\n    GET(pos[0][0]);\n    GET(pos[0][1]);\n    --pos[0][0];\n    --pos[0][1];\n    GET(n);\n    ++n;\n\n    for (int i = 1; i < n; ++i) {\n      GET(pos[i][0]);\n      GET(pos[i][1]);\n      --pos[i][0];\n      --pos[i][1];\n    }\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        dist[i][j] = abs(pos[i][0] - pos[j][0]) + abs(pos[i][1] - pos[j][1]);\n\n    memset(dp, -1, sizeof(dp));\n    printf(\"%d\n\", tsp(0, 1));\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "hard",
                "Link": "https://open.kattis.com/problems/beepers",
                "Name": "Collecting Beepers",
                "Note": "",
                "Session": "1",
                "Solution": "beepers.cpp"
            },
            {
                "Code": "",
                "Contributor": "btjanaka",
                "Difficulty": "announcement",
                "Link": "These are the questions/solutions for Internal Series Competition 2",
                "Name": "Competition",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "btjanaka",
                "Difficulty": "event",
                "Link": "https://open.kattis.com/",
                "Name": "Internal Series Competition 2 (LINK)",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "jtuyls",
                "Difficulty": "event",
                "Link": "http://clubs.uci.edu/acm/#/events",
                "Name": "Machine learning: Do we really understand it?",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "jtuyls",
                "Difficulty": "event",
                "Link": "http://clubs.uci.edu/acm/#/events",
                "Name": "Machine learning: Do we really understand it?",
                "Note": "Many machine learning models that are being applied today can grow very complex. This is why many of the models become harder and harder to understand, even by experts in the field. This talk will provide an overview of how we can tackle this problem and see how we can truly understand what our state-of-the-art machine learning models are doing today.\nBio: Jens is a junior studying computer science and engineering. Along with being extremely interested in machine learning and algorithms, he is also the tallest Belgian on campus.",
                "Session": "2",
                "Solution": ""
            }
        ],
        {
            "1": {
                "Code": "",
                "Contributor": "Arne",
                "Difficulty": "event",
                "Link": "http://clubs.uci.edu/acm/#/events",
                "Name": "Let's Go!!!",
                "Note": "Go has been gaining traction recently because of its ease of use and value to parallel computing. You could think of it as a join of the simplicity of python and the efficiency of C. In this talk he will dive into Go and see what makes it so awesome. As Arne claims by the end of the talk you will definitely say : “Go, the only programming language you will ever need”\nBio: Arne Philipeit is a senior in Computer Science and Engineering, exchange student from Trinity College Dublin, and Go-enthusiast. He also holds the socal record for solving most ICPC problems in Java, something he’s not too proud of.",
                "Session": "1",
                "Solution": ""
            },
            "-LY-Os3SPqWRixlSLo6T": {
                "Code": "",
                "Contributor": "timothy4",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/number-of-1-bits",
                "Name": "Number of 1 Bits",
                "Note": "",
                "Session": "1",
                "Solution": "",
                "SubmitDate": "Tue Feb 05 2019 16:53:14 GMT-0800 (Pacific Standard Time)"
            },
            "-LY-Osa7Hm4XlDIVfCTL": {
                "Code": "import sys\r\nfrom collections import defaultdict,deque\r\n\r\ndef bipar(e,n):\r\n    q = deque()\r\n    visited = set()\r\n    b = set()\r\n    w = set()\r\n    in_q = set()\r\n    for i in range(1,n+1):\r\n        in_q.add(i)\r\n        q.append(i)\r\n        if i not in visited:\r\n            w.add(i)\r\n        while len(q) > 0:\r\n            cur = q.pop()\r\n            if cur not in visited:\r\n                blk = cur in b\r\n                if cur in b and cur in w:\r\n                    return False\r\n                for child in e[cur]:\r\n                    if blk:\r\n                        w.add(child)\r\n                    else:\r\n                        b.add(child)\r\n                    if child not in in_q:\r\n                        q.append(child)\r\n                        in_q.add(child)\r\n                visited.add(cur)\r\n    #print(b)\r\n    #print(w)\r\n    return len(b) == len(w)\r\n\r\nfor line in sys.stdin:\r\n    n = int(line.strip())\r\n    if n == 0:\r\n        break\r\n    edges = defaultdict(set)\r\n    for line in sys.stdin:\r\n        u,v = map(int,line.strip().split())\r\n        if u == 0 and v == 0:\r\n            break\r\n        edges[u].add(v)\r\n        edges[v].add(u)\r\n    print(\"YES\" if bipar(edges,n) else \"NO\")\r\n    \r\n    \r\n    \r\ncom = '''\r\n4\r\n1 2\r\n1 3\r\n1 4\r\n2 3\r\n2 4\r\n3 4\r\n0 0\r\n6\r\n1 2\r\n1 3\r\n1 6\r\n2 3\r\n2 5\r\n3 4\r\n4 5\r\n4 6\r\n5 6\r\n0 0\r\n0\r\n'''",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2391",
                "Name": "Claw Decomposition",
                "Note": "",
                "Session": "1",
                "Solution": "uva_11396.py",
                "SubmitDate": "Tue Feb 05 2019 16:54:57 GMT-0800 (Pacific Standard Time)"
            },
            "-LY-Ot8VwujlVaOmesIK": {
                "Code": "T = int(input())\r\n# note not good example as many -1's ... :(\r\nfor t in range(1,T+1):\r\n    n = int(input())\r\n    edges = [-1]*(n+1)\r\n    for e in range(n):\r\n        u,v = map(int,input().split())\r\n        edges[u] = v\r\n    pwr = [0]*n\r\n    for m in range(1,n+1):\r\n        if pwr[m-1] == 0:\r\n            order_node = []\r\n            node_order = {}\r\n            cur = m\r\n            i = 0\r\n            while pwr[cur-1] == 0:\r\n                if cur not in node_order:\r\n                    node_order[cur]=i\r\n                    order_node.append(cur)\r\n                    cur = edges[cur]\r\n                    i+=1\r\n                else:\r\n                    sz = i-node_order[cur]\r\n                    for martian in order_node[node_order[cur]:]:\r\n                        pwr[martian-1] = sz\r\n                    break\r\n            else:\r\n                node_order[cur]=i\r\n                order_node.append(cur)\r\n            for j in range(node_order[cur]-1,-1,-1):\r\n                pwr[order_node[j]-1] = pwr[order_node[j+1]-1]+1\r\n            \r\n    best_m = 1\r\n    for i in range(1,n):\r\n        if pwr[i]>pwr[best_m-1]:\r\n            best_m = i+1\r\n    print(\"Case {}: {}\".format(t,best_m))\r\n    \r\ncom = \"\"\"\r\n3\r\n3\r\n1 2\r\n2 3\r\n3 1\r\n4\r\n1 2\r\n2 1\r\n4 3\r\n3 2\r\n5\r\n1 2\r\n2 1\r\n5 3\r\n3 4\r\n4 5\r\n\"\"\"",
                "Contributor": "craut",
                "Difficulty": "med",
                "File": "",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3873",
                "Name": "Forwarding Emails",
                "Note": "",
                "Session": "1",
                "Solution": "uva_12442.py",
                "SubmitDate": "Tue Feb 05 2019 16:58:42 GMT-0800 (Pacific Standard Time)"
            },
            "-LY-OtYXv9hyoLdbIaJi": {
                "Code": "#include <iostream>\nusing namespace std;\n\nint main () {\n    int m;\n    while (scanf(\"%d\", &m) != EOF) {\n        char field[m][m];\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%s\", field[i]);\n        }\n\n        int result = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (field[i][j] == '1') {\n                    int temp = 2 * m - 2;\n                    for (int z = 0; z < m; ++z) {\n                        for (int k = 0; k < m; ++k) {\n                            if (field[z][k] == '3') {\n                                temp = min(temp, abs(z - i) + abs(k - j));\n                            }\n                        }\n                    }\n                    result = max(result, temp);\n                }\n            }\n        }\n        cout << result << endl;\n    }\n    return 0;\n}",
                "Contributor": "jtuyls",
                "Difficulty": "med",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1043",
                "Name": "The path in the colored field",
                "Note": "",
                "Session": "1",
                "Solution": "10102.cpp",
                "SubmitDate": "Tue Feb 05 2019 17:01:13 GMT-0800 (Pacific Standard Time)"
            },
            "-LY-Otwx5PrrskM0vh7_": {
                "Code": "#include <iostream>\nusing namespace std;\n\nint main () {\n    int m;\n    while (scanf(\"%d\", &m) != EOF) {\n        char field[m][m];\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%s\", field[i]);\n        }\n\n        int result = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (field[i][j] == '1') {\n                    int temp = 2 * m - 2;\n                    for (int z = 0; z < m; ++z) {\n                        for (int k = 0; k < m; ++k) {\n                            if (field[z][k] == '3') {\n                                temp = min(temp, abs(z - i) + abs(k - j));\n                            }\n                        }\n                    }\n                    result = max(result, temp);\n                }\n            }\n        }\n        cout << result << endl;\n    }\n    return 0;\n}",
                "Contributor": "kgajulap",
                "Difficulty": "med",
                "File": "",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=945",
                "Name": "Bicoloring",
                "Note": "",
                "Session": "1",
                "Solution": "10102.cpp",
                "SubmitDate": "Tue Feb 05 2019 17:01:57 GMT-0800 (Pacific Standard Time)"
            },
            "-LY-OuO6snc9I6217JRN": {
                "Code": "#include <iostream>\nusing namespace std;\n\nint main () {\n    int m;\n    while (scanf(\"%d\", &m) != EOF) {\n        char field[m][m];\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%s\", field[i]);\n        }\n\n        int result = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (field[i][j] == '1') {\n                    int temp = 2 * m - 2;\n                    for (int z = 0; z < m; ++z) {\n                        for (int k = 0; k < m; ++k) {\n                            if (field[z][k] == '3') {\n                                temp = min(temp, abs(z - i) + abs(k - j));\n                            }\n                        }\n                    }\n                    result = max(result, temp);\n                }\n            }\n        }\n        cout << result << endl;\n    }\n    return 0;\n}",
                "Contributor": "zhonghas",
                "Difficulty": "hard",
                "File": "",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=995",
                "Name": "The Necklace",
                "Note": "",
                "Session": "1",
                "Solution": "10102.cpp",
                "SubmitDate": "Tue Feb 05 2019 17:03:44 GMT-0800 (Pacific Standard Time)"
            }
        },
        {
            "0": {
                "Code": "",
                "Contributor": "btjanaka",
                "Difficulty": "event",
                "Link": "https://open.kattis.com/contests/uijenc",
                "Name": "Internal Competition III",
                "Note": "This competition will be held, Tuesday February 19th, from 6 - 8 pm in ICS 432. 💻😎 Good luck!! Happy coding 😄😄",
                "Session": "2",
                "Solution": ""
            },
            "-LYYh0R7Un_Q22A6JQiQ": {
                "Code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\n public:\n  TreeNode* invertTree(TreeNode* root) {\n    if (root == nullptr) return root;\n    TreeNode* tmp = root->left;\n    root->left = root->right;\n    root->right = tmp;\n    invertTree(root->left);\n    invertTree(root->right);\n    return root;\n  }\n};\n",
                "Contributor": "btjanaka",
                "Difficulty": "easy",
                "Link": "https://leetcode.com/problems/invert-binary-tree",
                "Name": "Leetcode 226",
                "Note": "binary trees, recursion",
                "Session": "1",
                "Solution": "226.cpp",
                "SubmitDate": "Tue Feb 12 2019 12:56:36 GMT-0800 (Pacific Standard Time)"
            },
            "-LYYh27FL6Ev0OZLtQGU": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 1234\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nstruct UnionFind {\n  vector<int> p, rank;\n  UnionFind(int n) : p(n), rank(n, 0) { iota(p.begin(), p.end(), 0); }\n  int find(int i) { return i == p[i] ? i : (p[i] = find(p[i])); }\n  bool same(int i, int j) { return find(i) == find(j); }\n  void join(int i, int j) {\n    if (!same(i, j)) {\n      int x = find(i), y = find(j);\n      if (rank[x] < rank[y]) {\n        p[x] = y;\n      } else {\n        p[y] = x;\n        if (rank[x] == rank[y]) ++rank[x];\n      }\n    }\n  }\n};\n\nint main() {\n  int ca;\n  GET(ca);\n  while (ca--) {\n    int n, m;\n    GET(n);\n    GET(m);\n    vector<pair<int, ii>> edges;\n    for (int i = 0; i < m; ++i) {\n      int u, v, c;\n      GET(u);\n      GET(v);\n      --u;\n      --v;\n      GET(c);\n      edges.push_back({c, {u, v}});\n    }\n    sort(edges.begin(), edges.end());\n\n    // Calculate the maximum spanning tree - the remaining edges need cameras\n    // because they are the places where the loops close\n    UnionFind uf(n);\n    int cost = 0;\n    for (int i = edges.size() - 1; i >= 0; --i) {\n      int u = edges[i].second.first, v = edges[i].second.second,\n          c = edges[i].first;\n      if (uf.same(u, v)) {\n        cost += c;\n      } else {\n        uf.join(u, v);\n      }\n    }\n\n    printf(\"%d\\n\", cost);\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=3675",
                "Name": "RACING",
                "Note": "Maximum Spanning Tree; Kruskal",
                "Session": "1",
                "Solution": "1234.cpp",
                "SubmitDate": "Sun Feb 10 2019 18:58:51 GMT-0800 (Pacific Standard Time)"
            },
            "-LYYh3ZdEXVSg3qhgn5P": {
                "Code": "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n#include <cmath>\r\n#include <climits>\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nint main(){\r\n\r\n    long n, k, m, x, a, b;\r\n    string y, z;\r\n\r\n    cin >> n >> k;\r\n\r\n    map<string, vector<int> > item;\r\n\r\n    while(k--){\r\n        cin >> x >> y;\r\n        item[y].push_back(x);\r\n    }\r\n\r\n    cin >> m;\r\n    string arr[m];\r\n    long ind[100001][2]={};\r\n\r\n    cin >> arr[0];\r\n    sort(item[arr[0]].begin(), item[arr[0]].end());\r\n    ind[0][1] = item[arr[0]].size()-1;\r\n\r\n    for(int i=1; i<m; i++){\r\n        cin >> arr[i];\r\n        sort(item[arr[i]].begin(), item[arr[i]].end());\r\n        ind[i][1] = item[arr[i]].size()-1;\r\n        while(item[arr[i]][ind[i][0]] < item[arr[i-1]][ind[i-1][0]]){\r\n            ind[i][0]++;\r\n            if(ind[i][0]>ind[i][1]){\r\n                cout << \"impossible\" << endl;\r\n                return 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    for(int i=m-1; i>0; i--){\r\n        while(item[arr[i]][ind[i][1]] < item[arr[i-1]][ind[i-1][1]]){\r\n            ind[i-1][1]--;\r\n            if(ind[i][0]>ind[i][1]){\r\n                cout << \"impossible\" << endl;\r\n                return 0;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    for(int i=0; i<m; i++){\r\n        if(ind[i][0]<ind[i][1]){\r\n            cout << \"ambiguous\" << endl;\r\n            return 0;\r\n        }\r\n    }\r\n    cout << \"unique\" << endl;\r\n    return 0;\r\n}\r\n",
                "Contributor": "mnovitia",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/abandonedanimal",
                "Name": "Abandoned Animal",
                "Note": "",
                "Session": "1",
                "Solution": "abandonedanimal.cpp",
                "SubmitDate": "Sat Feb 02 2019 20:02:06 GMT-0800 (PST)"
            },
            "-LYYh5Xlt88lUY1iNG2z": {
                "Code": "#!/bin/python3\r\n\r\nimport math\r\nimport os\r\nimport random\r\nimport re\r\nimport sys\r\n\r\nfrom heapq import heappop,heappush,heapify\r\nfrom collections import defaultdict\r\n\r\nINF = 10**10\r\n\r\ndef getCost(g,num_v):\r\n    # Print your answer within the function and return nothing\r\n    visited = set()\r\n\r\n    tot_cost = INF\r\n\r\n    pq = [(0,1)]#cur_weight,node_num\r\n    heapify(pq)\r\n\r\n    while len(pq) > 0:\r\n        cur_weight,cur_node = heappop(pq)\r\n        if cur_node == num_v:\r\n            tot_cost = cur_weight\r\n            break\r\n        if cur_node not in visited:\r\n            for neighbor,weight in g[cur_node]:\r\n                if neighbor not in visited:\r\n                    heappush(pq,(max(weight,cur_weight),neighbor))\r\n            visited.add(cur_node)\r\n\r\n    if tot_cost == INF:\r\n        print(\"NO PATH EXISTS\")\r\n    else:\r\n        print(tot_cost)\r\n\r\n\r\nif __name__ == '__main__':\r\n    g_nodes, g_edges = map(int, input().rstrip().split())\r\n\r\n    graph = defaultdict(list)\r\n    for i in range(g_edges):\r\n        g_from, g_to, g_weight = map(int, input().rstrip().split())\r\n        graph[g_from].append((g_to,g_weight))\r\n        graph[g_to].append((g_from,g_weight))\r\n\r\n    getCost(graph,g_nodes)",
                "Contributor": "craut",
                "Difficulty": "med",
                "Link": "https://www.hackerrank.com/challenges/jack-goes-to-rapture/problem",
                "Name": "Jack Goes to Rapture",
                "Note": "Dijkstra’s with a twist!",
                "Session": "1",
                "Solution": "jack_goes_to_rapture.py",
                "SubmitDate": "Tue Feb 05 2019 15:17:46 GMT-0800 (Pacific Standard Time)"
            },
            "-LYYh7cVuaTnDtLhJZvj": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 11228\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nstruct UnionFind {\n  vector<int> p, rank;\n  int comps;\n  UnionFind(int n) : p(n), rank(n, 0) {\n    iota(p.begin(), p.end(), 0);\n    comps = n;\n  }\n  int find(int i) { return i == p[i] ? i : (p[i] = find(p[i])); }\n  bool same(int i, int j) { return find(i) == find(j); }\n  void join(int i, int j) {\n    if (!same(i, j)) {\n      --comps;\n      int x = find(i), y = find(j);\n      if (rank[x] < rank[y]) {\n        p[x] = y;\n      } else {\n        p[y] = x;\n        if (rank[x] == rank[y]) ++rank[x];\n      }\n    }\n  }\n};\n\nint main() {\n  int ca;\n  GET(ca);\n  for (int caa = 1; caa <= ca; ++caa) {\n    int n;\n    double r;\n    GET(n);\n    GED(r);\n\n    double coords[n][2];\n    for (int i = 0; i < n; ++i) {\n      GED(coords[i][0]);\n      GED(coords[i][1]);\n    }\n\n    // Create two sets of edges\n    vector<pair<double, ii>> roads, railroads;\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j < n; ++j) {\n        double dx = coords[j][0] - coords[i][0];\n        double dy = coords[j][1] - coords[i][1];\n        double d = sqrt(dx * dx + dy * dy);\n        if (d <= r) {\n          roads.push_back({d, {i, j}});\n        } else {\n          railroads.push_back({d, {i, j}});\n        }\n      }\n    }\n    sort(roads.begin(), roads.end());\n    sort(railroads.begin(), railroads.end());\n\n    // Results\n    int states = 0;\n    double road_cost = 0.0;\n    double railroad_cost = 0.0;\n    UnionFind uf(n);\n\n    // Select roads\n    for (const pair<double, ii>& road : roads) {\n      double cost = road.first;\n      int u = road.second.first, v = road.second.second;\n\n      if (uf.same(u, v)) continue;\n\n      uf.join(u, v);\n      road_cost += cost;\n    }\n\n    // Determine number of states\n    states = uf.comps;\n\n    // Select railroads\n    for (const pair<double, ii>& railroad : railroads) {\n      double cost = railroad.first;\n      int u = railroad.second.first, v = railroad.second.second;\n\n      if (uf.same(u, v)) continue;\n\n      uf.join(u, v);\n      railroad_cost += cost;\n    }\n\n    printf(\"Case #%d: %d %d %d\\n\", caa, states, (int)round(road_cost),\n           (int)round(railroad_cost));\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=2169",
                "Name": "UVa 11228: Transportation System",
                "Note": "Minimum Spanning Tree",
                "Session": "1",
                "Solution": "11228.cpp",
                "SubmitDate": "Sun Feb 10 2019 19:01:04 GMT-0800 (Pacific Standard Time)"
            },
            "-LYYh96I6TRUnpyMnsn4": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 124\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\n// recursive topo sort where we have to keep track of all possible sequences of\n// characters - we use in to keep track of which chars to use next\nvoid topo(string& s, unordered_set<char>& visited,\n          unordered_map<char, unordered_set<char>>& g, map<char, int>& in,\n          int n) {\n  if (s.size() == n) {\n    printf(\"%s\\n\", s.c_str());\n    return;\n  }\n\n  // guaranteed sorted because |in| is a map\n  for (auto&& x : in) {\n    if (x.second == 0 && visited.find(x.first) == visited.end()) {\n      for (char ch : g[x.first]) --in[ch];\n      s.push_back(x.first);\n      visited.insert(x.first);\n      topo(s, visited, g, in, n);\n      visited.erase(x.first);\n      s.pop_back();\n      for (char ch : g[x.first]) ++in[ch];\n    }\n  }\n}\n\nint main() {\n  char buf[1000];\n  bool first = true;\n  while (fgets(buf, 1000, stdin) != NULL) {\n    // input\n    unordered_map<char, unordered_set<char>> g;\n    map<char, int> in;  // in-degree\n\n    for (int i = 0; buf[i] != '\\n'; ++i) {\n      if (buf[i] != ' ') {\n        g[buf[i]] = {};\n        in[buf[i]] = 0;\n      }\n    }\n\n    fgets(buf, 1000, stdin);\n    int cur = 0;\n    char a, b;\n    for (int i = 0; buf[i] != '\\n'; ++i) {\n      if (buf[i] != ' ') {\n        if (cur % 2 == 0)\n          a = buf[i];\n        else {\n          b = buf[i];\n          // account for duplicates\n          if (g[a].find(b) == g[a].end()) {\n            ++in[b];\n            g[a].insert(b);\n          }\n        }\n        ++cur;\n      }\n    }\n\n    // output\n    if (first)\n      first = false;\n    else\n      printf(\"\\n\");\n    string s;\n    unordered_set<char> visited;\n    topo(s, visited, g, in, (int)g.size());\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=60",
                "Name": "UVa 124: Following Orders",
                "Note": "Topological Sort ft. Recursive Backtracking",
                "Session": "1",
                "Solution": "124.cpp",
                "SubmitDate": "Sat Feb 02 2019 20:50:00 GMT-0800 (Pacific Standard Time)"
            },
            "-LYYh9bG4_MoCbyMwWMD": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 796\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nint dfsi;\nvector<int> dfs_num;\nvector<int> dfs_low;\nvector<int> parent;\nset<ii> art;\nvector<unordered_set<int>> g;\nvoid dfs(int u) {\n  dfs_num[u] = dfs_low[u] = dfsi++;\n  for (int v : g[u]) {\n    if (dfs_num[v] == -1) {\n      parent[v] = u;\n      dfs(v);\n      // found an articulation bridge/edge - note > not >=\n      // if it is >= then there is a back edge from v to u and removing this\n      // edge will not do anything\n      if (dfs_low[v] > dfs_num[u]) {\n        art.insert({min(u, v), max(u, v)});\n      }\n      dfs_low[u] = min(dfs_low[u], dfs_low[v]);\n    } else if (parent[u] != v) {\n      dfs_low[u] = min(dfs_low[u], dfs_num[v]);\n    }\n  }\n}\n\nint main() {\n  int n;\n  while (GET(n) > 0) {\n    // input\n    g.assign(n, {});\n    for (int i = 0; i < n; ++i) {\n      int u, k, v;\n      scanf(\"%d (%d)\", &u, &k);\n      for (int j = 0; j < k; ++j) {\n        GET(v);\n        g[u].insert(v);\n        g[v].insert(u);\n      }\n    }\n\n    // find articulation bridges - note: disregard edge case with root because\n    // only care about finding bridges\n    dfsi = 0;\n    dfs_num.assign(n, -1);\n    dfs_low.assign(n, -1);\n    parent.assign(n, -1);\n    art.clear();\n    for (int i = 0; i < n; ++i) {\n      if (dfs_num[i] == -1) {\n        dfs(i);\n      }\n    }\n\n    // output\n    printf(\"%lu critical links\\n\", art.size());\n    for (const ii& x : art) {\n      printf(\"%d - %d\\n\", x.first, x.second);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=737",
                "Name": "UVa 796: Critical Links",
                "Note": "Articulation bridges",
                "Session": "1",
                "Solution": "796.cpp",
                "SubmitDate": "Sat Feb 02 2019 20:51:45 GMT-0800 (Pacific Standard Time)"
            }
        },
        [
            {
                "Code": "",
                "Contributor": "btjanaka",
                "Difficulty": "event",
                "Link": "https://open.kattis.com/contests/uijenc",
                "Name": "Internal Competition III",
                "Note": "This competition will be held, Tuesday February 19th, from 6 - 8 pm in ICS 432. 💻😎 Good luck!! Happy coding 😄😄",
                "Session": "2",
                "Solution": ""
            }
        ],
        {
            "-LZfhCiYREIav7Lk55cN": {
                "Code": "",
                "Contributor": "timothy4",
                "Difficulty": "med",
                "Link": "https://leetcode.com/problems/network-delay-time",
                "Name": "Network Delay Time",
                "Note": "DFS or Djikstra",
                "Session": "1",
                "Solution": "",
                "SubmitDate": "Tue Feb 05 2019 15:28:42 GMT-0800 (Pacific Standard Time)"
            },
            "-LZfhEczDE1Qg2OxPSCN": {
                "Code": "n,k = (int(x) for x in input().split())\r\n\r\na = [[int(x) for x in input().split()]+[False] for _ in range(n)]\r\n\r\nct = 0\r\n\r\nfor j in range(3):\r\n    a = sorted(a, key = lambda t: -t[j])\r\n    for i in range(k):\r\n        if not a[i][3]:\r\n            a[i][3] = True\r\n            ct+=1\r\n\r\nprint(ct)",
                "Contributor": "mnovitia",
                "Difficulty": "easy",
                "Link": "https://open.kattis.com/problems/iwannabe",
                "Name": "I Wanna Be The Very Best",
                "Note": "",
                "Session": "1",
                "Solution": "iwannabe.py",
                "SubmitDate": "Sat Feb 02 2019 20:03:24 GMT-0800 (PST)"
            },
            "-LZfjPbDPnDxbF_Zvzyv": {
                "Code": "'''Please use Python2...'''\r\nif __name__ == '__main__':\r\n    coffee_num, pages = map(int,input().strip().split())\r\n    coffee_list = [int(i) for i in input().strip().split()]\r\n    coffee_list.sort(reverse = True)\r\n    #possible = False\r\n    days = 10000000000\r\n    first, last = 1,coffee_num\r\n    has_sol = False\r\n    while first <= last:\r\n        possible = False\r\n        mid = int(first+ (last - first)/2)\r\n        #print(first,last,mid)\r\n        to_minus_list = [0 for i in range(coffee_num)]\r\n        make = 0\r\n        for j in range(coffee_num):\r\n            make += coffee_list[j] - to_minus_list[j%mid]\r\n            to_minus_list[j%mid] += 1\r\n            if make >= pages:\r\n                possible = True\r\n                has_sol = True\r\n                if mid < days:\r\n                    days = mid\r\n                break\r\n        if possible:\r\n            last = mid - 1\r\n        else:\r\n            first = mid + 1\r\n       \r\n    if has_sol:\r\n        print(days)\r\n    else:\r\n        print(-1)\r\n",
                "Contributor": "renjied",
                "Difficulty": "hard",
                "Link": "https://codeforces.com/contest/1118/problem/D2",
                "Name": "Coffee and Coursework",
                "Note": "Greedy + Binary Search",
                "Session": "1",
                "Solution": "JackyD2.py",
                "SubmitDate": "Tue Feb 26 2019 13:37:15 GMT-0800 (PST)"
            },
            "-LZfjReN8ObezgDkYtqT": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Kattis) supermario169\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\ndouble xyzdist(double a[3], double b[3]) {\n  double dx = a[0] - b[0];\n  double dy = a[1] - b[1];\n  double dz = a[2] - b[2];\n  return sqrt(dx * dx + dy * dy + dz * dz);\n}\n\ndouble dp[15][1 << 15];\n\nvoid clear_dp() {\n  for (int i = 0; i < 15; ++i)\n    for (int j = 0; j < (1 << 15); ++j) dp[i][j] = -1.0;\n}\n\ndouble tsp(int pos, int visited, int n, double dist[15][15]) {\n  if (visited == (1 << n) - 1) {\n    return dist[pos][0];\n  }\n  if (dp[pos][visited] != -1.0) return dp[pos][visited];\n\n  dp[pos][visited] = 1e9;\n  for (int nxt = 0; nxt < n; ++nxt) {\n    if (!(visited & (1 << nxt))) {\n      dp[pos][visited] =\n          min(dp[pos][visited],\n              dist[pos][nxt] + tsp(nxt, visited | (1 << nxt), n, dist));\n    }\n  }\n  return dp[pos][visited];\n}\n\nint main() {\n  int n;\n  int k[15];  // number of coins in each switch, plus 1 for the switch itself\n  double pts[15][15][3];  // first entry in each index is switch, next are coins\n\n  // input\n  GET(n);\n  ++n;  // for mario\n  for (int i = 0; i < n; ++i) {\n    if (i == 0) {\n      // mario\n      k[i] = 1;\n      for (int j = 0; j < 3; ++j) {\n        GED(pts[0][0][j]);\n      }\n      continue;\n    }\n    GET(k[i]);\n    ++k[i];\n    for (int j = 0; j < k[i]; ++j) {\n      for (int l = 0; l < 3; ++l) {\n        GED(pts[i][j][l]);\n      }\n    }\n  }\n\n  // printf(\"input:\\n\");\n  // for (int i = 0; i < n; ++i) {\n  //   printf(\"pt %d\\n\", i);\n  //   for (int j = 0; j < k[i]; ++j) {\n  //     if (j != 0) printf(\"  \");\n  //     printf(\"%lf %lf %lf\\n\", pts[i][j][0], pts[i][j][1], pts[i][j][2]);\n  //   }\n  // }\n\n  // find distances between each pair of switches\n  double dist[15][15];\n  for (int from = 0; from < n; ++from) {\n    for (int to = 0; to < n; ++to) {\n      if (from == to) {\n        dist[from][to] = 0.0;\n      } else {\n        // calculate tsp distance btwn |from| and |to|\n        double subdist[15][15];\n        for (int i = 0; i < k[from]; ++i) {\n          for (int j = 0; j < k[from]; ++j) {\n            subdist[i][j] = xyzdist(pts[from][i], pts[from][j]);\n            // the \"return\" dist is the distance to |to|, unless |to| is 0, in\n            // which case there is no need to return at all\n            if (j == 0) {\n              if (to == 0) {\n                subdist[i][j] = 0.0;\n              } else {\n                subdist[i][j] = xyzdist(pts[from][i], pts[to][0]);\n              }\n            }\n          }\n        }\n        clear_dp();\n        dist[from][to] = tsp(0, 1, k[from], subdist);\n      }\n    }\n  }\n\n  clear_dp();\n  printf(\"%.6lf\\n\", tsp(0, 1, n, dist));\n\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "hard",
                "Link": "https://open.kattis.com/problems/supermario169",
                "Name": "SuperMario169",
                "Note": "TSP on  s t e r o i d s",
                "Session": "1",
                "Solution": "supermario169.cpp",
                "SubmitDate": "Sat Feb 23 2019 21:16:35 GMT-0800 (Pacific Standard Time)"
            },
            "-LZfkghHRNNvvsJssdF2": {
                "Code": "# https://www.hackerrank.com/challenges/acm-icpc-team/problem\r\nn,m=map(int,input().split())\r\np=[int(input(),2) for i in range(n)]\r\nr=[bin(p[i]|p[j]).count('1') for i in range(n-1) for j in range(i+1,n)]\r\nm=max(r)\r\nprint(m)\r\nprint(r.count(m))\r\n# code golf :D\r\n# try to beat 174 bytes ",
                "Contributor": "craut",
                "Difficulty": "easy",
                "Link": "https://www.hackerrank.com/challenges/acm-icpc-team/problem",
                "Name": "ACM ICPC Team",
                "Note": "|",
                "Session": "1",
                "Solution": "acm_icpc_team.py",
                "SubmitDate": "Tue Feb 26 2019 13:02:32 GMT-0800 (Pacific Standard Time)"
            },
            "-LZfl0zqwknKwsB29xsz": {
                "Code": "#!/bin/python3\r\n\r\nimport os\r\nimport sys\r\nfrom collections import defaultdict, deque\r\nfrom fractions import Fraction\r\n\r\n# https://www.hackerrank.com/challenges/the-story-of-a-tree/problem\r\n# Complete the storyOfATree function below.\r\n#\r\ndef storyOfATree(n, edges, k, guesses):\r\n    # build graph for dfs\r\n    graph = defaultdict(set)\r\n    for edge in edges:\r\n        graph[edge[0]].add(edge[1])\r\n        graph[edge[1]].add(edge[0])\r\n    \r\n    # build map for fast guess validation\r\n    guess_check = defaultdict(set)\r\n    for guess in guesses:\r\n        guess_check[guess[1]].add(guess[0])\r\n\r\n    # build the 1st par_arr using full bfs on 1st node\r\n    init_g = 0\r\n    par_arr = [-1]*(n+1)\r\n    q = deque()\r\n    q.append(1)\r\n    par_arr[1]=0\r\n    while len(q)>0:\r\n        cur = q.popleft()\r\n        for child in graph[cur]:\r\n            if par_arr[child] == -1:\r\n                par_arr[child] = cur\r\n                q.append(child)\r\n    # build the initial guesses correct value assuming node 1 was root\r\n    for kid in guess_check:\r\n        if par_arr[kid] in guess_check[kid]:\r\n            init_g+=1\r\n\r\n    # map for guesses correct given that root = i\r\n    guesses_corr = [-1]*(n+1)\r\n    guesses_corr[1] = init_g\r\n\r\n    # start dfs for changing root (max iterations = 2*n)\r\n    q = deque()\r\n    q.append(1)\r\n    root = 1\r\n    while len(q)>0:\r\n        cur = q.pop()\r\n        #print(cur)\r\n        if root != cur:\r\n            init_g -= int(par_arr[cur] in guess_check[cur])\r\n            par_arr[root] = cur\r\n            par_arr[cur] = 0\r\n            init_g += int(par_arr[root] in guess_check[root])\r\n            root = cur\r\n            if guesses_corr[cur] == -1:\r\n                guesses_corr[cur] = init_g\r\n        # ditch edge to avoid unnecessary n^2 while figuring out which children to pursue next\r\n        for child in graph[cur]:\r\n            graph[cur].discard(child)\r\n            graph[child].discard(cur)\r\n            q.append(cur)\r\n            q.append(child)\r\n            break\r\n    #print(guesses_corr)\r\n    \r\n    # count number of points based on guesses correct given root\r\n    wins = sum(int(corr>=k) for corr in guesses_corr)\r\n    prob = Fraction(wins,n)\r\n    return \"{}/{}\".format(prob.numerator,prob.denominator)\r\n\r\nif __name__ == '__main__':\r\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\r\n\r\n    q = int(input())\r\n\r\n    for q_itr in range(q):\r\n        n = int(input())\r\n\r\n        edges = []\r\n\r\n        for _ in range(n-1):\r\n            edges.append(list(map(int, input().rstrip().split())))\r\n\r\n        gk = input().split()\r\n\r\n        g = int(gk[0])\r\n\r\n        k = int(gk[1])\r\n\r\n        guesses = []\r\n\r\n        for _ in range(g):\r\n            guesses.append(list(map(int, input().rstrip().split())))\r\n\r\n        result = storyOfATree(n, edges, k, guesses)\r\n\r\n        fptr.write(result + '\\n')\r\n\r\n    fptr.close()\r\n",
                "Contributor": "craut",
                "Difficulty": "hard",
                "Link": "https://www.hackerrank.com/challenges/the-story-of-a-tree/problem",
                "Name": "Story of a Tree",
                "Note": "",
                "Session": "1",
                "Solution": "story_of_a_tree.py",
                "SubmitDate": "Tue Feb 26 2019 12:57:25 GMT-0800 (Pacific Standard Time)"
            }
        },
        {
            "-LZrxjrpBkKfI8J3Tw2M": {
                "Code": "// Skip list\n\nclass MedianFinder {\n public:\n  /** initialize your data structure here. */\n  MedianFinder()\n      : device_(),\n        engine_(device_()),\n        choice_(0, 1),\n        size_(0u),\n        heads_(1, new node()),\n        median_(heads_[0]) {}\n\n  void addNum(int num) {\n    insert(num, heads_.size() - 1, heads_.back());\n    ++size_;\n    if (median_ == heads_[0]) {\n      median_ = heads_[0]->next;\n    } else {\n      if (size_ % 2 == 1) {\n        if (num >= median_->val) {\n          median_ = median_->next;\n        } else {\n          // do nothing\n        }\n      } else {\n        if (num >= median_->val) {\n          // do nothing\n        } else {\n          median_ = median_->prev;\n        }\n      }\n    }\n  }\n\n  double findMedian() {\n    /*printf(\"BEGIN\\n\");\n    for(int i = heads_.size() - 1; i >= 0; --i) {\n        for(node* cur = heads_[i]->next; cur != nullptr; cur = cur->next) {\n            printf(\"%d \", cur->val);\n            if(i != 0) printf(\"(%dv) \", cur->below->val);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"END\\n\");\n\n    printf(\"%d\\n\", median_->val);\n    */\n\n    if (size_ == 0) {\n      return 0.0;\n    } else if (size_ % 2 == 0) {\n      return double(median_->val + median_->next->val) / 2.0;\n    } else {\n      return median_->val;\n    }\n  }\n\n private:\n  struct node {\n    int val;\n    node* prev;\n    node* next;\n    node* below;\n    node() : val(0), prev(nullptr), next(nullptr), below(nullptr) {}\n    node(int _val, node* _prev, node* _next, node* _below)\n        : val(_val), prev(_prev), next(_next), below(_below) {}\n  };\n\n  // randomness for skip list\n  random_device device_;\n  default_random_engine engine_;\n  uniform_int_distribution<int> choice_;\n\n  unsigned int size_;\n  vector<node*> heads_;\n  node* median_;\n\n  node* insert(int num, int lvl, node* cur) {\n    // Advance while less than or equal to next - thuse we always add duplicates\n    // to the end of the duplicates\n    for (; cur->next && cur->next->val <= num; cur = cur->next)\n      ;\n    node* ret;\n\n    // Always add on bottom\n    if (lvl == 0) {\n      node* newnode = new node(num, cur, cur->next, nullptr);\n      if (cur->next) cur->next->prev = newnode;\n      cur->next = newnode;\n      ret = cur->next;\n    } else {\n      // Add onto this level only if the choice works and the below levels\n      // worked too\n      node* below = insert(num, lvl - 1, cur->below);\n      if (choice_(engine_) && below) {\n        node* newnode = new node(num, cur, cur->next, below);\n        if (cur->next) cur->next->prev = newnode;\n        cur->next = newnode;\n        ret = cur->next;\n      } else {\n        ret = nullptr;  // prevents higher levels\n      }\n    }\n\n    // Possibly add on more levels above\n    if (lvl == heads_.size() - 1 && ret && choice_(engine_)) {\n      heads_.push_back(new node(num, nullptr, nullptr, heads_.back()));\n      heads_.back()->next = new node(num, heads_.back(), nullptr, ret);\n    }\n\n    return ret;\n  }\n};\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder obj = new MedianFinder();\n * obj.addNum(num);\n * double param_2 = obj.findMedian();\n */\n",
                "Contributor": "btjanaka",
                "Difficulty": "hard",
                "Link": "https://leetcode.com/problems/find-median-from-data-stream",
                "Name": "Leetcode 295 - Find Median From Data Stream",
                "Note": "I decided it was a good day to implement a skip list.",
                "Session": "1",
                "Solution": "295.cpp",
                "SubmitDate": "Fri Feb 22 2019 01:25:12 GMT-0800 (Pacific Standard Time)"
            },
            "-LZrxpt9sav9Dl_4bvi-": {
                "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Kattis) 2048\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nint b[4][4];\n\n// rotates the board counterclockwise n times\nvoid rotate(int n) {\n  for (int _ = 0; _ < n; ++_) {  // haha\n    for (int i = 0; i < 2; ++i) {\n      for (int j = i; j < (4 - i - 1); ++j) {\n        int tmp = b[i][j];\n        b[i][j] = b[j][3 - i];\n        b[j][3 - i] = b[3 - i][3 - j];\n        b[3 - i][3 - j] = b[3 - j][i];\n        b[3 - j][i] = tmp;\n      }\n    }\n  }\n}\n\n// makes a move in the left direction always\nvoid compress() {\n  for (int i = 0; i < 4; ++i) {\n    // clear out zeros\n    int j2 = 0;\n    for (int j = 0; j < 4; ++j) {\n      if (b[i][j] != 0) {\n        b[i][j2++] = b[i][j];\n        if (j != j2 - 1) b[i][j] = 0;\n      }\n    }\n\n    // clear out duplicates and replace with double and a zero\n    int tmp[4] = {0, 0, 0, 0};\n    j2 = 0;\n    for (int j = 0; j < 4; ++j) {\n      if (j != 3 && b[i][j] == b[i][j + 1]) {\n        tmp[j] = 2 * b[i][j];\n        b[i][j + 1] = 0;\n      } else {\n        tmp[j] = b[i][j];\n      }\n    }\n    memcpy(b[i], tmp, sizeof(tmp));\n\n    // clear out zeros again\n    j2 = 0;\n    for (int j = 0; j < 4; ++j) {\n      if (b[i][j] != 0) {\n        b[i][j2++] = b[i][j];\n        if (j != j2 - 1) b[i][j] = 0;\n      }\n    }\n  }\n}\n\nint main() {\n  int first;\n  while (GET(first) > 0) {\n    // input board\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        if (i == 0 && j == 0) {\n          b[i][j] = first;\n        } else {\n          GET(b[i][j]);\n        }\n      }\n    }\n\n    int move;  // 0 = left, 1 = up, 2 = right, 3 = down\n    GET(move);\n    rotate(move);  // rotate the board to get it to a consistent position for\n                   // the move\n    compress();\n    rotate(4 - move);  // rotate the board back to original position\n\n    // output\n    for (int i = 0; i < 4; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        printf(\"%d%c\", b[i][j], j == 3 ? '\\n' : ' ');\n      }\n    }\n  }\n  return 0;\n}\n",
                "Contributor": "btjanaka",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/2048",
                "Name": "Kattis 2048",
                "Note": "implementation heavy",
                "Session": "1",
                "Solution": "2048.cpp",
                "SubmitDate": "Fri Feb 15 2019 03:29:04 GMT-0800 (Pacific Standard Time)"
            },
            "-L_EysXDQ4edhihikBuo": {
                "Code": "#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\nfrom collections import defaultdict\n\n# Complete the sockMerchant function below.\ndef sockMerchant(n, ar):\n    socks = defaultdict(int)\n    for el in ar:\n        socks[el] += 1\n    return sum([math.floor(socks[key]/2) for key in socks.keys()])\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    ar = list(map(int, input().rstrip().split()))\n\n    result = sockMerchant(n, ar)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()\n",
                "Contributor": "jtuyls",
                "Difficulty": "easy",
                "Link": "https://www.hackerrank.com/challenges/sock-merchant/problem",
                "Name": "Sock Merchant",
                "Note": "",
                "Session": "1",
                "Solution": "socks.py",
                "SubmitDate": "Mon Mar 04 2019 13:47:44 GMT-0800 (PST)"
            },
            "-L_Eyuf-1tvoSF07J7nE": {
                "Code": "'''good implementation problem\r\n    greedy + implementation\r\n    Bonus: Write short'''\r\nif __name__ == '__main__':\r\n    num = int(input().strip())\r\n    num_dict = dict()\r\n    nums = [int(i) for i in input().strip().split()]\r\n    for i in nums:\r\n        if i not in num_dict:\r\n            num_dict[i] = 1\r\n        else:\r\n            num_dict[i] +=1\r\n    matrix = [[0 for i in range(num)] for j in range(num)]\r\n    mid = num//2\r\n    #print(num_dict)\r\n    if num%2 != 0:\r\n        for key in num_dict:\r\n            if num_dict[key] != 0 and num_dict[key] % 2 != 0:\r\n                matrix[mid][mid] = key\r\n                num_dict[key] -= 1\r\n                break\r\n        \r\n                \r\n    for row in range(num//2):\r\n        for col in range(num//2):\r\n            if matrix[row][col] == 0:\r\n                for key in num_dict:\r\n                    if num_dict[key] >= 4 and num_dict[key] % 2 == 0:\r\n                        #print(row,col)\r\n                        matrix[row][col] = key\r\n                        matrix[row][num - col - 1] = key\r\n                        matrix[num - row - 1][col] = key\r\n                        matrix[num - row - 1][num - col - 1] = key\r\n                        num_dict[key] -= 4\r\n                        break\r\n    if num%2 != 0:\r\n        for col in range(num):\r\n            if col != mid and matrix[mid][col] == 0:\r\n                for key in num_dict:\r\n                    if num_dict[key] != 0 and \\\r\n                       num_dict[key] % 2 == 0:\r\n                        matrix[mid][col] = key\r\n                        matrix[mid][num - col - 1] = key\r\n                        num_dict[key] -= 2\r\n                        break\r\n        for row in range(num):\r\n            if row != mid and matrix[row][mid] == 0:\r\n                for key in num_dict:\r\n                    if num_dict[key] != 0 and \\\r\n                       num_dict[key] % 2 == 0:\r\n                        matrix[row][mid] = key\r\n                        matrix[num - row - 1][mid] = key\r\n                        num_dict[key] -= 2\r\n                        break\r\n    \r\n    yes = True\r\n    for i in matrix:\r\n        for j in i:\r\n            if j == 0:\r\n                yes = False\r\n                break\r\n    if yes:\r\n        print('Yes')\r\n        for row in matrix:\r\n            print(' '.join(str(i) for i in row))\r\n    else:\r\n        print('No')\r\n",
                "Contributor": "renjied",
                "Difficulty": "med",
                "Link": "https://codeforces.com/contest/1118/problem/C",
                "Name": "Palindromic Matrix",
                "Note": "Medium Implementation",
                "Session": "1",
                "Solution": "Jacky1.py",
                "SubmitDate": "Tue Feb 26 2019 13:51:12 GMT-0800 (PST)"
            },
            "-L_EyvLWgSAkrN4FVO5j": {
                "Code": "#include <iostream>\n\nusing namespace std;\n\nint gcd(int x, int y){\n  if(y){\n    return gcd(y, x%y);\n  } \n  return x;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  bool arr[101]={},brr[101]={};\n  int x,y,ct=0;\n  while(n--){\n    cin >> x;\n    brr[x] = true;\n    for(int i=1; i<101; i++){\n      if(brr[i]){\n        brr[i] = false;\n        y = gcd(x, i);\n\tif(!arr[y]){\n\t  arr[y] = true;\n\t  ct++;\n        }\n\tbrr[y] = true;\n      }\n    }\n  }\n\n  cout << ct << endl;\n  \n  \n  return 0;\n}",
                "Contributor": "mnovitia",
                "Difficulty": "med",
                "Link": "https://open.kattis.com/problems/gcds",
                "Name": "GCDs",
                "Note": "Remember that a is really small",
                "Session": "1",
                "Solution": "gcd.cpp",
                "SubmitDate": "Mon Mar 11 2019 00:50:37 GMT-0700 (Pacific Daylight Time)"
            }
        },
        [
            null,
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "event",
                "Link": "https://www.facebook.com/events/2110949142354647/",
                "Name": "Movie Night",
                "Note": "Come chill out from studying by watching a movie. The movie is a mystery.... ",
                "Session": "1",
                "Solution": ""
            }
        ],
        [
            null,
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "finals",
                "Link": "",
                "Name": "",
                "Note": "",
                "Session": "1",
                "Solution": ""
            },
            {
                "Code": "",
                "Contributor": "",
                "Difficulty": "finals",
                "Link": "",
                "Name": "",
                "Note": "",
                "Session": "2",
                "Solution": ""
            }
        ]
    ],
    "logs": {
        "acmuciguest": {
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "ACMUCIGuest",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        "amourady": {
            "Fall 2018": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Armen Mouradyan",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        "aphilipe": {
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Arne Philipeit",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 5, 5, 6, 1, 0, 0, 0, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        "bbui3": {
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Brian Bui",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        "bmchu1": {
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Brian Chu",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        "btjanaka": {
            "Facebook": "btjanaka",
            "Fall 2018": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "GitHub": "btjanaka",
            "LinkedIn": "btjanaka",
            "Name": "Bryon Nicholas Tjanaka",
            "Photo": "https://raw.githubusercontent.com/btjanaka/namelogo/master/v2/final/bt-logo-color-white-bkgd-hi-res.png",
            "Position": "Member",
            "Spring 2019": [null, 2, 5, 5, 2, 2, 4, 3, 2, 2, 0, 0],
            "Winter 2019": [null, 2, 7, 3, 8, 3, 3, 5, 2, 2, 4, 0]
        },
        "bwakasa": {
            "Fall 2018": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Blake Yoshiaki Wakasa",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 2, 2, 0, 4, 1, 3, 2, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        "calmar": {
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Gael Calma Bau",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        "cdipalma": {
            "Fall 2018": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Christopher Joseph Dipalma",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Winter 2019": [null, 5, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        "craut": {
            "Fall 2018": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Chinmay Viraj Raut",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 2, 2, 1, 4, 4, 2, 5, 3, 0, 0, 0],
            "Winter 2019": [null, 2, 0, 0, 2, 2, 0, 2, 4, 2, 0, 0]
        },
        "haotiz8": {
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Haotian Zheng",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        "jtuyls": {
            "Fall 2018": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Jens Tuyls",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 2, 2, 2, 0, 3, 0, 2, 5, 0, 0],
            "Winter 2019": [null, 0, 0, 2, 2, 0, 0, 0, 0, 2, 0, 0]
        },
        "junliw1": {
            "Fall 2018": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Junlin Wang",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        "kgajulap": {
            "Fall 2018": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Karthik Gajulapalli",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        "mithilh": {
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Mithil Chandra Hari",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        "mnovitia": {
            "Facebook": "meta.novitia",
            "Fall 2018": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "GitHub": "MetaNovitia",
            "HackerRank": "meta_novitia",
            "LinkedIn": "metanovitia",
            "Name": "Meta Novitia",
            "Photo": "https://scontent-lax3-1.xx.fbcdn.net/v/t1.0-9/36225028_1737282199699541_4273720552348188672_o.jpg?_nc_cat=111&_nc_oc=AQkytVfZQ4WSTrGM6ejn8rhI95BQ-F_V-6WttQZS1zAGE5CqY9kqAkXEu1iSDyfbEQQ&_nc_ht=scontent-lax3-1.xx&oh=d7cf339ae85cc4bd11a1e74143d02cd7&oe=5D63694C",
            "Position": "Member",
            "Spring 2019": [null, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0],
            "Winter 2019": [null, 2, 0, 2, 0, 2, 0, 0, 0, 1, 0, 0]
        },
        "pooyak": {
            "Fall 2018": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Pooya Khosravi",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        "renjied": {
            "Fall 2018": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Jacky Dai",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0]
        },
        "satoks": {
            "Fall 2018": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Kaleo Shinichi Sato",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        "timothy4": {
            "Fall 2018": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Timothy Yao",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        "vincetn7": {
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Vincent Thai Nguyen",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        "zhonghas": {
            "Fall 2018": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Fall 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "Name": "Frank Shi",
            "Photo": "",
            "Position": "Member",
            "Spring 2019": [null, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0, 0],
            "Winter 2019": [null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        }
    },
    "submissions": {
        "-LXlhHedI32Zu774MmES": {
            "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 318\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nint main() {\n  int n, m;\n  for (int ca = 1; GET(n) && GET(m) && (n || m); ++ca) {\n    // input\n    vector<vector<ii>> g(n + 1);\n    for (int i = 0; i < m; ++i) {\n      int a, b, l;\n      GET(a);\n      GET(b);\n      GET(l);\n      g[a].push_back({b, l});\n      g[b].push_back({a, l});\n    }\n\n    // BFS\n    int clock = 0;\n    int last_dom = 0;\n    vector<int> time_to(n + 1, -1);  // -1 = not visited at all, -2 = visited\n    vector<int> final_time(n + 1, 0);\n    time_to[1] = 0;\n    int visited = 0;\n    while (visited != n) {\n      // find amount to tick the clock\n      int dt = INT_MAX;\n      for (int i = 1; i <= n; ++i) {\n        if (time_to[i] >= 0) dt = min(dt, time_to[i]);\n      }\n      clock += dt;\n\n      // subtract tick from each time_to\n      for (int i = 1; i <= n; ++i) {\n        if (time_to[i] >= 0) time_to[i] -= dt;\n      }\n\n      // find nodes that are now ready\n      for (int i = 1; i <= n; ++i) {\n        if (time_to[i] == 0) {\n          ++visited;\n          final_time[i] = clock;\n          last_dom = i;\n          for (const ii& x : g[i]) {\n            if (time_to[x.first] == -1) {\n              time_to[x.first] = x.second;\n            } else {\n              time_to[x.first] = min(time_to[x.first], x.second);\n            }\n          }\n          time_to[i] = -2;\n        }\n      }\n    }\n\n    // find out if there is a split that lasts longer than the clock\n    bool btwn = false;\n    int btwnclock = 0, btwnclockrem = 0, last1 = 0, last2 = 0;\n    for (int u = 1; u <= n; ++u) {\n      for (const ii& v : g[u]) {\n        if (abs(final_time[v.first] - final_time[u]) != v.second) {\n          int mn = min(final_time[v.first], final_time[u]);\n          int mx = max(final_time[v.first], final_time[u]);\n          int thisclock = mx + (v.second - (mx - mn)) / 2;\n          int thisclockrem = (v.second - (mx - mn)) % 2 == 0 ? 0 : 5;\n          if (thisclock > btwnclock ||\n              thisclock == btwnclock && thisclockrem > btwnclockrem) {\n            btwnclock = thisclock;\n            btwnclockrem = thisclockrem;\n            last1 = u;\n            last2 = v.first;\n          }\n        }\n      }\n    }\n    if (btwnclock > clock || (btwnclock == clock && btwnclockrem == 5))\n      btwn = true;\n\n    // output\n    printf(\"System #%d\\n\", ca);\n    if (!btwn) {\n      printf(\"The last domino falls after %d.0 seconds, at key domino %d.\\n\",\n             clock, last_dom);\n    } else {\n      printf(\n          \"The last domino falls after %d.%d seconds, between key dominoes %d \"\n          \"and %d.\\n\",\n          btwnclock, btwnclockrem, last1, last2);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n",
            "Contributor": "btjanaka",
            "Difficulty": "hard",
            "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=254",
            "Name": "UVa 318",
            "Note": "BFS ft. time simulation. tick-tock-tick-tock",
            "Session": "",
            "Solution": "318.cpp",
            "SubmitDate": "Sat Feb 02 2019 20:54:26 GMT-0800 (Pacific Standard Time)"
        },
        "-LXzxTfaPpXEatOIUbjN": {
            "Code": "import sys\r\nfrom collections import defaultdict,deque\r\n\r\n# iteratively... suck it Bryon 😎\r\ndef get_ap(g,num_nodes):\r\n    children_visited = set()\r\n    visited = set()\r\n    INF = 10**10\r\n    disc = [INF]*(num_nodes+1)\r\n    low = [INF]*(num_nodes+1)\r\n    par = [0]*(num_nodes+1)\r\n    \r\n    ap = set()\r\n    \r\n    q = deque()\r\n    q.append(1)\r\n    cnt = 1\r\n        \r\n    while len(q)>0:\r\n        cur = q.pop()        \r\n        if cur in visited:\r\n            continue\r\n        \r\n        if cur in children_visited:\r\n            if par[cur] == 0: # check if root\r\n                n_children = sum([par[child]==cur for child in g[cur]])\r\n                if n_children >= 2:\r\n                    ap.add(cur)\r\n            else: # non-root nodes (all children should have a subtree containing a backedge to an ancestor)\r\n                for child in g[cur]:\r\n                    if par[child] == cur:\r\n                        if low[child]>=disc[cur]:\r\n                            ap.add(cur)\r\n                        elif low[child] < low[cur]:\r\n                            low[cur] = low[child]\r\n            visited.add(cur)\r\n        else:\r\n            disc[cur] = cnt\r\n            low[cur] = disc[cur]\r\n            cnt+=1\r\n            to_visit = set()\r\n            for child in g[cur]:\r\n                if child  == par[cur]:\r\n                    pass\r\n                elif disc[child] < low[cur]:\r\n                    # backedge to ancestor\r\n                    low[cur] = disc[child]\r\n                elif child not in children_visited:\r\n                    # actual child\r\n                    to_visit.add(child)\r\n                    par[child] = cur\r\n                # anything else is a node that is already in the q & should be ignored\r\n            children_visited.add(cur)\r\n            if len(to_visit)>0:\r\n                q.append(cur)\r\n                for child in to_visit:\r\n                    q.append(child)\r\n            else:\r\n                visited.add(cur)\r\n    return ap\r\n            \r\n\r\n\r\nfor line in sys.stdin:\r\n    n = int(line.strip())\r\n    if n == 0:\r\n        break\r\n    graph = defaultdict(set)\r\n    for line in sys.stdin:\r\n        nums = list(map(int,line.strip().split()))\r\n        if nums[0] == 0:\r\n            break\r\n        for v in nums[1:]:\r\n            graph[nums[0]].add(v)\r\n            graph[v].add(nums[0])\r\n    aps = get_ap(graph,n)\r\n    #print(aps)\r\n    print(len(aps))\r\n    ",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=24&problem=251",
            "Name": "Network",
            "Note": "Uva 315 - Articulation points\nSee if u can do it iteratively 😎",
            "Session": "",
            "Solution": "uva315.py",
            "SubmitDate": "Tue Feb 05 2019 15:19:51 GMT-0800 (Pacific Standard Time)"
        },
        "-LXzzf7eahZgasJGzP7I": {
            "Code": "",
            "Contributor": "timothy4",
            "Difficulty": "med",
            "Link": "https://leetcode.com/problems/boundary-of-binary-tree",
            "Name": "Boundary of Binary Tree",
            "Note": "post order, pre order, level order",
            "Session": "",
            "Solution": "",
            "SubmitDate": "Tue Feb 05 2019 15:29:26 GMT-0800 (Pacific Standard Time)"
        },
        "-LYjOUOQy060NK64Y9kM": {
            "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 200\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  string s, prev;\n  unordered_map<char, unordered_set<char>> g;\n  unordered_map<char, int> in;\n\n  // input - find characters that are less than the others - similar to strcmp\n  bool first = true;\n  while (cin >> s && s[0] != '#') {\n    if (first) {\n      first = false;\n    } else {\n      int i;\n      for (i = 0; i < s.size() && i < prev.size() && prev[i] == s[i]; ++i) {\n      }\n      if (i < s.size() && i < prev.size()) {\n        if (g.find(prev[i]) == g.end()) {\n          g[prev[i]] = {};\n          in[prev[i]] = 0;\n        }\n        if (g.find(s[i]) == g.end()) {\n          g[s[i]] = {};\n          in[s[i]] = 0;\n        }\n        if (g[prev[i]].find(s[i]) == g[prev[i]].end()) {\n          ++in[s[i]];\n          g[prev[i]].insert(s[i]);\n        }\n      }\n    }\n    prev = s;\n  }\n\n  // topo sort\n  queue<char> visit;\n  for (auto& x : in) {\n    if (x.second == 0) {\n      visit.push(x.first);\n    }\n  }\n  while (!visit.empty()) {\n    char cur = visit.front();\n    visit.pop();\n    putchar(cur);\n    for (char ch : g[cur]) {\n      --in[ch];\n      if (in[ch] == 0) {\n        visit.push(ch);\n      }\n    }\n  }\n  putchar('\\n');\n\n  return 0;\n}\n",
            "Contributor": "btjanaka",
            "Difficulty": "med",
            "Link": "https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=136",
            "Name": "UVa 200: Rare Order",
            "Note": "topo sort",
            "Session": "",
            "Solution": "200.cpp",
            "SubmitDate": "Thu Feb 14 2019 20:24:23 GMT-0800 (Pacific Standard Time)"
        },
        "-LYjvuxZMthqv9Dvjvq0": {
            "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 1103\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\n// globals for days...\nbool img[220][220];\nbool cpy[220][220];\nbool visited[220][220];\nbool visited2[220][220];\nchar chars[] = {'W', 'A', 'K', 'J', 'S', 'D'};\nint di[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nint dj[8] = {1, 0, -1, 1, -1, 1, 0, -1};\nint h, w, w2;\n\n// eliminates black and copies to cpy\nvoid bfs(int si, int sj) {\n  queue<ii> q;\n  q.push({si, sj});\n  visited[si][sj] = true;\n  while (!q.empty()) {\n    int ci = q.front().first;\n    int cj = q.front().second;\n    q.pop();\n\n    cpy[ci][cj] = true;\n    for (int i = 0; i < 8; ++i) {\n      int i2 = ci + di[i];\n      int j2 = cj + dj[i];\n      if (i2 >= 0 && i2 < h && j2 >= 0 && j2 < w && img[i2][j2] &&\n          !visited[i2][j2]) {\n        visited[i2][j2] = true;\n        q.push({i2, j2});\n      }\n    }\n  }\n}\n\n// eliminates white\nvoid bfs2(int si, int sj) {\n  queue<ii> q;\n  q.push({si, sj});\n  visited2[si][sj] = true;\n  while (!q.empty()) {\n    int ci = q.front().first;\n    int cj = q.front().second;\n    q.pop();\n\n    for (int i = 0; i < 8; ++i) {\n      int i2 = ci + di[i];\n      int j2 = cj + dj[i];\n      if (i2 >= 0 && i2 < h && j2 >= 0 && j2 < w && !cpy[i2][j2] &&\n          !visited2[i2][j2]) {\n        visited2[i2][j2] = true;\n        q.push({i2, j2});\n      }\n    }\n  }\n}\n\n// count white components in each shape\nint count_comps() {\n  int comps = 0;\n  memset(visited2, false, sizeof(visited2));\n\n  // sweep edges of board to check for components outside of shape\n  for (int i = 0; i < h; ++i) {\n    for (int j = 0; j < w; ++j) {\n      if ((i == 0 || j == 0 || i == h - 1 || j == w - 1) && !cpy[i][j]) {\n        bfs2(i, j);\n      }\n    }\n  }\n\n  for (int i = 0; i < h; ++i) {\n    for (int j = 0; j < w; ++j) {\n      if (!visited2[i][j] && !cpy[i][j]) {\n        bfs2(i, j);\n        ++comps;\n      }\n    }\n  }\n  return comps;\n}\n\nint main() {\n  h, w2;\n  for (int ca = 1; GET(h) && GET(w2) && (h || w2); ++ca) {\n    // input\n    w = w2 * 4;\n    int d;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w2; ++j) {\n        scanf(\"%1x\", &d);\n        for (int k = 3; k >= 0; --k) {\n          img[i][j * 4 + (3 - k)] = (d & (1 << k)) ? 1 : 0;\n        }\n      }\n    }\n\n    string res;\n\n    // find each black connected component, isolate it in the cpy, and count\n    // white components in that cpy - then based on the count, select a\n    // character\n    memset(visited, false, sizeof(visited));\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        if (img[i][j] && !visited[i][j]) {\n          memset(cpy, false, sizeof(cpy));\n          bfs(i, j);\n          res.push_back(chars[count_comps()]);\n        }\n      }\n    }\n\n    sort(res.begin(), res.end());\n    printf(\"Case %d: %s\\n\", ca, res.c_str());\n  }\n  return 0;\n}\n",
            "Contributor": "btjanaka",
            "Difficulty": "med",
            "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=3544",
            "Name": "UVa 1103: Ancient Messages",
            "Note": "Hint: how many white spaces are there in each shape?",
            "Session": "",
            "Solution": "1103.cpp",
            "SubmitDate": "Thu Feb 14 2019 22:54:49 GMT-0800 (Pacific Standard Time)"
        },
        "-LZ8kAvGxGXuNVRBJmcv": {
            "Code": "#!/bin/python3\r\n\r\nimport math\r\nimport os\r\nimport random\r\nimport re\r\nimport sys\r\nfrom collections import defaultdict\r\n\r\n# Complete the evenForest function below.\r\ndef evenForest(t_nodes, t_edges, t_from, t_to):\r\n    tree = defaultdict(set)\r\n    for i in range(t_edges):\r\n        tree[t_to[i]-1].add(t_from[i]-1)\r\n    num_nodes = [-1]*t_nodes\r\n    cuts = set()\r\n    def recurse_num_nodes(n):\r\n        if num_nodes[n] > -1:\r\n            return num_nodes[n]\r\n        elif len(tree[n]) == 0:\r\n            num_nodes[n] = 1\r\n            return recurse_num_nodes(n)\r\n        else:\r\n            num_nodes[n] = 1+sum(recurse_num_nodes(node) for node in tree[n])\r\n            if num_nodes[n]%2==0:\r\n                cuts.add(n)\r\n                num_nodes[n] = 0\r\n            return recurse_num_nodes(n)\r\n    recurse_num_nodes(0)\r\n    return len(cuts)-1\r\n    \r\n\r\nif __name__ == '__main__':\r\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\r\n\r\n    t_nodes, t_edges = map(int, input().rstrip().split())\r\n\r\n    t_from = [0] * t_edges\r\n    t_to = [0] * t_edges\r\n\r\n    for i in range(t_edges):\r\n        t_from[i], t_to[i] = map(int, input().rstrip().split())\r\n\r\n    res = evenForest(t_nodes, t_edges, t_from, t_to)\r\n\r\n    fptr.write(str(res) + '\\n')\r\n\r\n    fptr.close()\r\n",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://www.hackerrank.com/challenges/even-tree/problem",
            "Name": "Even Tree",
            "Note": "",
            "Session": "",
            "Solution": "even_tree.py",
            "SubmitDate": "Tue Feb 19 2019 23:13:40 GMT-0800 (Pacific Standard Time)"
        },
        "-LZfYkJMuOm2F4LaVfCe": {
            "Code": "# https://www.hackerrank.com/challenges/larrys-array/problem\r\nfrom collections import defaultdict\r\n\r\nT = int(input())\r\nfor t in range(T):\r\n    n = int(input())\r\n    arr = list(map(int,input().split()))\r\n    final = sorted(arr)\r\n\r\n    lookup = {arr[i]:final[i] for i in range(n)}\r\n\r\n    even_cycles = 0\r\n\r\n    visited = set()\r\n    for b in arr:\r\n        if b not in visited:\r\n            size = 0\r\n            next = lookup[b]\r\n            while next not in visited:\r\n                visited.add(next)\r\n                size+=1\r\n                next = lookup[next]\r\n            if size%2 == 0:\r\n                even_cycles +=1\r\n            visited.add(b)\r\n    print(\"YES\" if even_cycles%2==0 else \"NO\")",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://www.hackerrank.com/challenges/larrys-array/problem",
            "Name": "Larry's Array",
            "Note": "",
            "Session": "",
            "Solution": "larrys_array.py",
            "SubmitDate": "Tue Feb 26 2019 12:46:27 GMT-0800 (Pacific Standard Time)"
        },
        "-LZwzLv-lrygLBxTdCYe": {
            "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Hackerrank) modified-kaprekar-numbers\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nbool kaprekar(ll i) {\n  ll sq = i * i;\n  ll left = sq;\n  ll right = 0;\n  ll place = 1;\n  int d = 0;\n  for (sq; sq > 0; ++d, sq /= 10)\n    ;\n  for (int j = 0; j < (d / 2) + (d % 2); ++j) {\n    right = right + (left % 10) * place;\n    place *= 10;\n    left /= 10;\n  }\n  return left + right == i;\n}\n\nint main() {\n  ll p, q;\n  scanf(\"%lld %lld\", &p, &q);\n  bool first = true;\n  for (ll i = p; i <= q; ++i) {\n    if (kaprekar(i)) {\n      if (first) {\n        first = false;\n      } else {\n        putchar(' ');\n      }\n      printf(\"%lld\", i);\n    }\n  }\n  if (first) printf(\"INVALID RANGE\");\n  putchar('\\n');\n  return 0;\n}\n",
            "Contributor": "btjanaka",
            "Difficulty": "easy",
            "Link": "https://www.hackerrank.com/challenges/kaprekar-numbers/problem",
            "Name": "Modified Kaprekar Numbers",
            "Note": "Try solving it without converting the number to a string.",
            "Session": "",
            "Solution": "modified-kaprekar-numbers.cpp",
            "SubmitDate": "Fri Mar 01 2019 22:00:35 GMT-0800 (Pacific Standard Time)"
        },
        "-L_9e8MgFZNp-VryfXiG": {
            "Code": "#\n# Complete the pageCount function below.\n#\ndef pageCount(n, p):\n    #\n    # Write your code here.\n    #\n    if (n % 2 == 1):\n        return min(math.floor(p/2), math.floor((n - p)/2))\n    else:\n        return min(math.floor(p/2), math.ceil((n - p)/2))\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    p = int(input())\n\n    result = pageCount(n, p)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()\n",
            "Contributor": "jtuyls",
            "Difficulty": "easy",
            "Link": "https://www.hackerrank.com/challenges/drawing-book/problem",
            "Name": "Drawing Book",
            "Note": "",
            "Session": "",
            "Solution": "drawing_book.py",
            "SubmitDate": "Mon Mar 04 2019 13:42:36 GMT-0800 (PST)"
        },
        "-L_FCDa2kF7hJT0bL4la": {
            "Code": "# https://open.kattis.com/problems/subsequencesinsubstrings\r\n# note py3 is really slow in Kattis (10**7 wouldn't pass), but python2 is like 100 faster for some reason?\r\n\r\norig = raw_input()\r\nsub = raw_input()\r\nk = len(sub)\r\ntot = 0\r\nlooking_for = [-1]*(k+1)\r\nsubstr = []\r\nfor i in range(len(orig)):\r\n    to_rm = []\r\n\r\n    for j in range(k-1,-1,-1):\r\n        ch = sub[j]\r\n        if ch == orig[i]:\r\n            if j == 0:\r\n                looking_for[j+1] = i\r\n            elif j > 0 and looking_for[j] != -1:\r\n                looking_for[j+1] = looking_for[j]\r\n                looking_for[j] = -1\r\n    if looking_for[k] != -1:\r\n        substr.append((looking_for[k],i))\r\n        looking_for[k] = -1\r\nfor i in range(len(substr)):\r\n    b4 = substr[i][0]+1\r\n    af = len(orig)-substr[i][1]\r\n    if i > 0:\r\n        b4-=(substr[i-1][0]+1)\r\n    tot+=b4*af\r\n\r\nprint(tot)",
            "Contributor": "craut",
            "Difficulty": "icpc",
            "Link": "https://open.kattis.com/problems/subsequencesinsubstrings",
            "Name": "Subsequences in Substrings",
            "Note": "*easiest problem from NAIPC19 (note: it is anything but easy)",
            "Session": "",
            "Solution": "J.py",
            "SubmitDate": "Tue Mar 05 2019 15:33:58 GMT-0800 (Pacific Standard Time)"
        },
        "-L_FCwAjdHGSRxAs8BL8": {
            "Code": "#!/bin/python3\r\n# https://www.hackerrank.com/challenges/matrix-rotation-algo/problem\r\n\r\nm,n,r = map(int,input().split())\r\ndirs = [(0,1),(1,0),(0,-1),(-1,0)]\r\npair_add = lambda x,y:(x[0]+y[0],x[1]+y[1])\r\n\r\nmat = [input().split() for i in range(m)]\r\nans_mat = [[\"-1\"]*n for i in range(m)]\r\n\r\ndef print_mat(matrix):\r\n    [print(\" \".join(row)) for row in matrix]\r\n\r\ncur = (0,0)\r\nwhile(cur[1]<(n)//2 and cur[1]<(m)//2):\r\n    start = cur\r\n    corners = [(cur[0],n-cur[1]-1),(m-cur[0]-1,n-cur[1]-1),(m-cur[0]-1,cur[1]),cur]\r\n    edge = []\r\n    for d_i in range(len(dirs)):\r\n        while cur != corners[d_i]:\r\n            edge.append(mat[cur[0]][cur[1]])\r\n            cur = pair_add(cur,dirs[d_i])\r\n    ind = 0\r\n    wr = len(edge)\r\n    for d_i in range(len(dirs)):\r\n        while cur != corners[d_i]:\r\n            ans_mat[cur[0]][cur[1]] = edge[(ind+r)%wr]\r\n            cur = pair_add(cur,dirs[d_i])\r\n            ind+=1\r\n    cur = pair_add(cur,(1,1))\r\n\r\nprint_mat(ans_mat)",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://www.hackerrank.com/challenges/matrix-rotation-algo/problem",
            "Name": "Matrix Layer Rotation",
            "Note": "",
            "Session": "",
            "Solution": "matix_rotation_algo.py",
            "SubmitDate": "Tue Mar 05 2019 15:37:05 GMT-0800 (Pacific Standard Time)"
        },
        "-L_HZrEi4OX6sPq0892O": {
            "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 1112\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nint main() {\n  int ca;\n  GET(ca);\n  while (ca--) {\n    int n, e, t, m;\n    GET(n);\n    GET(e);\n    --e;\n    GET(t);\n    GET(m);\n\n    vector<vector<ii>> g(n);\n    for (int i = 0; i < m; ++i) {\n      int u, v, w;\n      GET(u);\n      GET(v);\n      GET(w);\n      --u;\n      --v;\n      g[v].push_back({u, w});\n    }\n\n    // dijkstra\n    vector<int> dist(n, -1);\n    priority_queue<ii, vector<ii>, greater<ii>> pq;\n    pq.push({0, e});\n    dist[e] = 0;\n    while (!pq.empty()) {\n      ii cur = pq.top();\n      pq.pop();\n      int d = cur.first, u = cur.second;\n      if (d > dist[u] && dist[u] != -1) continue;\n      for (ii child : g[u]) {\n        int v = child.first, w = child.second;\n        if (dist[v] == -1 || dist[u] + w < dist[v]) {\n          dist[v] = dist[u] + w;\n          pq.push({dist[v], v});\n        }\n      }\n    }\n\n    int tot = 0;\n    for (int i = 0; i < n; ++i) {\n      if (dist[i] <= t && dist[i] >= 0) {\n        ++tot;\n      }\n    }\n    printf(\"%d\\n\", tot);\n\n    if (ca) printf(\"\\n\");\n  }\n  return 0;\n}\n",
            "Contributor": "btjanaka",
            "Difficulty": "med",
            "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=3553",
            "Name": "Mice and Maze",
            "Note": "esrever",
            "Session": "",
            "Solution": "1112.cpp",
            "SubmitDate": "Wed Mar 06 2019 02:36:29 GMT-0800 (Pacific Standard Time)"
        },
        "-L_HsaQTPf6QL9VDsdl2": {
            "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 10389\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  int ca;\n  string s;\n  cin >> ca;\n  getline(cin, s);\n  getline(cin, s);\n\n  while (ca--) {\n    vector<pair<double, double>> coords;\n    vector<int> sub;  // id of the subway\n\n    // home is node 0, school is node 1\n    double hx, hy, sx, sy;\n    cin >> hx >> hy >> sx >> sy;\n    getline(cin, s);\n    coords.push_back({hx, hy});\n    coords.push_back({sx, sy});\n    sub.push_back(-1);\n    sub.push_back(0);\n\n    int cur_id = 1;\n\n    // store all coords and their subway\n    while (getline(cin, s) && s != \"\") {\n      double x, y;\n      stringstream ss(s);\n      while (ss >> x >> y && !(x == -1 && y == -1)) {\n        coords.push_back({x, y});\n        sub.push_back(cur_id);\n      }\n      ++cur_id;\n    }\n\n    // construct graph - pay attn to units\n    int n = coords.size();\n    vector<vector<pair<int, double>>> g(n);\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j < n; ++j) {\n        double dx = coords[i].first - coords[j].first;\n        double dy = coords[i].second - coords[j].second;\n        double d = sqrt(dx * dx + dy * dy) / 1000.0;\n        double t =\n            (sub[i] == sub[j] && j == i + 1 ? d / 40.0 : d / 10.0) * 60.0;\n        g[i].push_back({j, t});\n        g[j].push_back({i, t});\n      }\n    }\n\n    // for (int i = 0; i < n; ++i) {\n    //   printf(\"%d:\", i);\n    //   for (int j = 0; j < g[i].size(); ++j) {\n    //     printf(\" %d(%lf)\", g[i][j].first, g[i][j].second);\n    //   }\n    //   printf(\"\\n\");\n    // }\n\n    // dijkstra\n    priority_queue<pair<double, int>, vector<pair<double, int>>,\n                   greater<pair<double, int>>>\n        pq;\n    pq.push({0.0, 0});\n    vector<double> dist(n, 1e14);\n    dist[0] = 0.0;\n    while (!pq.empty()) {\n      pair<double, int> cur = pq.top();\n      pq.pop();\n      double d = cur.first;\n      int u = cur.second;\n      if (d > dist[u]) continue;\n      for (pair<int, double> child : g[u]) {\n        int v = child.first;\n        double w = child.second;\n        if (dist[u] + w < dist[v]) {\n          dist[v] = dist[u] + w;\n          pq.push({dist[v], v});\n        }\n      }\n    }\n\n    printf(\"%d\\n\", (int)round(dist[1]));\n    if (ca) printf(\"\\n\");\n  }\n  return 0;\n}\n",
            "Contributor": "btjanaka",
            "Difficulty": "med",
            "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=1330",
            "Name": "Subway",
            "Note": "Dijkstra",
            "Session": "",
            "Solution": "10389.cpp",
            "SubmitDate": "Wed Mar 06 2019 04:02:43 GMT-0800 (Pacific Standard Time)"
        },
        "-L__NLVMB4PCx2rox78e": {
            "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (HackerRank) grid-challenge\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  int ca;\n  cin >> ca;\n\n  while (ca--) {\n    int n;\n    cin >> n;\n    cin.get();\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n      getline(cin, grid[i]);\n      sort(grid[i].begin(), grid[i].end());\n    }\n\n    bool ok = true;\n    for (int c = 0; c < n; ++c) {\n      for (int r = 0; r < n - 1; ++r) {\n        ok &= grid[r][c] <= grid[r + 1][c];\n      }\n    }\n\n    printf(ok ? \"YES\" : \"NO\");\n    printf(\"\\n\");\n  }\n  return 0;\n}\n",
            "Contributor": "btjanaka",
            "Difficulty": "easy",
            "Link": "https://www.hackerrank.com/challenges/grid-challenge/problem",
            "Name": "Grid Challenge",
            "Note": "",
            "Session": "",
            "Solution": "grid-challenge.cpp",
            "SubmitDate": "Sat Mar 09 2019 18:14:36 GMT-0800 (Pacific Standard Time)"
        },
        "-LboHblrtRdDPYzLzZGS": {
            "Code": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\n\npublic class Solution {\n    static TreeMap<Long, Integer> left;\n    static TreeMap<Long, Integer> right;\n    static boolean even;\n    static double median;\n\n    static void addLeft(long x) {\n        if (left.containsKey(x) == false) {\n            left.put(x, 1);\n        }else{\n            left.put(x, left.get(x) + 1);\n        }\n    }\n\n    static void removeLeft(long x) {\n        if (left.get(x) == 1) {\n            left.remove(x);\n        }else{\n            left.put(x, left.get(x) - 1);\n        }\n    }\n\n    static void addRight(long x) {\n        if (right.containsKey(x) == false) {\n            right.put(x, 1);\n        }else{\n            right.put(x, right.get(x) + 1);\n        }\n    }\n\n    static void removeRight(long x) {\n        if (right.get(x) == 1) {\n            right.remove(x);\n        }else{\n            right.put(x, right.get(x) - 1);\n        }\n    }\n\n    static void add(long x) {\n        if (even) {\n            if (x < median) {\n                addLeft(x);\n\n                long lMax = left.lastKey();\n                removeLeft(lMax);\n                even = false;\n                median = lMax;\n            }else{\n                addRight(x);\n\n                long rMin = right.firstKey();\n                removeRight(rMin);\n                even = false;\n                median = rMin;\n            }\n        }else{\n            if (x < median) {\n                addLeft(x);\n                addRight((long) median);\n            }else{\n                addRight(x);\n                addLeft((long) median);\n            }\n\n            long lMax = left.lastKey();\n            long rMin = right.firstKey();\n            even = true;\n            median = (lMax + rMin) / 2.0;\n        }\n    }\n\n    static boolean remove(long x) {\n        if (even) {\n            if (left.size() == 0 || right.size() == 0) {\n                return false;\n            }\n            if (x < median) {\n                if (left.containsKey(x) == false) {\n                    return false;\n                }\n                removeLeft(x);\n                long rMin = right.firstKey();\n                removeRight(rMin);\n                even = false;\n                median = rMin;\n            }else{\n                if (right.containsKey(x) == false) {\n                    return false;\n                }\n                removeRight(x);\n                long lMax = left.lastKey();\n                removeLeft(lMax);\n                even = false;\n                median = lMax;\n            }\n        }else{\n            if (x == median) {\n                if (left.size() == 0 || right.size() == 0) {\n                    even = true;\n                    median = 0.0;\n                }else{\n                    long lMax = left.lastKey();\n                    long rMin = right.firstKey();\n                    even = true;\n                    median = (lMax + rMin) / 2.0;\n                }\n                return true;\n            }else if (left.size() == 0 || right.size() == 0) {\n                return false;\n            }\n\n            if (x < median) {\n                if (left.containsKey(x) == false) {\n                    return false;\n                }\n                removeLeft(x);\n                addLeft((long) median);\n                long lMax = left.lastKey();\n                long rMin = right.firstKey();\n                even = true;\n                median = (lMax + rMin) / 2.0;\n            }else{\n                if (right.containsKey(x) == false) {\n                    return false;\n                }\n                removeRight(x);\n                addRight((long) median);\n                long lMax = left.lastKey();\n                long rMin = right.firstKey();\n                even = true;\n                median = (lMax + rMin) / 2.0;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        left = new TreeMap<>();\n        right = new TreeMap<>();\n        even = true;\n        median = 0.0;\n\n        Scanner in = new Scanner(System.in);\n        int n = Integer.parseInt(in.nextLine());\n\n        for (int i = 0; i < n; i++) {\n            String line = in.nextLine();\n            int x = Integer.parseInt(line.substring(2));\n            boolean wrong = false;\n            if (line.startsWith(\"a\")) {\n                add(x);\n            }else{\n                wrong = !remove(x);\n            }\n            if (wrong) {\n                System.out.println(\"Wrong!\");\n            }else if (left.size() == 0 || right.size() == 0) {\n                if (even) {\n                    System.out.println(\"Wrong!\");\n                }else{\n                    System.out.println((int)median);\n                }\n            }else{\n                if (even) {\n                    if (median == (int)median) {\n                        System.out.println((int)median);\n                    }else{\n                        DecimalFormat df = new DecimalFormat(\"#.#\");\n                        System.out.printf(df.format(median));\n                    }\n                }else{\n                    System.out.println((int)median);\n                }\n            }\n        }\n    }\n}\n",
            "Contributor": "aphilipe",
            "Difficulty": "med",
            "Link": "https://www.hackerrank.com/challenges/median",
            "Name": "Median Updates",
            "Note": "Trees for left and right of median\nAdd/remove previous/next median to/from left/right side",
            "Session": "",
            "Solution": "Solution.java",
            "SubmitDate": "Sat Apr 06 2019 13:15:16 GMT-0700 (PDT)"
        },
        "-LboJae--kfmetfLcSyv": {
            "Code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint lowestTriangle(int base, int area){\n    return ceil(2.0 * area / base);\n}\n\nint main() {\n    int base;\n    int area;\n    cin >> base >> area;\n    int height = lowestTriangle(base, area);\n    cout << height << endl;\n    return 0;\n}\n",
            "Contributor": "aphilipe",
            "Difficulty": "easy",
            "Link": "https://www.hackerrank.com/challenges/lowest-triangle",
            "Name": "Minimum Height Triangle",
            "Note": "",
            "Session": "",
            "Solution": "Triangle.cpp",
            "SubmitDate": "Sat Apr 06 2019 13:23:55 GMT-0700 (PDT)"
        },
        "-LboPhy6gGGRvmd7HdmR": {
            "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 10369\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\nstruct UnionFind {\n  vector<int> p, rank;\n  UnionFind(int n) : p(n), rank(n, 0) { iota(p.begin(), p.end(), 0); }\n  int find(int i) { return i == p[i] ? i : (p[i] = find(p[i])); }\n  bool same(int i, int j) { return find(i) == find(j); }\n  bool join(int i, int j) {\n    if (!same(i, j)) {\n      int x = find(i), y = find(j);\n      if (rank[x] > rank[y]) {\n        p[y] = x;\n      } else {\n        p[x] = y;\n        if (rank[x] == rank[y]) ++rank[y];\n      }\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  int ca;\n  GET(ca);\n  while (ca--) {\n    int s, p;\n    GET(s);\n    GET(p);\n    vector<ii> coords;\n    for (int i = 0; i < p; ++i) {\n      int x, y;\n      GET(x);\n      GET(y);\n      coords.push_back({x, y});\n    }\n\n    vector<pair<double, ii>> edges;\n    for (int i = 0; i < p; ++i) {\n      for (int j = i + 1; j < p; ++j) {\n        double dx = coords[i].first - coords[j].first;\n        double dy = coords[i].second - coords[j].second;\n        double d = sqrt(dx * dx + dy * dy);\n        edges.push_back({d, {i, j}});\n      }\n    }\n    sort(edges.begin(), edges.end());\n\n    UnionFind uf(p);\n    vector<bool> used(edges.size());\n    for (int i = 0; i < edges.size(); ++i) {\n      used[i] = uf.join(edges[i].second.first, edges[i].second.second);\n    }\n\n    unordered_set<int> has_s;\n    bool printed = false;\n    for (int i = edges.size() - 1; i >= 0; --i) {\n      if (used[i]) {\n        if (s > 1) {\n          --s;\n        } else {\n          printf(\"%.2lf\\n\", edges[i].first);\n          printed = true;\n          break;\n        }\n      }\n    }\n    if (!printed) printf(\"0.00\\n\");\n  }\n  return 0;\n}\n",
            "Contributor": "btjanaka",
            "Difficulty": "med",
            "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=0&problem=1310",
            "Name": "Arctic Network",
            "Note": "All satellite channels are unique; i.e. each pair of posts with a satellite channel needs its own satellite transmitters.",
            "Session": "",
            "Solution": "10369.cpp",
            "SubmitDate": "Sat Apr 06 2019 13:50:38 GMT-0700 (Pacific Daylight Time)"
        },
        "-LboV676kAV1Eg_mIuuI": {
            "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 924\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\nint main() {\n  int e;\n  GET(e);\n  vector<vector<int>> g(e);\n  for (int u = 0; u < e; ++u) {\n    int n;\n    GET(n);\n    for (int j = 0; j < n; ++j) {\n      int v;\n      GET(v);\n      g[u].push_back(v);\n    }\n  }\n\n  int t;\n  GET(t);\n  for (int i = 0; i < t; ++i) {\n    int x;\n    GET(x);\n    vi days;\n    queue<ii> q;\n    vector<bool> visited(e, false);\n    q.push({x, 0});\n    visited[x] = true;\n    while (!q.empty()) {\n      int u, d;\n      tie(u, d) = q.front();\n      q.pop();\n      if (d == days.size()) days.push_back(0);\n      ++days[d];\n\n      for (int v : g[u]) {\n        if (!visited[v]) {\n          visited[v] = true;\n          q.push({v, d + 1});\n        }\n      }\n    }\n\n    int mx = 0, mxi = 0;\n    for (int i = 0; i < days.size(); ++i) {\n      if (days[i] > mx || (mx == 1 && mxi == 0 && days[i] >= mx)) {\n        mx = days[i];\n        mxi = i;\n      }\n    }\n    if (days.size() == 1) {\n      printf(\"0\\n\");\n    } else {\n      printf(\"%d %d\\n\", mx, mxi);\n    }\n  }\n\n  return 0;\n}\n",
            "Contributor": "btjanaka",
            "Difficulty": "easy",
            "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=0&problem=865",
            "Name": "Spreading the News",
            "Note": "edge case when only telling 1 person",
            "Session": "",
            "Solution": "924.cpp",
            "SubmitDate": "Sat Apr 06 2019 14:14:12 GMT-0700 (Pacific Daylight Time)"
        },
        "-LbpkB1CjLN2VRZhGODw": {
            "Code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Complete the solve function below.\nfunc solve(a []int) (sol []int) {\n\tmin := 100000000\n\tsum := 0\n\tfor _, x := range a {\n\t\tsum += x\n\t\tif x < min {\n\t\t\tmin = x\n\t\t}\n\t}\n\n\tfactors := make(map[int]int)\n\tt := sum\n\tfor d := 2; d <= t; d++ {\n\t\tfor t%d == 0 {\n\t\t\tfactors[d]++\n\t\t\tt /= d\n\t\t}\n\t}\n\n\tposSizes := make(map[int]bool)\n\tposSizes[1] = true\n\tdivs := []int{1}\n\tfor f, c := range factors {\n\t\te := len(divs)\n\t\tg := 1\n\t\tfor a := 1; a <= c; a++ {\n\t\t\tg *= f\n\t\t\tfor i := 0; i < e; i++ {\n\t\t\t\tn := divs[i] * g\n\t\t\t\tdivs = append(divs, n)\n\t\t\t\tif n >= min {\n\t\t\t\t\tposSizes[n] = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nouter:\n\tfor s := range posSizes {\n\t\tb := 0\n\t\tfor _, x := range a {\n\t\t\tb += x\n\t\t\tif b > s {\n\t\t\t\tposSizes[s] = false\n\t\t\t\tcontinue outer\n\t\t\t} else if b == s {\n\t\t\t\tb = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor s, ok := range posSizes {\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tsol = append(sol, s)\n\t}\n\tsort.Ints(sol)\n\treturn\n}\n\nfunc main() {\n\treader := bufio.NewReaderSize(os.Stdin, 1024*1024)\n\n\tstdout, err := os.Create(os.Getenv(\"OUTPUT_PATH\"))\n\tcheckError(err)\n\n\tdefer stdout.Close()\n\n\twriter := bufio.NewWriterSize(stdout, 1024*1024)\n\n\taCount, err := strconv.ParseInt(readLine(reader), 10, 64)\n\tcheckError(err)\n\n\taTemp := strings.Split(readLine(reader), \" \")\n\n\tvar a []int\n\n\tfor aItr := 0; aItr < int(aCount); aItr++ {\n\t\taItemTemp, err := strconv.ParseInt(aTemp[aItr], 10, 64)\n\t\tcheckError(err)\n\t\taItem := int(aItemTemp)\n\t\ta = append(a, aItem)\n\t}\n\n\tresult := solve(a)\n\n\tfor resultItr, resultItem := range result {\n\t\tfmt.Fprintf(writer, \"%d\", resultItem)\n\n\t\tif resultItr != len(result)-1 {\n\t\t\tfmt.Fprintf(writer, \" \")\n\t\t}\n\t}\n\n\tfmt.Fprintf(writer, \"\\n\")\n\n\twriter.Flush()\n}\n\nfunc readLine(reader *bufio.Reader) string {\n\tstr, _, err := reader.ReadLine()\n\tif err == io.EOF {\n\t\treturn \"\"\n\t}\n\n\treturn strings.TrimRight(string(str), \"\\r\\n\")\n}\n\nfunc checkError(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n",
            "Contributor": "aphilipe",
            "Difficulty": "med",
            "Link": "https://www.hackerrank.com/challenges/bus-station",
            "Name": "Bus Station",
            "Note": "Find prime factors",
            "Session": "",
            "Solution": "buses.go",
            "SubmitDate": "Sat Apr 06 2019 20:04:04 GMT-0700 (PDT)"
        },
        "-LbrJUaLNZOioHGZ_nIR": {
            "Code": "# https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/000000000008830b\r\nALPH = \"\".join(chr(i) for i in range(65,65+26))\r\ndef gcd(a,b):\r\n    while b != 0:\r\n        t = b\r\n        b = a%b\r\n        a = t\r\n    return a\r\n\r\nT = int(raw_input())\r\nfor case in range(1,T+1):\r\n    N,L = map(int,raw_input().split())\r\n    enc_list = list(map(int,raw_input().split()))\r\n    p_nums = [-1]*(L+1)\r\n    uncov_i = -1\r\n    # for alt letter pattern at start... need 3 dist letters to start process\r\n    for i in range(L-1):\r\n        if enc_list[i] != enc_list[i+1]:\r\n            uncov_i = i+1\r\n            # gcd using euler method ...\r\n            p_nums[uncov_i] = gcd(enc_list[i],enc_list[i+1])\r\n            break\r\n    # uncover primes before uncovered num\r\n    for i in range(uncov_i-1,-1,-1):\r\n        p_nums[i] = enc_list[i]//p_nums[i+1]\r\n    # uncover primes after uncovered num\r\n    for i in range(uncov_i+1,L+1):\r\n        p_nums[i] = enc_list[i-1]//p_nums[i-1]\r\n    unique_primes = sorted(list(set(p_nums)))\r\n    primes_2_alph = {p:ALPH[i] for i,p in enumerate(unique_primes)}\r\n    text = \"\".join(map(lambda n:primes_2_alph[n],p_nums))\r\n    print(\"Case #{}: {}\".format(case,text))\r\n\r\nsample_input = \"\"\"\r\n2\r\n103 31\r\n217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053\r\n10000 25\r\n3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543\r\n\"\"\"",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/000000000008830b",
            "Name": "cryptopangrams",
            "Note": "plz use python/java ... big numbers have big problems\n\nlook at a much smaller alphabet 1st (eg: only \"abc\"). Why is this alphabet solvable, but not the smaller alphabet (\"ab\")?",
            "Session": "",
            "Solution": "cryptopangrams.py",
            "SubmitDate": "Sun Apr 07 2019 03:22:20 GMT-0700 (Pacific Daylight Time)"
        },
        "-LbtY4A9YHYoAsvbNdQS": {
            "Code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n    int t;\n    string n,a,b;\n    cin >> t;\n    for(int tc=1; tc<=t; tc++){\n        cout << \"Case #\" << tc << \": \";\n        cin >> n;\n        b=\"\";\n        a=\"\";\n        for(int i=0; i<n.length(); i++){\n            if(n[i]=='4'){\n                a += '1';\n                b += '3';\n            }else{\n                a += n[i];\n                if(b!=\"\"){\n                    b+='0';\n                }\n            }\n        }\n        cout << a << \" \" << b << endl;\n    }\n    return 0;\n}",
            "Contributor": "mnovitia",
            "Difficulty": "easy",
            "Link": "https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/0000000000088231",
            "Name": "Foregone Solution",
            "Note": "string traversal",
            "Session": "",
            "Solution": "foregone.cpp",
            "SubmitDate": "Sun Apr 07 2019 13:45:16 GMT-0700 (PDT)"
        },
        "-LbtYLIxXcz3UvxVIiLF": {
            "Code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n    int t,n;\n    string p,q;\n    cin >> t;\n    for(int tc=1; tc<=t; tc++){\n        cout << \"Case #\" << tc << \": \";\n        cin >> n >> p;\n        q=\"\";\n        for(int i=0; i<p.length(); i++){\n            if(p[i]=='S'){\n                q+='E';\n            }else{\n                q+='S';\n            }\n        }\n        cout << q << endl;\n    }\n    return 0;\n}",
            "Contributor": "mnovitia",
            "Difficulty": "easy",
            "Link": "https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881da",
            "Name": "You Can Go Your Own Way",
            "Note": "reflection",
            "Session": "",
            "Solution": "youcango.cpp",
            "SubmitDate": "Sun Apr 07 2019 13:46:27 GMT-0700 (PDT)"
        },
        "-Lbu8jaa1KtQ9m8RvioX": {
            "Code": "#include <iostream>\nusing namespace std;\n\nvoid swap(char * attack, int index) {\n  char temp = attack[index];\n  attack[index] = attack[index + 1];\n  attack[index + 1] = temp;\n}\n\nint get_total_attack(char * attack) {\n  // Get initial total attack\n  int attack_value = 1;\n  int total_attack = 0;\n  for (int j = 0; attack[j] != '\\0'; ++j) {\n    if (attack[j] == 'C') attack_value *= 2;\n    else if (attack[j] == 'S') total_attack += attack_value;\n  }\n  return total_attack; \n}\n\nint main() {\n  int t; scanf(\"%d\", &t);\n  for (int i = 1; i <= t; ++i) {\n\n    // Read the input \n    int D;\n    char attack[256]; \n    scanf(\"%d %s\", &D, attack);\n\n    // Scan for impossibility\n    int s_count = 0;\n    for (int j = 0; attack[j] != '\\0'; ++j)\n      if (attack[j] == 'S') s_count += 1;\n    if (s_count > D) {\n      cout << \"Case #\" << i << \": IMPOSSIBLE\" << endl;\n      continue;\n    }\n\n    // Get initial total attack\n    int total_attack = get_total_attack(attack);\n\n    int hacks = 0;\n    while (total_attack > D) {\n      int swap_index = -1;\n      for (int j = 0; attack[j + 1] != '\\0'; ++j) {\n        if (attack[j] == 'C' && attack[j + 1] == 'S')\n          swap_index = j;\n      }\n      // Do the swap\n      swap(attack, swap_index);\n      hacks += 1;\n      total_attack = get_total_attack(attack);\n    }\n\n    cout << \"Case #\" << i << \": \" << hacks << endl;\n  }\n  return 0;\n}",
            "Contributor": "jtuyls",
            "Difficulty": "med",
            "Link": "https://codingcompetitions.withgoogle.com/codejam/round/00000000000000cb/0000000000007966",
            "Name": "Saving The Universe Again",
            "Note": "Greedy ",
            "Session": "",
            "Solution": "main.cpp",
            "SubmitDate": "Sun Apr 07 2019 16:34:12 GMT-0700 (PDT)"
        },
        "-Lbubp4IwOakB7eVYkpe": {
            "Code": "#include <iostream>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint length(char * arr) {\n  int i;\n  for (i = 0; arr[i] != '\\0'; ++i);\n  return i;\n}\n\nlong long build_result(vector<int> & arr) {\n  int power = 0;\n  int size = arr.size();\n  long long result = 0;\n  for (int i = size - 1; i >= 0; --i) {\n    result += arr[i] * pow(10, power);\n    cout << \"result: \" << result << endl;\n    power += 1;\n  }\n  return result; \n}\n\nint main() {\n  int t; scanf(\"%d\", &t);\n  for (int i = 1; i < t + 1; ++i) {\n    char s_number[256]; scanf(\"%s\", s_number);\n    vector<int> number(length(s_number), 0);\n    for (int j = 0; j < number.size(); ++j) {\n      number[j] = s_number[j] - '0';\n    }\n\n    // Do backward pass\n    for (int j = number.size() - 1; j - 1 >= 0; --j) {\n      if (number[j - 1] > number[j]) {\n        number[j - 1] -= 1;\n        number[j] = 9;\n      }\n    }\n\n    // Do forward pass\n    for (int j = 0; j < number.size(); ++j) {\n      if (number[j] > number[j + 1]) {\n        number[j + 1] = 9;\n      }\n    }\n\n    // Find the stop index\n    int stop_index;\n    for (int j = 0; j < number.size(); ++j) {\n      if (number[j] != 0) {\n        stop_index = j - 1;\n        break;\n      }\n    }\n\n    cout << \"Case #\" << i << \": \";\n    for (int j = stop_index + 1; j < number.size(); ++j) {\n      cout << number[j];\n    }\n    cout << endl;\n  }\n  return 0;\n}",
            "Contributor": "jtuyls",
            "Difficulty": "easy",
            "Link": "https://code.google.com/codejam/contest/3264486/dashboard#s=p1",
            "Name": "Tidy Numbers",
            "Note": "Greedy ",
            "Session": "",
            "Solution": "main.cpp",
            "SubmitDate": "Sun Apr 07 2019 18:45:38 GMT-0700 (PDT)"
        },
        "-LbvKU2gXLLJYenAKjrC": {
            "Code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint a[200010];\r\n\r\nint main()\r\n{\r\n    int n;\r\n    scanf(\"%d\",&n);\r\n    int lastl = 0,lastr = 0;\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        scanf(\"%d\",&a[i]);\r\n        if(a[i]==0)\r\n        {\r\n            lastl = i;\r\n        }\r\n        else\r\n        {\r\n            lastr = i;\r\n        }\r\n    }\r\n    printf(\"%d\\n\",min(lastl,lastr)+1);\r\n    return 0;\r\n}\r\n",
            "Contributor": "zhonghas",
            "Difficulty": "easy",
            "Link": "https://codeforces.com/contest/1143/problem/A",
            "Name": "The Doors",
            "Note": "implementation",
            "Session": "",
            "Solution": "A.cpp",
            "SubmitDate": "Sun Apr 07 2019 22:05:09 GMT-0700 (北美太平洋夏令时间)"
        },
        "-LbvKyjZNxP466bjT3db": {
            "Code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nstruct node\r\n{\r\n    int father;\r\n    int respect;\r\n    int respected;\r\n};\r\n\r\nnode a[100010];\r\n\r\n/*\r\nbool check_son(int i)\r\n{\r\n    for(int j=0;j<a[i].son.size();j++)\r\n    {\r\n        int son_sub = a[i].son[j];\r\n        if(a[son_sub].respect==0)\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n*/\r\n\r\nint main()\r\n{\r\n    int n;\r\n    scanf(\"%d\",&n);\r\n\r\n    for(int i=1;i<=n;i++)\r\n    {\r\n        a[i].respected = 1;\r\n    }\r\n    for(int i=1;i<=n;i++)\r\n    {\r\n        int p,c;\r\n        scanf(\"%d%d\",&p,&c);\r\n        a[i].father = p;\r\n        a[i].respect = c;\r\n        if(p>0) a[p].respected *= c;\r\n    }\r\n    int printed = 0;\r\n    for(int i=1;i<=n;i++)\r\n    {\r\n        if(a[i].respect==1 && a[i].respected==1)\r\n        {\r\n            printed = 1;\r\n            printf(\"%d \",i);\r\n        }\r\n    }\r\n    if(printed)\r\n    {\r\n        printf(\"\\n\");\r\n    }\r\n    else\r\n    {\r\n        printf(\"-1\\n\");\r\n    }\r\n    return 0;\r\n}\r\n",
            "Contributor": "zhonghas",
            "Difficulty": "med",
            "Link": "https://codeforces.com/contest/1143/problem/C",
            "Name": "Queen",
            "Note": "Graph theory, Search",
            "Session": "",
            "Solution": "C.cpp",
            "SubmitDate": "Sun Apr 07 2019 22:07:18 GMT-0700 (北美太平洋夏令时间)"
        },
        "-LbvemYnvDoRnkb-ADw4": {
            "Code": "",
            "Contributor": "bwakasa",
            "Difficulty": "easy",
            "Link": "https://leetcode.com/problems/set-matrix-zeroes",
            "Name": "Set Matrix Zeros",
            "Note": "",
            "Session": "",
            "Solution": "",
            "SubmitDate": "Sun Apr 07 2019 23:38:12 GMT-0700 (Pacific Daylight Time)"
        },
        "-Lbvk04oxRVHRaQV69AV": {
            "Code": "",
            "Contributor": "bwakasa",
            "Difficulty": "easy",
            "Link": "https://leetcode.com/problems/intersection-of-two-linked-lists",
            "Name": "Intersection of Two Linked Lists",
            "Note": "",
            "Session": "",
            "Solution": "",
            "SubmitDate": "Mon Apr 08 2019 00:01:02 GMT-0700 (Pacific Daylight Time)"
        },
        "-LbwAFqRuQ7JYwQ18ZSk": {
            "Code": "'''\r\n    Author: Jacky Dai\r\n    Solution Description: math\r\n'''\r\nnum = int(input().strip())\r\nnumbers = [int(i) for i in input().strip().split()]\r\nnum_dict = dict()\r\nfor i in numbers:\r\n    if i not in num_dict:\r\n        num_dict[i] = 1\r\n    else:\r\n        num_dict[i] += 1\r\n\r\nmax_number = 0\r\nmax_index = 0\r\nfor i in num_dict:\r\n    if num_dict[i] > max_number:\r\n        max_index = i\r\n        max_number = num_dict[i]\r\nfor i in range(num):\r\n    if numbers[i] == max_index:\r\n        index = i\r\n        break\r\n\r\nleft = index - 1\r\nright = index + 1\r\nans = []\r\nwhile left >= 0 or right < num:\r\n    if left >= 0:\r\n        if numbers[left] != max_index:\r\n            if numbers[left] < max_index:\r\n                ans.append((1,left + 1,left + 1 + 1))\r\n            else:\r\n                ans.append((2,left + 1,left + 1 + 1))\r\n        left -= 1\r\n    if right < num:\r\n        if numbers[right] != max_index:\r\n            if numbers[right] < max_index:\r\n                ans.append((1,right + 1,right - 1 + 1))\r\n            else:\r\n                ans.append((2,right + 1,right - 1 + 1))\r\n        right += 1\r\nprint(len(ans))\r\nfor i in ans:\r\n    print(' '.join(str(j) for j in i))\r\n",
            "Contributor": "renjied",
            "Difficulty": "med",
            "Link": "https://codeforces.com/contest/1144/problem/D",
            "Name": "Equalize Them All",
            "Note": "Greedy",
            "Session": "",
            "Solution": "D.py",
            "SubmitDate": "Mon Apr 08 2019 02:00:06 GMT-0700 (Pacific Daylight Time)"
        },
        "-LbwAOVKhE2AsYx_ghPX": {
            "Code": "'''\r\n    Author: Jacky Dai\r\n    Solution Description: bipartite check using bfs (do not use dfs unless it's\r\n    inevitable)\r\n'''\r\nn,m = map(int,input().strip().split())\r\ngraph = dict()\r\norder = dict()\r\nfor i in range(m):\r\n    left,right = map(int,input().strip().split())\r\n    order[(left,right)] = i\r\n    if left not in graph:\r\n        graph[left] = set([right])\r\n    else:\r\n        graph[left].add(right)\r\n    if right not in graph:\r\n        graph[right] = set([left])\r\n    else:\r\n        graph[right].add(left)\r\n#print(graph)\r\nleft_set = {1}\r\nright_set = set()\r\nfirst = 1\r\nto_process = {1}\r\nans_dict = dict()\r\nfail = False\r\nwhile to_process != set():\r\n    temp_list = set()\r\n    for u in to_process:\r\n        #left_set.add(u)\r\n        for v in set(graph[u]):\r\n            temp_list.add(v)\r\n            if v in left_set:\r\n                fail = True\r\n                break\r\n            right_set.add(v)\r\n            if (u,v) in order:\r\n                ans_dict[order[(u,v)]] = 0 \r\n            else:\r\n                ans_dict[order[(v,u)]] = 1\r\n            graph[v].remove(u)\r\n            graph[u].remove(v)\r\n    to_process = set()\r\n    for v in temp_list:\r\n        for u in set(graph[v]):\r\n            if u in right_set:\r\n                fail = True\r\n                break\r\n            left_set.add(u)\r\n            to_process.add(u)\r\n            if (v,u) in order:\r\n                ans_dict[order[(v,u)]] = 1 \r\n            else:\r\n                ans_dict[order[(u,v)]] = 0\r\n            graph[v].remove(u)\r\n            graph[u].remove(v)\r\n             \r\n        if fail:\r\n            break\r\n    if fail:\r\n        break\r\n    #to_process = temp_list\r\nif fail:\r\n    print('NO')\r\nelse:\r\n    print('YES')\r\n    for i in range(m):\r\n        print(ans_dict[i],end = '')\r\n",
            "Contributor": "renjied",
            "Difficulty": "med",
            "Link": "https://codeforces.com/contest/1144/problem/F",
            "Name": "Graph Without Long Directed Paths",
            "Note": "Bipartite Check",
            "Session": "",
            "Solution": "F.py",
            "SubmitDate": "Mon Apr 08 2019 02:00:42 GMT-0700 (Pacific Daylight Time)"
        },
        "-Lc2ySiDtGHX2tCNjg5T": {
            "Code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode start = null;\n        ListNode current = null;\n        int c = 0;\n        while (l1 != null || l2 != null) {\n            int a = (l1 != null) ? l1.val : 0;\n            int b = (l2 != null) ? l2.val : 0;\n            int r = a + b + c;\n            c = 0;\n            while (r >= 10) {\n                r -= 10;\n                c += 1;\n            }\n            if (start == null) {\n                start = new ListNode(r);\n                current = start;\n            }else{\n                current.next = new ListNode(r);\n                current = current.next;\n            }\n            l1 = (l1 != null) ? l1.next : null;\n            l2 = (l2 != null) ? l2.next : null;\n        }\n        if (c > 0) {\n            current.next = new ListNode(c);\n            current = current.next;\n        }\n        return start;\n    }\n}\n",
            "Contributor": "aphilipe",
            "Difficulty": "easy",
            "Link": "https://leetcode.com/problems/add-two-numbers",
            "Name": "Add Two Numbers",
            "Note": "",
            "Session": "",
            "Solution": "Solution.cs",
            "SubmitDate": "Tue Apr 09 2019 14:21:07 GMT-0700 (PDT)"
        },
        "-LcU5iKEv6sJK03E3Dfh": {
            "Code": "class Solution {\r\n    public boolean canJump(int[] nums) {\r\n        int finali = nums.length-1;\r\n        for(int i= finali-1; i>=0; --i){\r\n            if(i+nums[i]>=finali){\r\n                finali =i;\r\n            }\r\n        }\r\n        return finali<=0;\r\n    }\r\n}",
            "Contributor": "bwakasa",
            "Difficulty": "easy",
            "Link": "https://leetcode.com/problems/jump-game",
            "Name": "Jump Game",
            "Note": "",
            "Session": "",
            "Solution": "jump_game.java",
            "SubmitDate": "Sun Apr 14 2019 20:46:57 GMT-0700 (Pacific Daylight Time)"
        },
        "-LcUEh16caTMHvHr8DaM": {
            "Code": "#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n# Complete the catAndMouse function below.\ndef catAndMouse(x, y, z):\n    if (abs(x - z) > abs(y - z)):\n        return \"Cat B\" \n    elif (abs(x - z) < abs(y - z)):\n        return \"Cat A\"\n    else:\n        return \"Mouse C\"\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    q = int(input())\n\n    for q_itr in range(q):\n        xyz = input().split()\n\n        x = int(xyz[0])\n\n        y = int(xyz[1])\n\n        z = int(xyz[2])\n\n        result = catAndMouse(x, y, z)\n\n        fptr.write(result + '\\n')\n\n    fptr.close()\n",
            "Contributor": "jtuyls",
            "Difficulty": "easy",
            "Link": "https://www.hackerrank.com/challenges/cats-and-a-mouse/problem",
            "Name": "Cats and a Mouse",
            "Note": "Yes it's that easy ",
            "Session": "",
            "Solution": "main.py",
            "SubmitDate": "Sun Apr 14 2019 21:26:11 GMT-0700 (PDT)"
        },
        "-LcUNCZG_G_L1Hyt1u3M": {
            "Code": "class Solution:\r\n    def numIslands(self, grid):\r\n        if not grid:\r\n            return 0\r\n        \r\n        count = 0\r\n        for i in range(len(grid)):\r\n            for j in range(len(grid[0])):\r\n                if grid[i][j] == '1':\r\n                    self.dfs(grid, i, j)\r\n                    count += 1\r\n        return count\r\n\r\n    def dfs(self, grid, i, j):\r\n        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':\r\n            return\r\n        grid[i][j] = '9'\r\n        self.dfs(grid, i+1, j)\r\n        self.dfs(grid, i-1, j)\r\n        self.dfs(grid, i, j+1)\r\n        self.dfs(grid, i, j-1)",
            "Contributor": "bwakasa",
            "Difficulty": "easy",
            "Link": "https://leetcode.com/problems/number-of-islands/submissions",
            "Name": "Number of islands",
            "Note": "Graph algoo",
            "Session": "",
            "Solution": "number-of-islands.py",
            "SubmitDate": "Sun Apr 14 2019 22:03:22 GMT-0700 (Pacific Daylight Time)"
        },
        "-LcURQ5BnDorrcGjcUp3": {
            "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (HackerRank) max-min\nimport java.io.*;\nimport java.util.*;\n\npublic class Solution {\n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    int k = in.nextInt();\n    ArrayList<Integer> arr = new ArrayList<>();\n    for (int i = 0; i < n; ++i) arr.add(in.nextInt());\n    Collections.sort(arr);\n\n    int mn_i = 0, mn = arr.get(k - 1) - arr.get(0);\n    for (int i = 1; i + k <= arr.size(); ++i) {\n      int diff = arr.get(i + k - 1) - arr.get(i);\n      if (diff < mn) {\n        mn = diff;\n        mn_i = i;\n      }\n    }\n    System.out.println(mn);\n  }\n}\n",
            "Contributor": "btjanaka",
            "Difficulty": "easy",
            "Link": "https://www.hackerrank.com/challenges/angry-children/problem",
            "Name": "Max Min",
            "Note": "",
            "Session": "",
            "Solution": "max-min.java",
            "SubmitDate": "Sun Apr 14 2019 22:21:45 GMT-0700 (Pacific Daylight Time)"
        },
        "-LcUSMLrtMc8kK6DKt-B": {
            "Code": "n = int(input().strip())\r\nstring = input().strip()\r\nif n%2 != 0:\r\n    print(\":(\")\r\nelse:\r\n    ans = \"\"\r\n    if string[0] == \")\" or string[-1] == \"(\":\r\n        print(\":(\")\r\n    else:\r\n        bad = False\r\n        stack = []\r\n        ans = [\"(\"]\r\n        num = [0,0]\r\n        for i in string:\r\n            if i == \"(\":\r\n                num[0] += 1\r\n            elif i == \")\":\r\n                num[1] += 1\r\n        a,b = n//2 - num[0], n//2 - num[1]\r\n        #print(a)\r\n        left,right = 0,1\r\n        if string[0] == \"?\":\r\n            a -= 1\r\n        for i in range(1,n):\r\n            if left == right:\r\n                bad = True\r\n                break\r\n            if string[i] == \"?\":\r\n                if a <= 0:\r\n                    ans.append(\")\")\r\n                    left += 1\r\n                    b -= 1\r\n                else:\r\n                    ans.append(\"(\")\r\n                    right += 1\r\n                    a -= 1\r\n            else:\r\n                ans.append(string[i])\r\n                if string[i] == \"(\":\r\n                    right += 1\r\n                else:\r\n                    left += 1\r\n\r\n        if a != 0 or b != 0 or bad:\r\n            print(\":(\")\r\n        else:\r\n            print(''.join(ans))\r\n                \r\n",
            "Contributor": "renjied",
            "Difficulty": "easy",
            "Link": "https://codeforces.com/contest/1153/problem/C",
            "Name": "Serval and Parenthesis Sequence",
            "Note": "Easy when you understand the problem",
            "Session": "",
            "Solution": "C.py",
            "SubmitDate": "Sun Apr 14 2019 22:25:53 GMT-0700 (Pacific Daylight Time)"
        },
        "-LcUSfCRSuLrUHyIK9U1": {
            "Code": "'''\r\n    Solution: dp on tree, one thing to notice is that python is poor at handling\r\n    recursion stack memory so I import threading module to manually allocate\r\n    stack memory for huge recusion to pass all test\r\n'''import sys,threading\r\nsys.setrecursionlimit(10**6)\r\nthreading.stack_size(10**8)\r\n\r\ndef main():\r\n    n = int(input().strip())\r\n    son_tree = dict()\r\n    min_max = [0] + [int(i) for i in input().strip().split()]\r\n    for child, parent in enumerate(map(int,input().strip().split()),2):\r\n        if parent not in son_tree:\r\n            son_tree[parent] = [child]\r\n        else:\r\n            son_tree[parent].append(child)\r\n    leaf_ctr = 0\r\n    dp = [0 for i in range(n+1)]\r\n    for i in range(1,n+1):\r\n        if i not in son_tree:\r\n            leaf_ctr += 1\r\n            dp[i] = 1\r\n\r\n    visited = set()\r\n    def dfs(node):\r\n        if node not in visited:\r\n            visited.add(node)\r\n            if node not in son_tree:\r\n                return 1\r\n            if min_max[node]:\r\n                for i in son_tree[node]:\r\n                    dfs(i)\r\n                dp[node] = min(dp[k] for k in son_tree[node])\r\n                return 0\r\n            else:\r\n                for i in son_tree[node]:\r\n                    dfs(i)\r\n                dp[node] = sum(dp[k] for k in son_tree[node])\r\n                return 0\r\n    dfs(1)\r\n    print(leaf_ctr - dp[1]+1)\r\nif __name__ == \"__main__\":\r\n    t = threading.Thread(target=main)\r\n    t.start()\r\n    t.join()\r\n",
            "Contributor": "renjied",
            "Difficulty": "med",
            "Link": "https://codeforces.com/contest/1153/problem/D",
            "Name": " Serval and Rooted Tree",
            "Note": "Easy when change representation of problem",
            "Session": "",
            "Solution": "D.py",
            "SubmitDate": "Sun Apr 14 2019 22:27:14 GMT-0700 (Pacific Daylight Time)"
        },
        "-LcV64RflOmPlhHBqUqu": {
            "Code": "T = int(raw_input())\r\nfor case in range(1,T+1):\r\n    c = int(raw_input())\r\n    b = list(map(int,raw_input().split()))\r\n    resp = \".\"*c\r\n    if sum(b) != c or b[0] == 0 or b[-1] == 0:\r\n        resp = \"IMPOSSIBLE\"\r\n    else:\r\n        rows = 0\r\n        cols_assigned = [(0,0)]*c\r\n        avail_col = 0\r\n        for i in range(c):\r\n            if b[i]>0:\r\n                cols_assigned[i] = (avail_col,avail_col+b[i])\r\n                rows = max(rows,abs(avail_col-i)+1,abs(avail_col+b[i]-i))\r\n                avail_col = avail_col+b[i]\r\n        grid = [['.']*c for i in range(rows)]\r\n        for bin in range(c):\r\n            l,r = cols_assigned[bin]\r\n            if l != r:\r\n                # add '\\'\r\n                row = 0\r\n                while l < bin:\r\n                    grid[row][l] = '\\\\'\r\n                    row+=1\r\n                    l+=1\r\n                # add '/'\r\n                row = 0\r\n                while r-1 > bin:\r\n                    r-=1\r\n                    grid[row][r] = '/'\r\n                    row+=1\r\n        resp = \"{}\\n\".format(rows)+\"\\n\".join(\"\".join(grid[r]) for r in range(rows))\r\n    print(\"Case #{}: {}\".format(case,resp))",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://codingcompetitions.withgoogle.com/codejam/round/0000000000007706/00000000000459f2",
            "Name": "Falling Balls",
            "Note": "",
            "Session": "",
            "Solution": "falling_balls.py",
            "SubmitDate": "Mon Apr 15 2019 01:28:10 GMT-0700 (Pacific Daylight Time)"
        },
        "-LcXG_i7e2yAh-3TeV0f": {
            "Code": "class Solution {\n    func findRotateSteps(_ ring: String, _ key: String) -> Int {\n        struct State {\n            var steps:Int\n            var current:Int\n        }\n        var states = [Int: State]()\n        states[0] = State(steps: 0, current:0)\n        for c in key {\n            var oldStates = states\n            var newStates = [Int: State]()\n            for i in 0..<ring.count {\n                if c != ring[ring.index(ring.startIndex, offsetBy:i)] {\n                    continue\n                }\n                for (_, s) in oldStates {\n                    var m = min(abs(s.current - i), \n                                abs(ring.count + s.current - i),\n                                abs(ring.count + i - s.current))\n                    if let t = newStates[i] {\n                        \n                        if t.steps <= s.steps+m+1 {\n                            continue\n                        }\n                        newStates[i] = State(steps: s.steps+m+1, current: i)\n                    }else{\n                        newStates[i] = State(steps: s.steps+m+1, current: i)\n                    }\n                }\n            }\n            states = newStates\n        }\n        var m = 10000000\n        for (_, s) in states {\n            m = min(m, s.steps)\n        }\n        return m\n    }\n}\n",
            "Contributor": "aphilipe",
            "Difficulty": "med",
            "Link": "https://leetcode.com/problems/freedom-trail",
            "Name": "Freedom Trail",
            "Note": "",
            "Session": "",
            "Solution": "Freedom Trail.swift",
            "SubmitDate": "Mon Apr 15 2019 11:33:17 GMT-0700 (PDT)"
        },
        "-LcXhqFdhI2FxwN2kZvO": {
            "Code": "# @param {Integer} n\n# @param {Integer} k\n# @return {Integer}\ndef k_inverse_pairs(n, k)\n    a = (1..n-1).sum\n    k = a - k if k > a / 2\n    row = [1] + [0] * 1000\n    (2..n).each do |n|\n        new = [0] * 1001\n        sum = 0\n        t = (1..n-1).sum\n        t = k if t > k\n        (0..t).each do |k|\n                sum -= row[k - n] if k >= n\n                sum += row[k]\n                new[k] = sum\n        end\n        row = new\n    end\n    return row[k] % 1000000007\nend\n\n#   ---   n   ---\n# k 1  2  3  4  5\n# 0 1  1  1  1  1\n# 1 0  1  2  3  4\n# 2 0  0  2  5  9\n# 3 0  0  1  6 15\n# 4 0  0  0  5 20\n# 5 0  0  0  3 22\n# 6 0  0  0  1 20\n# 7 0  0  0  0 15\n# 8 0  0  0  0  9\n# 9 0  0  0  0  4\n#10 0  0  0  0  1\n\n# n = 4\n# [1, 2, 3, 4] 0\n# [1, 2, 4, 3] 1\n# [1, 3, 2, 4] 1\n# [1, 3, 4, 2] 2\n# [1, 4, 2, 3] 2\n# [1, 4, 3, 2] 3\n# [2, 1, 3, 4] 1\n# [2, 1, 4, 3] 2\n# [2, 3, 1, 4] 2\n# [2, 3, 4, 1] 3\n# [2, 4, 1, 3] 3\n# [2, 4, 3, 1] 4\n# [3, 1, 2, 4] 2\n# [3, 1, 4, 2] 3\n# [3, 2, 1, 4] 3\n# [3, 2, 4, 1] 4\n# [3, 4, 1, 2] 4\n# [3, 4, 2, 1] 5\n# [4, 1, 2, 3] 3\n# [4, 1, 3, 2] 4\n# [4, 2, 1, 3] 4\n# [4, 2, 3, 1] 5\n# [4, 3, 1, 2] 5\n# [4, 3, 2, 1] 6\n",
            "Contributor": "aphilipe",
            "Difficulty": "hard",
            "Link": "https://leetcode.com/problems/k-inverse-pairs-array",
            "Name": "K Inverse Pairs Array",
            "Note": "Mahonian Triangle",
            "Session": "",
            "Solution": "InvPairs.rb",
            "SubmitDate": "Mon Apr 15 2019 13:36:45 GMT-0700 (PDT)"
        },
        "-LcYMJTqZ8g7daEejtWy": {
            "Code": "#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\nint main(){\r\n\tstring s, t;\r\n\tcin>>s>>t;\r\n\tbool flag = true;\r\n\tfor(int i = 0; i < s.length(); i++)\r\n\t\tif(s[i] != t[s.length() - i - 1])\r\n\t\t\tflag = false;\r\n\tflag ? (cout<<\"YES\") : (cout<<\"NO\");\r\n\treturn 0;\r\n}",
            "Contributor": "pooyak",
            "Difficulty": "easy",
            "Link": "http://codeforces.com/problemset/problem/41/A",
            "Name": "Translation",
            "Note": "implementation",
            "Session": "",
            "Solution": "41A.cpp",
            "SubmitDate": "Mon Apr 15 2019 16:37:55 GMT-0700 (Pacific Daylight Time)"
        },
        "-LcYMOkfy_HP7uqwHE-z": {
            "Code": "#include<iostream>\r\n\r\nusing namespace std;\r\nint main(){\r\n\tint i,n,a,b[105];\r\n\tcin>>n;\r\n\tfor(i=0;i<n;i++) \r\n\t\tcin>>a,b[a-1]=i;\r\n\tfor(i=0;i<n;i++) \r\n\t\tcout<<b[i]+1<<\" \";\r\n\treturn 0;\r\n}",
            "Contributor": "pooyak",
            "Difficulty": "easy",
            "Link": "http://codeforces.com/problemset/problem/136/A",
            "Name": "Presents",
            "Note": "implementation",
            "Session": "",
            "Solution": "136A.cpp",
            "SubmitDate": "Mon Apr 15 2019 16:38:17 GMT-0700 (Pacific Daylight Time)"
        },
        "-LcYMTWoiNsJ9ek3958E": {
            "Code": "#include<iostream>\r\nusing namespace std;\r\nint main(){\r\n\tint a,b,c,d,e;\r\n\tcin>>a>>b;\r\n\tc = d = a;\r\n\twhile(d >= b){\r\n\t\tc += d/b;\r\n\t\td = d/b + d%b;\r\n\t}\r\n\tcout<<c;\r\n\treturn 0;\r\n}",
            "Contributor": "pooyak",
            "Difficulty": "easy",
            "Link": "http://codeforces.com/problemset/problem/379/A",
            "Name": "New Year Candles",
            "Note": "implementation",
            "Session": "",
            "Solution": "379A.cpp",
            "SubmitDate": "Mon Apr 15 2019 16:38:36 GMT-0700 (Pacific Daylight Time)"
        },
        "-LcYMY_vFmtc5QUoeKw6": {
            "Code": "#include<iostream>\r\n\r\nusing namespace std;\r\nint main(){\r\n\tint n,c=0,p,q;\r\n\tcin>>n;\r\n\tfor(int i = 0; i < n; i++){\r\n\t\tcin>>p>>q;\r\n\t\tif(q-p > 1)\r\n\t\t\tc++;\r\n\t}\r\n\tcout<<c;\r\n}",
            "Contributor": "pooyak",
            "Difficulty": "easy",
            "Link": "http://codeforces.com/problemset/problem/467/A",
            "Name": "George and Accommodation",
            "Note": "implementation",
            "Session": "",
            "Solution": "467A.cpp",
            "SubmitDate": "Mon Apr 15 2019 16:38:57 GMT-0700 (Pacific Daylight Time)"
        },
        "-LcZst4zlvLqzHIMqQhE": {
            "Code": "#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nint main(){\r\n  \r\n  int x1=0,y1=0,x2,y2,x3,y3,dx=0,dy=1, dx2, dy2;\r\n  string command[3]={\"Forward\",\"Left\",\"Right\"};\r\n  cin >> x2 >> y2;\r\n  int n;\r\n  vector<string> v;\r\n  string s;\r\n  cin >> n;\r\n  \r\n  // input commands\r\n  while(n--){\r\n    cin >> s;\r\n    v.push_back(s);\r\n  }\r\n  \r\n  // go through array\r\n  for(int i=0; i<v.size(); i++){\r\n\r\n    // go through each possible command correction\r\n    for(int k=0; k<3; k++){\r\n      s = command[k];\r\n      \r\n      if(s!=v[i]){\r\n\r\n        // update position and direction\r\n        x3 = x1;\r\n        y3 = y1;\r\n        dx2 = dx;\r\n        dy2 = dy;\r\n\r\n        if(s==\"Forward\"){\r\n          x3+=dx2;\r\n          y3+=dy2;\r\n        }else if(s==\"Right\"){\r\n          if(dy2==1){\r\n            dy2 = 0;\r\n            dx2 = 1;\r\n          }else if(dy2==-1){\r\n            dy2 = 0;\r\n            dx2 = -1;\r\n          }else if(dx2==1){\r\n            dx2 = 0;\r\n            dy2 = -1;\r\n          }else{\r\n            dx2 = 0;\r\n            dy2 = 1;\r\n          }\r\n        }else{\r\n          if(dy2==1){\r\n            dy2 = 0;\r\n            dx2 = -1;\r\n          }else if(dy2==-1){\r\n            dy2 = 0;\r\n            dx2 = 1;\r\n          }else if(dx2==1){\r\n            dx2 = 0;\r\n            dy2 = 1;\r\n          }else{\r\n            dx2 = 0;\r\n            dy2 = -1;\r\n          }\r\n        }\r\n        \r\n        // go through rest of the array\r\n        for(int j=i+1; j<v.size(); j++){\r\n\r\n\r\n\t\t\t\t\tif(v[j]==\"Forward\"){\r\n            x3+=dx2;\r\n            y3+=dy2;\r\n          }else if(v[j]==\"Right\"){\r\n            if(dy2==1){\r\n              dy2 = 0;\r\n              dx2 = 1;\r\n            }else if(dy2==-1){\r\n              dy2 = 0;\r\n              dx2 = -1;\r\n            }else if(dx2==1){\r\n              dx2 = 0;\r\n              dy2 = -1;\r\n            }else{\r\n              dx2 = 0;\r\n              dy2 = 1;\r\n            }\r\n          }else{\r\n            if(dy2==1){\r\n              dy2 = 0;\r\n              dx2 = -1;\r\n            }else if(dy2==-1){\r\n              dy2 = 0;\r\n              dx2 = 1;\r\n            }else if(dx2==1){\r\n              dx2 = 0;\r\n              dy2 = 1;\r\n            }else{\r\n              dx2 = 0;\r\n              dy2 = -1;\r\n            }\r\n          }\r\n        }\r\n        if(x3==x2 && y3==y2){\r\n          cout << i+1 << \" \" << s << endl;\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n    \r\n    if(v[i]==\"Forward\"){\r\n      x1+=dx;\r\n      y1+=dy;\r\n    }else if(v[i]==\"Right\"){\r\n      if(dy==1){\r\n        dy = 0;\r\n        dx = 1;\r\n      }else if(dy==-1){\r\n        dy = 0;\r\n        dx = -1;\r\n      }else if(dx==1){\r\n        dx = 0;\r\n        dy = -1;\r\n      }else{\r\n        dx = 0;\r\n        dy = 1;\r\n      }\r\n    }else{\r\n      if(dy==1){\r\n        dy = 0;\r\n        dx = -1;\r\n      }else if(dy==-1){\r\n        dy = 0;\r\n        dx = 1;\r\n      }else if(dx==1){\r\n        dx = 0;\r\n        dy = 1;\r\n      }else{\r\n        dx = 0;\r\n        dy = -1;\r\n      }\r\n    }\r\n    \r\n  }\r\n  return 0;\r\n}",
            "Contributor": "mnovitia",
            "Difficulty": "easy",
            "Link": "https://open.kattis.com/problems/glitchbot",
            "Name": "GlitchBot",
            "Note": "",
            "Session": "",
            "Solution": "glitchbot.cpp",
            "SubmitDate": "Mon Apr 15 2019 23:44:14 GMT-0700 (PDT)"
        },
        "-LcZtVNKK-Jf-oD9p6ho": {
            "Code": "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <sstream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nint main(){\r\n    long n,t,c,tm;\r\n    cin >> n >> t;\r\n    long arr[t];\r\n\r\n    for(int i=0; i<t; i++){\r\n        arr[i] = 0;\r\n    }\r\n\r\n    for(int i=0; i<n; i++){\r\n        cin >> c >> tm;\r\n        while(tm>=0){\r\n            if(arr[tm]==0){\r\n                arr[tm] = c;\r\n                break;\r\n            }\r\n            if(arr[tm]<c){\r\n                long temp = arr[tm];\r\n                arr[tm] = c;\r\n                c = temp;\r\n            }\r\n            tm--;\r\n        }\r\n    }\r\n\r\n    tm = 0;\r\n    for(int i=0; i<t; i++){\r\n        tm+=arr[i];\r\n    }\r\n\r\n    cout << tm;\r\n\r\n}\r\n",
            "Contributor": "mnovitia",
            "Difficulty": "easy",
            "Link": "https://open.kattis.com/problems/bank",
            "Name": "Bank Queue",
            "Note": "",
            "Session": "",
            "Solution": "bank.cpp",
            "SubmitDate": "Mon Apr 15 2019 23:46:55 GMT-0700 (PDT)"
        },
        "-LcneDo_qffxO8auTUoE": {
            "Code": "int brokenCalc(int X, int Y) {\n    int steps = 0;\n    while (X != Y) {\n        if (X > Y) {\n            steps += X - Y;\n            X = Y;\n        }else if (Y >= 2 * X && Y % 2 == 0) {\n            Y /= 2;\n            steps++;\n        }else if (Y >= 2 * X && Y % 2 == 1) {\n            Y++;\n            steps++;\n        }else if (Y >= 2 * X) {\n            X *= 2;\n            steps++;\n        }else if (2 * X - Y <= Y - 2 * (X - 1)) {\n            X *= 2;\n            steps++;\n        }else{\n            X--;\n            steps++;\n        }\n    }\n    return steps;\n}\n",
            "Contributor": "aphilipe",
            "Difficulty": "med",
            "Link": "https://leetcode.com/problems/broken-calculator",
            "Name": "Broken Calculator",
            "Note": "",
            "Session": "",
            "Solution": "BrokenCalc.c",
            "SubmitDate": "Thu Apr 18 2019 20:56:09 GMT-0700 (PDT)"
        },
        "-LcnhDC6B5gjJN6ACDoI": {
            "Code": "func largestSumAfterKNegations(A []int, K int) int {\n    sort.Ints(A)\n    var i int\n    for i = 0; i < K; i++ {\n        if A[i] < 0 {\n            A[i] *= -1\n        }else if A[i] == 0 {\n            break\n        }else{\n            if (K - i) % 2 == 0 {\n                break\n            }\n            if i == 0 {\n                A[i] *= -1\n            }else if A[i - 1] > A[i] {\n                A[i] *= -1\n            }else{\n                A[i - 1] *= -1\n            }\n            break\n        }\n    }\n    \n    var sum int\n    for _, v := range A {\n        sum += v\n    }\n    return sum\n}\n",
            "Contributor": "aphilipe",
            "Difficulty": "easy",
            "Link": "https://leetcode.com/problems/maximize-sum-of-array-after-k-negations",
            "Name": "Maximize Sum Of Array After K Negations",
            "Note": "Sorting",
            "Session": "",
            "Solution": "Sol420.go",
            "SubmitDate": "Thu Apr 18 2019 20:47:33 GMT-0700 (PDT)"
        },
        "-LcniCeUg9zP2M4HkhJl": {
            "Code": "func judgeCircle(moves string) bool {\n    var x, y int\n    for _, r := range moves {\n        if r == 'U' {\n            y++\n        }else if r == 'D' {\n            y--\n        }else if r == 'L' {\n            x--\n        }else if r == 'R' {\n            x++\n        }\n    }\n    return x == 0 && y == 0\n}\n",
            "Contributor": "aphilipe",
            "Difficulty": "easy",
            "Link": "https://leetcode.com/problems/robot-return-to-origin",
            "Name": "Robot Return to Origin",
            "Note": "",
            "Session": "",
            "Solution": "Robot.go",
            "SubmitDate": "Thu Apr 18 2019 20:51:53 GMT-0700 (PDT)"
        },
        "-Ld2Xz0rhJBWa4x7SF7r": {
            "Code": "#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\ndef binary_search(key, powerList, low, high):\n    if low > high:\n        return low - 1\n    mid = int((low + high)/2)\n    if (key < powerList[mid]):\n        return binary_search(key, powerList, low, mid - 1)\n    elif (key > powerList[mid]):\n        return binary_search(key, powerList, mid + 1, high)\n    else:\n        return mid\n\n# Complete the counterGame function below.\ndef counterGame(n):\n    winnerMap = {\n        'Louise':'Richard',\n        'Richard':'Louise'\n    }\n    # compute all powers of 2\n    powerSet = set()\n    powerList = []\n    for i in range(65):\n        powerSet.add(2**i)\n        powerList.append(2**i)\n    winner = 'Richard'\n    while n != 1:\n        if n in powerSet:\n            n = n/2\n            winner = winnerMap[winner]\n        else:\n            index = binary_search(n, powerList, 0, len(powerList)-1)\n            n = n - powerList[index]\n            winner = winnerMap[winner]\n            \n    return winner\n        \n            \nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    t = int(input())\n\n    for t_itr in range(t):\n        n = int(input())\n\n        result = counterGame(n)\n\n        fptr.write(result + '\\n')\n\n    fptr.close()\n\n",
            "Contributor": "jtuyls",
            "Difficulty": "med",
            "Link": "https://www.hackerrank.com/challenges/counter-game/problem",
            "Name": "Counter game",
            "Note": "",
            "Session": "",
            "Solution": "main.py",
            "SubmitDate": "Sun Apr 21 2019 22:36:45 GMT-0700 (PDT)"
        },
        "-Ld2YdY0THviq5U94cd-": {
            "Code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring gameOfStones(int n) {\n    return (n % 7 == 0 || n % 7 == 1) ? \"Second\" : \"First\"; \n}\n\nint main() {\n    int t;\n    cin >> t;\n    for(int a0 = 0; a0 < t; a0++){\n        int n;\n        cin >> n;\n        string result = gameOfStones(n);\n        cout << result << endl;\n    }\n    return 0;\n}\n\n",
            "Contributor": "jtuyls",
            "Difficulty": "easy",
            "Link": "https://www.hackerrank.com/challenges/game-of-stones-1/submissions/code/65812008",
            "Name": "Game of Stones",
            "Note": "",
            "Session": "",
            "Solution": "main.cpp",
            "SubmitDate": "Sun Apr 21 2019 22:39:39 GMT-0700 (PDT)"
        },
        "-Ld2ZjBpdtws2Wg3OSYn": {
            "Code": "#!/bin/python3\r\n\r\n# https://www.hackerrank.com/challenges/floyd-city-of-blinding-lights/problem\r\nimport os\r\nimport sys\r\nimport heapq\r\nfrom collections import defaultdict\r\n\r\ndef dijks(src,g,n):\r\n    cur_map = [-1]*(n+1)\r\n    q = [(0,src)]\r\n    heapq.heapify(q)\r\n    visited = set()\r\n    while len(q) > 0:\r\n        d,node = heapq.heappop(q)\r\n        if node not in visited:\r\n            cur_map[node] = d\r\n            for child in g[node]:\r\n                weight = g[node][child]\r\n                heapq.heappush(q,(d+weight,child))\r\n            visited.add(node)\r\n    return cur_map\r\n\r\nif __name__ == '__main__':\r\n    n,m = map(int,input().split())\r\n    g = defaultdict(dict)\r\n    for i in range(m):\r\n        s,d,w = map(int,input().split())\r\n        g[s][d] = w\r\n    q = int(input())\r\n    dp = dict()\r\n    for i in range(q):\r\n        s,d = map(int,input().split())\r\n        if s not in dp:\r\n            dp[s] = dijks(s,g,n)\r\n        print(dp[s][d])",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://www.hackerrank.com/challenges/floyd-city-of-blinding-lights/problem",
            "Name": "Floyd : City of Blinding Lights",
            "Note": "dijk's & dp",
            "Session": "",
            "Solution": "floyd.py",
            "SubmitDate": "Sun Apr 21 2019 22:44:26 GMT-0700 (Pacific Daylight Time)"
        },
        "-Ld2gghy-fABcjcrZYDT": {
            "Code": "#include <stdio.h>\r\n\r\nlong long c(long long a,long long b)\r\n{\r\n    long long result = 1;\r\n    int i;\r\n    for(i=0;i<a;i++)\r\n    {\r\n        result *= (b-i);\r\n        result /= (i+1);\r\n    }\r\n    return result;\r\n}\r\n\r\nint main()\r\n{\r\n    long long n;\r\n    long long result;\r\n    scanf(\"%I64d\",&n);\r\n    printf(\"%I64d\\n\",c(5,n)+c(6,n)+c(7,n));\r\n    return 0;\r\n}\r\n",
            "Contributor": "zhonghas",
            "Difficulty": "easy",
            "Link": "http://codeforces.com/problemset/problem/630/F",
            "Name": "Selection of Personnel",
            "Note": "number theory, combination numbers",
            "Session": "",
            "Solution": "630F.cpp",
            "SubmitDate": "Sun Apr 21 2019 23:19:11 GMT-0700 (北美太平洋夏令时间)"
        },
        "-Ld2hG32KwmAr9FOiOnm": {
            "Code": "#include <stdio.h>\r\n\r\nlong long result = 0;\r\nlong long used[2000];\r\nlong long times[2000];\r\nlong long n;\r\n\r\nlong long gcd(long long a,long long b)\r\n{\r\n    return b==0 ? a : gcd(b,a%b);\r\n}\r\n\r\nlong long lcm(long long a,long long b)\r\n{\r\n    return a*b/gcd(a,b);\r\n}\r\n\r\nvoid solve(int a,int operat)\r\n{\r\n    int temp = a;\r\n    int cnt = 0;\r\n    for(cnt=0;cnt<9;cnt++)\r\n    {\r\n        if(temp%2==0)\r\n        {\r\n            if(used[(1<<cnt)+a]==0)\r\n            {\r\n                used[(1<<cnt)+a] = 1;\r\n                times[(1<<cnt)+a] = lcm(cnt+2,times[a]);\r\n                result += operat*(n/times[(1<<cnt)+a]);\r\n                solve((1<<cnt)+a,-operat);\r\n            }\r\n        }\r\n        temp /= 2;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int i,j;\r\n    scanf(\"%I64d\",&n);\r\n    for(i=2;i<=10;i++)\r\n    {\r\n        used[1<<(i-2)] = 1;\r\n        times[1<<(i-2)] = i;\r\n        result += n/i;\r\n        solve(1<<(i-2),-1);\r\n    }\r\n    printf(\"%I64d\\n\",n-result);\r\n    return 0;\r\n}\r\n",
            "Contributor": "zhonghas",
            "Difficulty": "med",
            "Link": "http://codeforces.com/problemset/problem/630/K",
            "Name": "Indivisibility",
            "Note": "number theory, Principle of inclusion-exclusion",
            "Session": "",
            "Solution": "630K.cpp",
            "SubmitDate": "Sun Apr 21 2019 23:21:40 GMT-0700 (北美太平洋夏令时间)"
        },
        "-Ld2phvzvta4sd16hwam": {
            "Code": "# Author: btjanaka (Bryon Tjanaka)\n# Problem: (HackerRank) circular-array-rotation\nn, k, q = map(int, input().split())\nnums = list(map(int, input().split()))\nfor _ in range(q):\n    m = int(input())\n    print(nums[(m - k) % n])\n",
            "Contributor": "btjanaka",
            "Difficulty": "easy",
            "Link": "https://www.hackerrank.com/challenges/circular-array-rotation/problem",
            "Name": "Circular Array Rotation",
            "Note": "",
            "Session": "",
            "Solution": "circular-array-rotation.py",
            "SubmitDate": "Sun Apr 21 2019 23:58:36 GMT-0700 (Pacific Daylight Time)"
        },
        "-LdIYyMqq9XxyZnrYYHL": {
            "Code": "class Solution {\r\n    int[] factions;\r\n    \r\n    public int root_get(int n){\r\n        int r = factions[n];\r\n        while(factions[r] != r){\r\n            r = factions[r];\r\n        }\r\n        factions[n] = r;\r\n        return r;\r\n    }\r\n    \r\n    public int findCircleNum(int[][] M) {\r\n        int N = M.length;\r\n        factions = new int[N];\r\n        for(int i=0;i<N;++i){\r\n            factions[i] = i;\r\n        }\r\n        for(int i=0;i<N-1;++i){\r\n            for(int j=i+1;j<N;++j){\r\n                if(M[i][j] != 0){\r\n                    factions[root_get(j)] = root_get(i);\r\n                }\r\n            }\r\n        }\r\n        int ans = 0;\r\n        int[] factions_alive = new int[N];\r\n        for(int i=0;i<N;++i){\r\n            if(factions_alive[root_get(i)]++ == 0){\r\n                ++ans;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://leetcode.com/problems/friend-circles",
            "Name": "Friend Circles",
            "Note": "CC union-find!",
            "Session": "",
            "Solution": "friend_circles.java",
            "SubmitDate": "Thu Apr 25 2019 01:15:01 GMT-0700 (Pacific Daylight Time)"
        },
        "-LdIuiNUhHLVBt0xIiiS": {
            "Code": "class Solution:\r\n    def calcEquation(self, equations, values, queries):\r\n        ancestor = {}#k:(v,k/v)\r\n        def get_root(var):\r\n            root,rat = ancestor[var]\r\n            while root != ancestor[root][0]:\r\n                root,ratp = ancestor[root]\r\n                rat*=ratp\r\n            ancestor[var] = (root,rat)\r\n            return root,rat\r\n        i = 0\r\n        while i < len(equations):\r\n            n,d = equations[i]\r\n            v = values[i]\r\n            if d in ancestor:\r\n                anc,anc_rat = get_root(d)\r\n                ancestor[n] = (anc,v*anc_rat)\r\n            elif n in ancestor:\r\n                anc,anc_rat = get_root(n)\r\n                ancestor[d] = (anc,1/v*anc_rat)\r\n            else:\r\n                ancestor[d] = (d,1.0)\r\n                i-=1\r\n            i+=1\r\n        results = []\r\n        for n,d in queries:\r\n            ans = -1.0\r\n            if n in ancestor and d in ancestor:\r\n                na,nar = get_root(n)\r\n                da,dar = get_root(d)\r\n                if na == da:\r\n                    results.append(nar/dar)\r\n                    continue\r\n            results.append(ans)\r\n        return results",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://leetcode.com/problems/evaluate-division",
            "Name": "Evaluate Division",
            "Note": "think graphs",
            "Session": "",
            "Solution": "evaluate_division.py",
            "SubmitDate": "Thu Apr 25 2019 02:54:25 GMT-0700 (Pacific Daylight Time)"
        },
        "-LdKX4nHFh_AtQ7o1T2G": {
            "Code": "#import <Foundation/Foundation.h>\n\nint main(int argc, const char * argv[]) {\n    NSUInteger n;\n    scanf(\"%ld\", &n);\n    \n    NSUInteger sum = 0;\n    for (NSUInteger i = 0; i < n; i++) {\n        NSUInteger p;\n        scanf(\"%ld\", &p);\n        NSUInteger num = p / 10;\n        NSUInteger pow = p % 10;\n        NSUInteger term = powl(num, pow);\n        sum += term;\n    }\n    printf(\"%ld\", sum);\n    return 0;\n}\n",
            "Contributor": "aphilipe",
            "Difficulty": "easy",
            "Link": "https://open.kattis.com/problems/pot",
            "Name": "Pot",
            "Note": "",
            "Session": "",
            "Solution": "main.m",
            "SubmitDate": "Thu Apr 25 2019 10:26:01 GMT-0700 (PDT)"
        },
        "-LdKuu7MScdcb3iQ-hQ7": {
            "Code": "package main\n\nimport \"fmt\"\n\n// Store number of connections of nodes\n// Store lengths of all connections between pairs of nodes\n// Note: There maybe be more than one connection between two nodes\n\n// Data structure to represent the Raiload Map\ntype railMap struct {\n\t// Number of connections of each node\n\tconnCounts []int\n\t// Slice of connection lengths between key1 and key2\n\tdists map[int]map[int][]int\n}\n\nfunc newRailMap(n int) *railMap {\n\tm := new(railMap)\n\tm.connCounts = make([]int, n)\n\tm.dists = make(map[int]map[int][]int, n)\n\treturn m\n}\n\n// Get all neighbors of a node i\nfunc (m *railMap) getNeighbors(i int) []int {\n\tneighbors := make([]int, 0, len(m.dists[i]))\n\tfor n := range m.dists[i] {\n\t\tneighbors = append(neighbors, n)\n\t}\n\treturn neighbors\n}\n\n// Add connection between a and b (may be equal) of lenght c\nfunc (m *railMap) addConnection(a, b, c int) {\n\tif a == b {\n\t\tm.connCounts[a] += 2\n\t\t_, ok := m.dists[a]\n\t\tif !ok {\n\t\t\tm.dists[a] = make(map[int][]int, 10)\n\t\t}\n\t\tm.dists[a][a] = append(m.dists[a][a], c)\n\t} else {\n\t\tm.connCounts[a]++\n\t\tm.connCounts[b]++\n\t\t_, ok := m.dists[a]\n\t\tif !ok {\n\t\t\tm.dists[a] = make(map[int][]int, 10)\n\t\t}\n\t\t_, ok = m.dists[b]\n\t\tif !ok {\n\t\t\tm.dists[b] = make(map[int][]int, 10)\n\t\t}\n\t\tm.dists[a][b] = append(m.dists[a][b], c)\n\t\tm.dists[b][a] = append(m.dists[b][a], c)\n\t}\n}\n\n// Delete all connections between a and b (may not be equal)\nfunc (m *railMap) removeConnections(a, b int) {\n\tm.connCounts[a]--\n\tm.connCounts[b]--\n\tdelete(m.dists[a], b)\n\tdelete(m.dists[b], a)\n}\n\nfunc test() {\n\t// Process input:\n\tvar n, m, d int\n\tfmt.Scan(&n, &m)\n\n\trails := newRailMap(n)\n\n\tfor i := 0; i < m; i++ {\n\t\tvar a, b, c int\n\t\tfmt.Scan(&a, &b, &c)\n\t\ta--\n\t\tb--\n\n\t\trails.addConnection(a, b, c)\n\t}\n\n\t// Remove all nodes with exactly two connections:\n\tfor i := 0; i < n; i++ {\n\t\tif rails.connCounts[i] != 2 {\n\t\t\tcontinue\n\t\t}\n\n\t\tneighbors := rails.getNeighbors(i)\n\t\tif len(neighbors) == 2 {\n\t\t\t// Node i has two distinct neighbors\n\t\t\ta, b := neighbors[0], neighbors[1]\n\t\t\tl1, l2 := rails.dists[i][a][0], rails.dists[i][b][0]\n\n\t\t\trails.removeConnections(a, i)\n\t\t\trails.removeConnections(b, i)\n\t\t\trails.addConnection(a, b, l1+l2)\n\t\t} else {\n\t\t\t// Node i has two connections to only one neighbor (cycle)\n\t\t\tj := neighbors[0]\n\t\t\tls := rails.dists[i][j]\n\t\t\trails.removeConnections(i, j)\n\t\t\trails.addConnection(j, j, ls[0]+ls[1])\n\t\t}\n\t\td++\n\t}\n\n\t// Print new rail map:\n\tfmt.Println(m - d)\n\tfor a := 0; a < n; a++ {\n\t\tif rails.connCounts[a] == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tfor b, c := range rails.dists[a] {\n\t\t\tif a > b {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, l := range c {\n\t\t\t\tfmt.Printf(\"%d %d %d\\n\", a+1, b+1, l)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc main() {\n\tvar t int\n\tfmt.Scan(&t)\n\tfor i := 0; i < t; i++ {\n\t\ttest()\n\t\tif i+1 < t {\n\t\t\tfmt.Println()\n\t\t}\n\t}\n}\n",
            "Contributor": "aphilipe",
            "Difficulty": "med",
            "Link": "https://open.kattis.com/problems/railroad",
            "Name": "Railroad Map",
            "Note": "",
            "Session": "",
            "Solution": "RailroadMap.go",
            "SubmitDate": "Thu Apr 25 2019 12:14:27 GMT-0700 (PDT)"
        },
        "-LdKzZcUQLAtBgA3wOtn": {
            "Code": "<?php\r\n    fscanf(STDIN, \"%d %d\", $X, $Y);\r\n    if ($Y % 2 == 0) {\r\n        fprintf(STDOUT, \"possible\");\r\n    }else{\r\n        fprintf(STDOUT, \"impossible\");\r\n    }\r\n?>",
            "Contributor": "aphilipe",
            "Difficulty": "easy",
            "Link": "https://open.kattis.com/problems/railroad2",
            "Name": "Railroad",
            "Note": "Handshaking lemma",
            "Session": "",
            "Solution": "railroad2.php",
            "SubmitDate": "Thu Apr 25 2019 12:34:49 GMT-0700 (PDT)"
        },
        "-LdYAwq8c_jc2w8OOrxT": {
            "Code": "#!/bin/python3\r\n# https://www.hackerrank.com/challenges/construct-the-array/problem\r\nimport sys\r\nMOD = (10**9+7)\r\n\r\ndef countArray(n, k, x):\r\n    memo = [None]*(n+1)# dp for recurs countArray(n,k,x)=(k-1)**(n-2)-countArray(n-1,k,x)\r\n    pow_mem=[1]*(n+1)# dp to reduce complexity of powers to O(1) for fast lookup\r\n    for i in range(1,n+1):\r\n        pow_mem[i]=(pow_mem[i-1]*(k-1))%MOD\r\n    if n>=2:# edge cases\r\n        memo[2]=0\r\n    if n>=3:\r\n        memo[3]=k-2+int(x==1)# note edge case if both start & end are 1\r\n    for i in range(4,n+1):\r\n        memo[i]=pow_mem[i-2]-memo[i-1]\r\n    return memo[n]%MOD\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    n, k, x = input().strip().split(' ')\r\n    n, k, x = [int(n), int(k), int(x)]\r\n    answer = countArray(n, k, x)\r\n    print(answer)",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://www.hackerrank.com/challenges/construct-the-array/problem",
            "Name": "Construct the Array",
            "Note": "DP. look for recursive reduction",
            "Session": "",
            "Solution": "construct_the_array.py",
            "SubmitDate": "Sun Apr 28 2019 02:03:58 GMT-0700 (Pacific Daylight Time)"
        },
        "-LdYC5YHhG1klQbnchyT": {
            "Code": "# https://www.hackerrank.com/challenges/equal/problem\r\n# group differences\r\nfor t in range(int(input())):\r\n    n = int(input())\r\n    choco = list(map(int,input().split()))\r\n    n_ops = lambda c: c//5+(c%5)//2+(c%5)%2 # finds min # of ops to send this worker to delta of 0 chocolates\r\n    poor = min(choco)\r\n    nred = [sum(map(lambda c: n_ops(c-poor+i),choco)) for i in range(3)] # optimal min could be lower than actual, but only 1,2, lower as 3+ is just combos of 1&2\r\n    print(min(nred))",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://www.hackerrank.com/challenges/equal/problem",
            "Name": "Equal Chocolates",
            "Note": "how does the operation change the relative differences in chocolates?\nAlso, the optimum final # of chocolates/person could be greater than twice the maximum... (ex: 0,4,4)",
            "Session": "",
            "Solution": "equal.py",
            "SubmitDate": "Sun Apr 28 2019 02:09:00 GMT-0700 (Pacific Daylight Time)"
        },
        "-Lda8JLdH9nzF03LkSMj": {
            "Code": "# https://www.hackerrank.com/contests/data-structure-tasks-binary-tree-union-find/challenges/binary-expression-tree\r\n# bst, post-order traversal\r\nimport sys\r\n\r\nbst = []\r\ndef add(cmd):\r\n    new_node = [cmd[-1],None,None]\r\n    if len(cmd) != 1:\r\n        cur = 0\r\n        for i in range(len(cmd)-2):\r\n            cur = bst[cur][1 if cmd[i] == \"L\" else 2]\r\n        bst[cur][1 if cmd[-2] == \"L\" else 2] = len(bst)\r\n    bst.append(new_node)\r\ndef post_order():\r\n    q = [bst[0]]\r\n    vals = []\r\n    while len(q) > 0:\r\n        cur = q.pop()\r\n        if not cur[1] and not cur[2]:\r\n            vals.append(cur[0])\r\n        else:\r\n            q.append([cur[0],None,None])\r\n            if cur[2]:\r\n                q.append(bst[cur[2]])\r\n            if cur[1]:\r\n                q.append(bst[cur[1]])\r\n    return ' '.join(vals)\r\n\r\nfor line in sys.stdin:\r\n    add(line.strip())\r\nprint(post_order())",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://www.hackerrank.com/contests/data-structure-tasks-binary-tree-union-find/challenges/binary-expression-tree",
            "Name": "Binary Expression Tree",
            "Note": "",
            "Session": "",
            "Solution": "binary_expression_tree.py",
            "SubmitDate": "Sun Apr 28 2019 15:51:21 GMT-0700 (Pacific Daylight Time)"
        },
        "-Lda8_9TeyeaCNsWRvet": {
            "Code": "# https://www.hackerrank.com/contests/data-structure-tasks-binary-tree-union-find/challenges/connected-component\r\n# union-find connected components\r\nimport sys\r\nn = int(input())\r\nfactions = list(range(n+1))\r\ndef find(node):\r\n    root = factions[node]\r\n    while root != factions[root]:\r\n        root = factions[root]\r\n    factions[node] = root\r\n    return root\r\ncc = n\r\nfor line in sys.stdin:\r\n    u,v = map(int,line.split())\r\n    cycle = \"\"\r\n    pu,pv = find(u),find(v)\r\n    if pu == pv:\r\n        cycle = \" CYCLE FORMED!\"\r\n    else:\r\n        factions[pv] = pu\r\n        cc-=1\r\n    print(\"{}{}\".format(cc,cycle))",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://www.hackerrank.com/contests/data-structure-tasks-binary-tree-union-find/challenges/connected-component",
            "Name": "Connected Components",
            "Note": "",
            "Session": "",
            "Solution": "connected_component.py",
            "SubmitDate": "Sun Apr 28 2019 15:52:30 GMT-0700 (Pacific Daylight Time)"
        },
        "-Ldb7AgpWeA8aJHifdUQ": {
            "Code": "class Solution(object):\r\n    def mergeTwoLists(self, l1, l2):\r\n        \"\"\"\r\n        :type l1: ListNode\r\n        :type l2: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        ret = ans = ListNode(0)\r\n        while l1!=None and l2!=None:\r\n            print(l1.val,l2.val)\r\n            if l1.val<l2.val:\r\n                ans.next = l1\r\n                l1 = l1.next\r\n            else:\r\n                ans.next = l2\r\n                l2 = l2.next\r\n            ans = ans.next\r\n        if l1!=None:\r\n            ans.next = l1\r\n        if l2!=None:\r\n            ans.next = l2\r\n        return ret.next",
            "Contributor": "bwakasa",
            "Difficulty": "easy",
            "File": "",
            "Link": "https://leetcode.com/problems/merge-two-sorted-lists",
            "Name": "Merge-two-sorted",
            "Note": "",
            "Session": "",
            "Solution": "merge-two-sorted.py",
            "SubmitDate": "Sun Apr 28 2019 20:25:59 GMT-0700 (Pacific Daylight Time)"
        },
        "-LdbBVBTZybyYvd6-34p": {
            "Code": "class Solution(object):\r\n    def searchRange(self, nums, target):\r\n        \"\"\"\r\n        :type nums: List[int]\r\n        :type target: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        print(nums)\r\n        if len(nums)==0:\r\n            return [-1,-1]\r\n        if len(nums)<2:\r\n            \r\n            if nums[0]==target:\r\n                return [0,0]\r\n            \r\n            return [-1,-1]",
            "Contributor": "bwakasa",
            "Difficulty": "easy",
            "File": "",
            "Link": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array",
            "Name": "First-and-last",
            "Note": "",
            "Session": "",
            "Solution": "first-and-last.py",
            "SubmitDate": "Sun Apr 28 2019 20:44:51 GMT-0700 (Pacific Daylight Time)"
        },
        "-LdcPd-ckJWTrYQizEkQ": {
            "Code": "from collections import defaultdict\r\n\r\ndef ransom_note(magazine, note):\r\n    mydict = defaultdict(int)\r\n    for word in magazine:\r\n        mydict[word]+=1\r\n    for word in note: \r\n        if mydict[word]==0 : \r\n        \treturn False \r\n        mydict[word]-=1\r\n    return True         \r\n        ",
            "Contributor": "bwakasa",
            "Difficulty": "easy",
            "Link": "https://www.hackerrank.com/challenges/ctci-ransom-note/problem",
            "Name": "Hash Tables: Ransom Note",
            "Note": "",
            "Session": "",
            "Solution": "ransom.py",
            "SubmitDate": "Mon Apr 29 2019 02:26:15 GMT-0700 (Pacific Daylight Time)"
        },
        "-LdkJAQ8E57KfLCAfd3J": {
            "Code": "num = int(input().strip())\r\nn = [int(i) for i in input().strip().split()]\r\nfirst = 0\r\nlast = num - 1\r\nans = []\r\nan = []\r\nctr = 1\r\nif n[first] < n[last]:\r\n    ans.append('L')\r\n    an.append(n[first])\r\n    first += 1\r\nelse:\r\n    ans.append('R')\r\n    an.append(n[last])\r\n    last -= 1\r\nwhile first <= last:\r\n    if n[first] < n[last] and n[first] > an[-1]:\r\n        an.append(n[first])\r\n        ans.append('L')\r\n        ctr += 1\r\n        first += 1\r\n    elif n[last] < n[first] and n[last] > an[-1]:\r\n        an.append(n[last])\r\n        ans.append('R')\r\n        ctr += 1\r\n        last -= 1\r\n    elif n[first] > an[-1]:\r\n        an.append(n[first])\r\n        ans.append('L')\r\n        ctr += 1\r\n        first += 1\r\n    elif n[last] > an[-1]:\r\n        an.append(n[last])\r\n        ans.append('R')\r\n        ctr += 1\r\n        last -= 1\r\n    else:\r\n        break\r\nprint(ctr)\r\nprint(''.join(ans))\r\n",
            "Contributor": "renjied",
            "Difficulty": "easy",
            "Link": "https://codeforces.com/contest/1157/problem/C1",
            "Name": "Increasing Subsequence (easy version)",
            "Note": "",
            "Session": "",
            "Solution": "C.py",
            "SubmitDate": "Tue Apr 30 2019 15:15:02 GMT-0700 (Pacific Daylight Time)"
        },
        "-LdkKjz6EnLdTEMPu6Wd": {
            "Code": "'''\r\n    Source: https://codeforces.com/contest/1132/problem/C\r\n    Author: Jacky Dai\r\n    Comment: Good practive problem, either use prefix sum array or a 2D lookup\r\n    table. If using look up table, table[i][j] represent the number of sections\r\n    that is not painted if we remove painter i and painter j. To get which sections\r\n    is(are) painted by which painter(s) preprocess the painters list and for each\r\n    painter's painting interval, store the painter number in an array\r\n    indicating the section is painted by that painter. A section can be painted\r\n    by many painters. However, we only care about those section that is painted\r\n    by exactly one and two painters because removing those painters would\r\n    affect our result.\r\n'''\r\nif __name__ == '__main__':\r\n    N,Q = map(int,input().strip().split())\r\n    '''preprocess painters'''\r\n    painters = []\r\n    for i in range(Q):\r\n        painters.append(tuple(map(int,input().strip().split())))\r\n    C = [[] for i in range(N+1)]\r\n    for i in range(len(painters)):\r\n        start,end = painters[i]\r\n        for j in range(start,end+1):\r\n            C[j].append(i)\r\n    C = C[1:]\r\n    \r\n    total = sum(1 for i in C if len(i) > 0)\r\n    count = [[0 for i in range(Q)] for j in range(Q)]\r\n    '''count how mant sections are not painted if removed i and j'''\r\n    for i in range(N):\r\n        if len(C[i]) == 2:\r\n            count[C[i][0]][C[i][1]] += 1\r\n            count[C[i][1]][C[i][0]] += 1\r\n        if len(C[i]) == 1:\r\n            for j in range(Q):\r\n                if j != C[i][0]:\r\n                    count[C[i][0]][j] += 1\r\n                    count[j][C[i][0]] += 1\r\n    '''choose minimum value from it'''              \r\n    mini = 100000\r\n    for i in range(Q):\r\n        for j in range(Q):\r\n            if i != j and count[i][j] < mini:\r\n                mini = count[i][j]\r\n    print(total - mini)\r\n    \r\n",
            "Contributor": "renjied",
            "Difficulty": "med",
            "Link": "https://codeforces.com/contest/1132/problem/C",
            "Name": "Painting the Fence",
            "Note": "",
            "Session": "",
            "Solution": "Csol.py",
            "SubmitDate": "Tue Apr 30 2019 15:21:54 GMT-0700 (Pacific Daylight Time)"
        },
        "-Le0utcGWSLhmH2Kz_Be": {
            "Code": "# https://open.kattis.com/problems/pearwise\r\n# took me about 30 minutes tops, directed graph construction & then dfs/traversal\r\nfrom collections import defaultdict,deque\r\n\r\nALPH = \"\".join([chr(i) for i in range(65,65+26)])\r\nn,m = map(int,raw_input().split())\r\ncand_comps = defaultdict(int)\r\nfor uniq_ballot in range(m):\r\n    ppl,ballot = raw_input().split()\r\n    ppl = int(ppl)\r\n    for c1 in range(n-1):\r\n        for c2 in range(c1+1,n):\r\n            cand_comps[(ballot[c1],ballot[c2])]+=ppl\r\n\r\nwin_graph = defaultdict(set)\r\nfor i in range(n-1):\r\n    for j in range(i+1,n):\r\n        if cand_comps[(ALPH[i],ALPH[j])] > cand_comps[(ALPH[j],ALPH[i])]:\r\n            win_graph[ALPH[i]].add(ALPH[j])\r\n        else:\r\n            win_graph[ALPH[j]].add(ALPH[i])\r\n\r\ndef can_win(cand):\r\n    visited = set()\r\n    q = deque()\r\n    q.append(cand)\r\n    while len(q) > 0:\r\n        cur = q.pop()\r\n        if cur not in visited:\r\n            visited.add(cur)\r\n            for c in win_graph[cur]:\r\n                if c not in visited:\r\n                    q.append(c)\r\n    return len(visited) == n\r\n\r\nfor candidate in ALPH[:n]:\r\n    print(\"{}: can{} win\".format(candidate,\"\" if can_win(candidate) else \"'t\"))",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://open.kattis.com/problems/pearwise",
            "Name": "Pear-wise Voting",
            "Note": "This is a graph problem ... in disguise!",
            "Session": "",
            "Solution": "pearwise.py",
            "SubmitDate": "Sat May 04 2019 01:26:08 GMT-0700 (Pacific Daylight Time)"
        },
        "-Le0vQPq5sLdfxDfxrCQ": {
            "Code": "# https://open.kattis.com/problems/carvet\r\n# took me about an hour, most important insight is that because only 1 gap, each car can move only once\r\n# from there u can realize that if a car can only move once if a car is covering a part, \r\n# there is only one way to move that car to uncover the part.\r\n# then u work backwards, sending the part until it moves somewhere which isn't a car\r\nm,n = map(int,raw_input().split())\r\ngrid = [list(map(int,raw_input().split())) for i in range(m)]\r\nhole = (-1,-1)\r\nfor i in range(m):\r\n    for j in range(n):\r\n        if grid[i][j] == -1:\r\n            hole = (i,j)\r\n            break\r\nnut = [int(i)-1 for i in raw_input().split()]\r\ncars = []\r\nvisited = set()\r\nwhile True:\r\n    if nut[0] < 0 or nut[0] >= m or nut[1] < 0 or nut[1] >= n:\r\n        break\r\n    elif tuple(nut) in visited: # edge case of a loop\r\n        break\r\n    else:\r\n        car = grid[nut[0]][nut[1]]\r\n        if car < 0:\r\n            break\r\n        else:\r\n            visited.add(tuple(nut))\r\n            if nut[0]>0 and grid[nut[0]-1][nut[1]] == car:\r\n                nut[0]-=2\r\n            elif nut[0]<m-1 and grid[nut[0]+1][nut[1]] == car:\r\n                nut[0]+=2\r\n            elif nut[1]>0 and grid[nut[0]][nut[1]-1] == car:\r\n                nut[1]-=2\r\n            elif nut[1]<n-1 and grid[nut[0]][nut[1]+1] == car:\r\n                nut[1]+=2\r\n            cars.append(car)\r\n\r\nif nut[0] == hole[0] and nut[1] == hole[1]:\r\n    print(\" \".join([str(c) for c in cars[::-1]]))\r\nelse:\r\n    print(\"impossible\")",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://open.kattis.com/problems/carvet",
            "Name": "Car Vet",
            "Note": "easy implementation when you see the trick, but until then try working backwards...",
            "Session": "",
            "Solution": "carvet.py",
            "SubmitDate": "Tue May 07 2019 01:46:52 GMT-0700 (Pacific Daylight Time)"
        },
        "-LeAKmR7E02gvmL-9ZEZ": {
            "Code": "#include <iostream>\n#include <vector>\n#include <math.h>\nusing namespace std;\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    cout << ceil(log2(n)) + 1 << endl;\n    return 0;\n}\n\n",
            "Contributor": "jtuyls",
            "Difficulty": "easy",
            "Link": "https://open.kattis.com/problems/3dprinter",
            "Name": "3D Printed Statues",
            "Note": "Math ",
            "Session": "",
            "Solution": "main.cpp",
            "SubmitDate": "Sun May 05 2019 21:11:45 GMT-0700 (PDT)"
        },
        "-LeANeTlC49sybLQGVuP": {
            "Code": "#include <iostream>\n#include <vector>\n#include <math.h>\nusing namespace std;\n\nint main() {\n    int t; scanf(\"%d\", &t);\n    while (t --> 0) {\n        int n; scanf(\"%d\", &n);\n        double total = 0.0;\n        int scores[n];\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%d\", &scores[i]);\n            total += scores[i]; \n        }\n        double avg = total/n;\n        \n        // find how many are above\n        double above_avg = 0.0;\n        for (int i = 0; i < n; ++i) {\n            if (scores[i] > avg) {\n                above_avg++;\n            }\n        }\n\n        printf(\"%.3f%%\\n\", above_avg/n * 100);\n    }\n    return 0;\n}\n\n",
            "Contributor": "jtuyls",
            "Difficulty": "easy",
            "Link": "https://open.kattis.com/problems/aboveaverage",
            "Name": "Above Average",
            "Note": "Simulate ",
            "Session": "",
            "Solution": "main.cpp",
            "SubmitDate": "Sun May 05 2019 21:24:19 GMT-0700 (PDT)"
        },
        "-LeAU-TEWYbf9Vy33AAb": {
            "Code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    int books[n + 1];\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d\", &books[i]);\n    }\n\n    sort(books+1, books+n+1, greater<int>());\n    int result = 0;\n    for (int i = 1; i <= n; ++i) {\n        // cout << books[i] << \" \";\n        if (i % 3 != 0) {\n            result += books[i];\n        }\n    }\n    cout << result << endl;\n\n    return 0;\n}\n\n",
            "Contributor": "jtuyls",
            "Difficulty": "easy",
            "Link": "https://open.kattis.com/problems/akcija",
            "Name": "Akcija",
            "Note": "Greedy ",
            "Session": "",
            "Solution": "main.cpp",
            "SubmitDate": "Sun May 05 2019 21:52:02 GMT-0700 (PDT)"
        },
        "-LeBIjdWla4JkbNWAA_e": {
            "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Google Code Jam) Robot Programming Strategy\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> ii;\n\nint main() {\n  int ca;\n  cin >> ca;\n  for (int caa = 1; caa <= ca; ++caa) {\n    int a;\n    cin >> a;\n    vector<string> c(a);\n    vector<bool> won(a, false);\n    for (int i = 0; i < a; ++i) cin >> c[i];\n\n    string res = \"\";\n    bool chars[128];\n    int won_count = 0;\n    int prev_won = -1;\n    for (int i = 0; won_count < a && won_count != prev_won; ++i) {\n      // Reset\n      chars['R'] = chars['P'] = chars['S'] = false;\n\n      // Figure out which characters are present\n      for (int j = 0; j < a; ++j) {\n        if (won[j]) continue;\n        char ch = c[j][i % c[j].size()];\n        chars[ch] = true;\n      }\n\n      // Impossible if all 3 present\n      if (chars['R'] && chars['P'] && chars['S']) {\n        res = \"IMPOSSIBLE\";\n        break;\n      }\n\n      // Can beat\n      char tied_ch, beat_ch;\n      if (chars['R'] && chars['P']) {\n        tied_ch = 'P';\n        beat_ch = 'R';\n      } else if (chars['R'] && chars['S']) {\n        tied_ch = 'R';\n        beat_ch = 'S';\n      } else if (chars['S'] && chars['P']) {\n        tied_ch = 'S';\n        beat_ch = 'P';\n      } else if (chars['R']) {\n        tied_ch = 'P';\n        beat_ch = 'R';\n      } else if (chars['S']) {\n        tied_ch = 'R';\n        beat_ch = 'S';\n      } else if (chars['P']) {\n        tied_ch = 'S';\n        beat_ch = 'P';\n      }\n      res.push_back(tied_ch);\n\n      // Mark certain players as beat\n      prev_won = won_count;\n      for (int j = 0; j < a; ++j) {\n        char ch = c[j][i % c[j].size()];\n        if (!won[j] && ch == beat_ch) {\n          ++won_count;\n          won[j] = true;\n        }\n      }\n    }\n\n    printf(\"Case #%d: %s\\n\", caa, res.c_str());\n  }\n  return 0;\n}\n",
            "Contributor": "btjanaka",
            "Difficulty": "med",
            "Link": "https://codingcompetitions.withgoogle.com/codejam/round/00000000000516b9/0000000000134c90",
            "Name": "Robot Programming Strategy",
            "Note": "",
            "Session": "",
            "Solution": "robot-programming-strategy.cpp",
            "SubmitDate": "Mon May 06 2019 01:42:27 GMT-0700 (Pacific Daylight Time)"
        },
        "-LeJMtOVfn_p08TzBHE8": {
            "Code": "    def maxDepth(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        if root==None:\r\n            return 0\r\n        else:\r\n            return max(self.maxDepth(root.left)+1,self.maxDepth(root.right)+1)",
            "Contributor": "bwakasa",
            "Difficulty": "easy",
            "Link": "https://leetcode.com/problems/maximum-depth-of-binary-tree/submissions",
            "Name": "max depth",
            "Note": "",
            "Session": "",
            "Solution": "maxdepth.py",
            "SubmitDate": "Tue May 07 2019 15:17:33 GMT-0700 (Pacific Daylight Time)"
        },
        "-LeJxZsTItlwI5j3RaTH": {
            "Code": "import sys,threading\r\nsys.setrecursionlimit(200000)\r\nthreading.stack_size(20480000)\r\n#thread = threading.Thread(target=main)\r\n#thread.start()\r\nn = int(input().strip())\r\ntree = dict()\r\nnumbers = [int(i) for i in input().strip().split()]\r\n\r\nfor i in range(n - 1):\r\n    child = i + 2\r\n    parent = numbers[i]\r\n    if parent not in tree:\r\n        tree[parent] = [child]\r\n    else:\r\n        tree[parent].append(child)\r\n\r\nvals = [0]\r\nfor i in input().strip().split():\r\n    val = int(i)\r\n    vals.append(0 if val == -1 else val)\r\n\r\nimpossible = [False]\r\nresidual = [0 for i in range(n+1)]\r\ndef dfs(root,total = 0,odd = True,prev = 0):\r\n    if odd and vals[root] < vals[prev]:\r\n        impossible[0] = True\r\n        return total\r\n    if root not in tree:\r\n        if odd:\r\n            residual[root] = 0 if vals[root] - total < 0 else vals[root] - total\r\n            return total\r\n        else:\r\n            return vals[root]\r\n    if odd:\r\n        result = vals[root]\r\n    else:\r\n        result = min(vals[i] for i in tree[root])\r\n    residual[root] = 0 if  result - total  < 0 else result - total\r\n    total = result\r\n    for i in tree[root]:\r\n        dfs(i,total,False if odd else True,root if odd else prev)\r\n    return total\r\npatho = False\r\nif n > 100:\r\n    patho = True\r\n    for i in range(1,100):\r\n        if numbers[i-1] < numbers[i]:\r\n            pass\r\n        else:\r\n            patho = False\r\n            break\r\nif patho:\r\n    impossible = False\r\n    for i in range(len(vals)):\r\n        if i + 2 < len(vals):\r\n            if vals[i] > vals[i + 2]:\r\n                impossible = True\r\n                break\r\n    print(vals[numbers[-1]] if not impossible else -1)\r\nelse:\r\n    total = dfs(1)\r\n    if impossible[0]:\r\n        print(-1)\r\n    else:\r\n        print(sum(residual))\r\n",
            "Contributor": "renjied",
            "Difficulty": "med",
            "Link": "https://codeforces.com/contest/1099/problem/D",
            "Name": "Sum in the tree",
            "Note": "",
            "Session": "",
            "Solution": "D1.py",
            "SubmitDate": "Tue May 07 2019 18:02:11 GMT-0700 (Pacific Daylight Time)"
        },
        "-Lech22wM242Td7b6MRs": {
            "Code": "n,m = map(int,input().split())\r\ngrid = []\r\ngrid.append([0 for a in range(m+2)])\r\nfor a in range(n):\r\n    grid.append([0]+[int(b) for b in input()]+[0])\r\ngrid.append([0 for a in range(m+2)])\r\nq = set()\r\nq.add((0,0))\r\nvisited = set()\r\nn+=2\r\nm+=2\r\n'''\r\nfor a in range(n):\r\n    [print(b,end=\"\") for b in grid[a]]\r\n    print()\r\n'''\r\n    \r\ndef get_coast(r,c):\r\n    result = 0\r\n    if r > 0 and grid[r-1][c] == 1:\r\n        result+=1\r\n    if r < n-1 and grid[r+1][c] == 1:\r\n        result+=1\r\n    if c > 0 and grid[r][c-1] == 1:\r\n        result+=1\r\n    if c < m-1 and grid[r][c+1] == 1:\r\n        result+=1\r\n    return result    \r\n    \r\ncoast = 0\r\nwhile len(q)>0:\r\n    r,c = q.pop()\r\n    visited.add((r,c))\r\n    if grid[r][c] == 0:\r\n        grid[r][c] = 2\r\n        coast+=get_coast(r,c)\r\n        if r > 0 and grid[r-1][c] == 0 and (r-1,c) not in visited:\r\n            q.add((r-1,c))\r\n        if r < n-1 and grid[r+1][c] == 0 and (r+1,c) not in visited:\r\n            q.add((r+1,c))\r\n        if c > 0 and grid[r][c-1] == 0 and (r,c-1) not in visited:\r\n            q.add((r,c-1))\r\n        if c < m-1 and grid[r][c+1] == 0 and (r,c+1) not in visited:\r\n            q.add((r,c+1))\r\n'''\r\nfor a in range(n):\r\n    [print(b,end=\"\") for b in grid[a]]\r\n    print()\r\n'''\r\nprint(coast)",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://open.kattis.com/problems/coast",
            "Name": "Coast",
            "Note": "fill method, but don't step on the land",
            "Session": "",
            "Solution": "coast.py",
            "SubmitDate": "Sat May 11 2019 14:02:25 GMT-0700 (Pacific Daylight Time)"
        },
        "-LechfE3U6rnhJM3Dzc7": {
            "Code": "// https://www.hackerrank.com/challenges/coin-change/problem\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Solution {\r\n\r\n    // 1d-dp\r\n    static long getWays(int n, int[] c) {\r\n        long[] ways = new long[n+1];\r\n        ways[0]=1;\r\n        for(int coin:c){\r\n            for(int i=0;i<n+1-coin;++i){\r\n                if(ways[i]>0){\r\n                    ways[i+coin]+=ways[i];\r\n                }\r\n            }\r\n        }\r\n        return ways[n];\r\n    }\r\n\r\n    private static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        String[] nm = br.readLine().split(\" \");\r\n\r\n        int n = Integer.parseInt(nm[0]);\r\n        int m = Integer.parseInt(nm[1]);\r\n        int[] c = new int[m];\r\n        String[] cItems = br.readLine().split(\" \");\r\n        for (int i = 0; i < m; i++) {\r\n            c[i] = Integer.parseInt(cItems[i]);\r\n        }\r\n\r\n        System.out.println(getWays(n, c));\r\n    }\r\n}",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://www.hackerrank.com/challenges/coin-change/problem",
            "Name": "Coin Change",
            "Note": "standard introduction to DP",
            "Session": "",
            "Solution": "coin_change.java",
            "SubmitDate": "Sat May 11 2019 14:05:10 GMT-0700 (Pacific Daylight Time)"
        },
        "-LeiiIMhCbMKnzHiqRmI": {
            "Code": "# Author: btjanaka (Bryon Tjanaka)\n# Problem: (UVa) 452\n# Idea: Shortest path algorithm in a DAG - find topological ordering then go\n# through and relax all edges - O(E) time.\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\nca = int(input())\ninput()\n\nfor caa in range(ca):\n    g = defaultdict(set)\n    cost = defaultdict(int)\n    indeg = defaultdict(int)\n    while True:\n        try:\n            line = input().strip()\n        except EOFError:\n            break\n\n        if line == \"\": break\n        tokens = line.split()\n        if len(tokens) == 2:\n            v, c = tokens\n            incoming = \"\"\n        else:\n            v, c, incoming = tokens\n        cost[v] = -int(c)\n        indeg[v] = len(incoming)\n        for u in incoming:\n            g[u].add(v)\n            g[v]\n\n    # topo sort\n    topo = []\n    q = deque()\n    dist = {u: 1 << 31 for u in g}\n    for u in indeg:\n        if indeg[u] == 0:\n            q.append(u)\n            dist[u] = cost[u]\n    while len(q) > 0:\n        u = q.popleft()\n        topo.append(u)\n        for v in g[u]:\n            indeg[v] -= 1\n            if indeg[v] == 0: q.append(v)\n\n    # find min\n    for u in topo:\n        for v in g[u]:\n            dist[v] = min(dist[v], dist[u] + cost[v])\n\n    print(-min(dist.values()))\n    if caa != ca - 1: print()\n",
            "Contributor": "btjanaka",
            "Difficulty": "easy",
            "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=0&problem=393",
            "Name": "Project Scheduling",
            "Note": "You can go faster then Dijkstra's",
            "Session": "",
            "Solution": "452.py",
            "SubmitDate": "Sun May 12 2019 18:05:34 GMT-0700 (Pacific Daylight Time)"
        },
        "-Leiwwwr4i0O-zH0iPWh": {
            "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (UVa) 558\n// Idea: Use Bellman-Ford, and if it makes changes for more than n cycles, there\n// is a negative cycle.\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\nint main() {\n  int ca;\n  GET(ca);\n  while (ca--) {\n    int n, m;\n    GET(n);\n    GET(m);\n    vector<vector<ii>> g(n);\n    for (int i = 0; i < m; ++i) {\n      int x, y, t;\n      GET(x);\n      GET(y);\n      GET(t);\n      g[x].push_back({y, t});\n    }\n\n    vector<int> d(n, INT_MAX);\n    d[0] = 0;\n    bool ok = false;\n    for (int i = 1;; ++i) {\n      bool change = false;\n      for (int u = 0; u < n; ++u) {\n        for (int j = 0; j < g[u].size(); ++j) {\n          int v, w;\n          tie(v, w) = g[u][j];\n          if (d[u] + w < d[v]) {\n            change = true;\n            d[v] = d[u] + w;\n          }\n        }\n      }\n\n      if (!change && i <= n) {\n        break;\n      } else if (i > n) {\n        ok = true;\n        break;\n      }\n    }\n\n    printf(ok ? \"possible\\n\" : \"not possible\\n\");\n  }\n  return 0;\n}\n",
            "Contributor": "btjanaka",
            "Difficulty": "easy",
            "Link": "https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=0&problem=499",
            "Name": "Wormholes",
            "Note": "Bellman Ford",
            "Session": "",
            "Solution": "558.cpp",
            "SubmitDate": "Sun May 12 2019 19:09:35 GMT-0700 (Pacific Daylight Time)"
        },
        "-LejR001ZcpbUXPCex2Y": {
            "Code": "n = int(input())\r\n\r\nfor _ in range(n):\r\n    vals = list(map(int,input().split()))\r\n    vals.sort()\r\n    allvals = [(vals[0],vals[1])]\r\n    absval = abs(vals[0]-vals[1])\r\n    \r\n    for i in range(1,len(vals)):\r\n        if i<len(vals)-1:\r\n            \r\n            if abs(vals[i]-vals[i+1])<absval:\r\n                absval = abs(vals[i]-vals[i+1])\r\n                allvals = [(vals[i],vals[i+1])]\r\n            elif abs(vals[i]-vals[i+1])==absval:\r\n                allvals.append((vals[i],vals[i+1]))\r\n    for pairs in allvals:\r\n        for pair in pairs:\r\n            print(pair,end =\" \")\r\n    ",
            "Contributor": "bwakasa",
            "Difficulty": "easy",
            "Link": "https://www.hackerrank.com/challenges/closest-numbers/problem",
            "Name": "Closest-numbers",
            "Note": "",
            "Session": "",
            "Solution": "ans.py",
            "SubmitDate": "Sun May 12 2019 21:25:18 GMT-0700 (Pacific Daylight Time)"
        },
        "-LeoM6Lt5ES35b2fO1e-": {
            "Code": "#https://www.hackerrank.com/challenges/abbr/problem\r\n# DFS/DP, hash previous compututations\r\nfrom collections import deque\r\nUPPERS = set(chr(i) for i in range(65,65+26))\r\nQ = int(input())\r\nfor q in range(Q):\r\n    a,b = input(),input()\r\n    stk = deque()\r\n    stk.append((0,0))\r\n    visited = set()\r\n    while len(stk)>0:\r\n        ai,bi = stk.pop()\r\n        if (ai,bi) not in visited:\r\n            if bi == len(b):\r\n                if ai == len(a):\r\n                    print(\"YES\")\r\n                    break\r\n                elif a[ai] not in UPPERS:\r\n                    stk.append((ai+1,bi))\r\n            elif ai < len(a):\r\n                if a[ai] == b[bi]:\r\n                    stk.append((ai+1,bi+1))\r\n                elif a[ai] not in UPPERS:\r\n                    stk.append((ai+1,bi))\r\n                    if a[ai].upper() == b[bi]:\r\n                        stk.append((ai+1,bi+1))\r\n            visited.add((ai,bi))       \r\n    else:\r\n        print(\"NO\")",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://www.hackerrank.com/challenges/abbr/problem",
            "Name": "Abbreviation",
            "Note": "hash old calculations to learn from previous mistakes",
            "Session": "",
            "Solution": "abbreviation.py",
            "SubmitDate": "Mon May 13 2019 20:22:01 GMT-0700 (Pacific Daylight Time)"
        },
        "-LeoQ-vcj2tDhHDp3Iso": {
            "Code": "n,m = map(int,input().strip().split())\r\nboy_give = [int(i) for i in input().strip().split()]\r\ngirl_recv = [int(i) for i in input().strip().split()]\r\nboy_give.sort(reverse = True); girl_min = min(girl_recv); girl_sum = sum(girl_recv)\r\ngirl_recv = set(girl_recv)\r\n\r\nans = 0\r\nhas = True\r\ncomplete = False\r\nif boy_give[0] > girl_min:\r\n    has = False\r\nelse:\r\n    if boy_give[0] in girl_recv:\r\n        ans += girl_sum\r\n        complete = True\r\n    else:\r\n        ans += girl_sum - girl_min + boy_give[0]\r\n\r\nif has:\r\n    if complete:\r\n        for i in range(1,n):\r\n            if boy_give[i] > girl_min:\r\n                has = False\r\n                break\r\n            ans += boy_give[i] * m\r\n    else:\r\n        if boy_give[1] > girl_min:\r\n            has = False\r\n        else:\r\n            ans += girl_min + boy_give[1] * (m - 1)\r\n            \r\n        for i in range(2,n):\r\n            if boy_give[i] > girl_min:\r\n                has = False\r\n                break\r\n            ans += boy_give[i] * m\r\n\r\n    if has:\r\n        print(ans)\r\n    else:\r\n        print(-1)\r\nelse:\r\n    print(-1)\r\n",
            "Contributor": "renjied",
            "Difficulty": "easy",
            "Link": "https://codeforces.com/contest/1159/problem/C",
            "Name": "The Party and Sweets",
            "Note": "implementation, logic",
            "Session": "",
            "Solution": "C.py",
            "SubmitDate": "Mon May 13 2019 20:39:04 GMT-0700 (Pacific Daylight Time)"
        },
        "-LezWMgKVYTtGO5JE4LE": {
            "Code": "class Solution(object):\r\n    def findDuplicate(self, nums):\r\n        \"\"\"\r\n        :type nums: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        first = nums[0]\r\n        second =nums[nums[0]]\r\n        \r\n        while first!=second:\r\n            first = nums[first]\r\n            second= nums[nums[second]]\r\n        first = 0\r\n        while(first!=second):\r\n            first = nums[first]\r\n            second = nums[second]\r\n            \r\n        return first",
            "Contributor": "bwakasa",
            "Difficulty": "easy",
            "Link": "https://leetcode.com/problems/find-the-duplicate-number",
            "Name": "Find the Duplicate Number",
            "Note": "",
            "Session": "",
            "Solution": "find_duplicate.py",
            "SubmitDate": "Thu May 16 2019 00:22:37 GMT-0700 (Pacific Daylight Time)"
        },
        "-LfHEZa2WysZTtVSW-Ly": {
            "Code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    set<pair<int, int>> minions;\n    for (int i = 0; i < n; ++i) {\n        int l, h; scanf(\"%d %d\", &l, &h);\n        minions.insert(make_pair(l, h));\n    }\n\n    vector<int> rooms;\n    while (!minions.empty()) {\n        // get first element in the set\n        set<pair<int, int>>::iterator it = minions.begin();\n        pair<int, int> cur_range = *it;\n        // cout << cur_range.first << \" \" << cur_range.second << endl;\n        set<pair<int, int>>::iterator temp = it;\n        ++it;\n        minions.erase(temp); \n        while (it != minions.end()) {\n            // cout << \"in while\" << endl;\n            if (cur_range.second >= it->first && cur_range.first <= it->first) {\n                int l = max(cur_range.first, it->first);\n                int h = min(cur_range.second, it->second);\n                cur_range = make_pair(l, h);\n                // cout << \"updated range \" << cur_range.first << \" \" << cur_range.second << endl;\n                set<pair<int, int>>::iterator temp = it;\n                ++it;\n                minions.erase(temp); \n                continue;\n            } \n            ++it;\n        }\n        // cout << \"hello\" << endl;\n        rooms.push_back(cur_range.first);\n    }\n\n    // cout << \"rooms: \" << endl;\n    // for (auto el: rooms) {\n    //     cout << el << endl;\n    // }\n\n    // cout << \"number of rooms \" << rooms.size() << endl;\n    cout << rooms.size() << endl;\n}\n\n",
            "Contributor": "jtuyls",
            "Difficulty": "med",
            "Link": "https://open.kattis.com/problems/airconditioned",
            "Name": "Air Conditioned Minions",
            "Note": "Greedy ",
            "Session": "",
            "Solution": "main.cpp",
            "SubmitDate": "Sun May 19 2019 15:37:38 GMT-0700 (PDT)"
        },
        "-LfIWT4VAkdpKoJx9Nn0": {
            "Code": "class Solution:\r\n    def singleNumber(self, nums: List[int]) -> int:\r\n        total =0\r\n        for num in nums:\r\n            total ^=num\r\n        return total",
            "Contributor": "bwakasa",
            "Difficulty": "easy",
            "Link": "https://leetcode.com/problems/single-number/submissions",
            "Name": "Single Number",
            "Note": "bit",
            "Session": "",
            "Solution": "single_number.py",
            "SubmitDate": "Sun May 19 2019 21:35:29 GMT-0700 (Pacific Daylight Time)"
        },
        "-LfI_grw8moMXBLFSkQe": {
            "Code": "class Solution(object):\r\n    def isSubsequence(self, s, t):\r\n        \"\"\"\r\n        :type s: str\r\n        :type t: str\r\n        :rtype: bool\r\n        \"\"\"\r\n        i, j = 0, 0\r\n        while i < len(s) and j < len(t):\r\n            if s[i] == t[j]:\r\n                i += 1\r\n            j += 1\r\n        return i == len(s) ",
            "Contributor": "bwakasa",
            "Difficulty": "easy",
            "Link": "https://leetcode.com/problems/is-subsequence",
            "Name": "Is Subsequence",
            "Note": "",
            "Session": "",
            "Solution": "is_subsequence.py",
            "SubmitDate": "Sun May 19 2019 21:53:58 GMT-0700 (Pacific Daylight Time)"
        },
        "-LfOVso0r1fHzbfE1tX_": {
            "Code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    for (int t = 1; t <= n; ++t) {\n        char number[256];\n        char source[256];\n        char dest[256];\n        scanf(\"%s %s %s\", number, source, dest);\n        \n        int source_len = strlen(source);\n        int dest_len = strlen(dest);\n        int number_len = strlen(number);\n\n        // make mapping source\n        map<char, int> source_to_int;\n        for (int i = source_len - 1; i >= 0; --i) {\n            source_to_int[source[i]] = i;\n        }\n\n        // make mapping dest \n        map<int, char> int_to_dest;\n        for (int i = dest_len - 1; i >= 0; --i) {\n            int_to_dest[i] = dest[i];\n        }\n\n        vector<int> converted;\n\n        // get sum\n        int sum = 0;\n        int power = 0;\n        for (int i = number_len - 1; i >= 0; --i) {\n            sum += source_to_int[number[i]] * pow(source_len, power);\n            ++power; \n        }\n\n        // translate\n        while (sum != 0) {\n            converted.push_back(sum % dest_len);\n            sum = sum - (sum % dest_len);\n            sum /= dest_len;\n        }\n\n        // output\n        cout << \"Case #\" << t << \": \";\n        for (int i = converted.size() - 1; i >= 0; --i) {\n            cout << int_to_dest[converted[i]];\n        }\n        cout << endl;\n        \n    }\n    return 0;\n}\n\n",
            "Contributor": "jtuyls",
            "Difficulty": "easy",
            "Link": "https://open.kattis.com/problems/aliennumbers",
            "Name": "Alien Numbers",
            "Note": "It's all about that base. ",
            "Session": "",
            "Solution": "main.cpp",
            "SubmitDate": "Tue May 21 2019 01:30:38 GMT-0700 (PDT)"
        },
        "-LfQiF9Q-JcXSgI68ZNl": {
            "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (HackerRank) longest-common-subsequence\n// Title: The Longest Common Subsequence\n// Link: https://www.hackerrank.com/challenges/dynamic-programming-classics-the-longest-common-subsequence/\n// Idea: Classic DP problem\n// Difficulty: easy\n// Tags: dp\n'use strict';\n\nconst fs = require('fs');\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf-8');\n\nlet inputString = '';\nlet currentLine = 0;\n\nprocess.stdin.on('data', inputStdin => {\n    inputString += inputStdin;\n});\n\nprocess.stdin.on('end', _ => {\n    inputString = inputString.replace(/\\s*$/, '')\n        .split('\\n')\n        .map(str => str.replace(/\\s*$/, ''));\n\n    main();\n});\n\nfunction readLine() {\n    return inputString[currentLine++];\n}\n\n// Complete the longestCommonSubsequence function below.\nfunction longestCommonSubsequence(a, b) {\n    let an = a.length,\n        bn = b.length;\n    let dp = [];\n    for (let i = 0; i <= an; ++i) dp.push(new Array(bn + 1));\n\n    // Fill out the dp table with the lengths\n    for (let i = 0; i <= an; ++i) {\n        for (let j = 0; j <= bn; ++j) {\n            if (i == 0 || j == 0) {\n                dp[i][j] = 0;\n            } else if (a[i - 1] == b[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);\n            }\n        }\n    }\n\n    // Backtrack through the table to find the actual string\n    let i = an,\n        j = bn;\n    let chars = [];\n    while (i > 0 && j > 0) {\n        if (a[i - 1] == b[j - 1]) {\n            chars.push(a[i - 1]);\n            --i;\n            --j;\n        } else if (dp[i][j] == dp[i - 1][j]) {\n            --i;\n        } else {\n            --j;\n        }\n    }\n    chars.reverse();\n\n    return chars;\n}\n\nfunction main() {\n    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);\n    const nm = readLine().split(' ');\n    const n = parseInt(nm[0], 10);\n    const m = parseInt(nm[1], 10);\n    const a = readLine().split(' ').map(aTemp => parseInt(aTemp, 10));\n    const b = readLine().split(' ').map(bTemp => parseInt(bTemp, 10));\n    let result = longestCommonSubsequence(a, b);\n    ws.write(result.join(\" \") + \"\\n\");\n    ws.end();\n}\n",
            "Contributor": "btjanaka",
            "Difficulty": "easy",
            "Link": "http://www.hackerrank.com/challenges/dynamic-programming-classics-the-longest-common-subsequence",
            "Name": "Longest Common Subsequence",
            "Note": "Classic DP problem",
            "Session": "",
            "Solution": "longest-common-subsequence.js",
            "SubmitDate": "Tue May 21 2019 11:48:16 GMT-0700 (Pacific Daylight Time)"
        },
        "-LfSHoq8tiKepo66WKA6": {
            "Code": "class Solution:\r\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\r\n        res = ''\r\n        count = 0\r\n        for i in range(len(S)-1,-1,-1):\r\n            if S[i]!=\"-\":\r\n                if count == K:\r\n                    count = 1\r\n                    res =  \"-\" +res\r\n                    res = S[i].upper() + res\r\n                else:\r\n                    res = S[i].upper() + res\r\n                    count+=1\r\n        return res",
            "Contributor": "junliw1",
            "Difficulty": "easy",
            "Link": "https://leetcode.com/problems/license-key-formatting",
            "Name": "Licence key formatting",
            "Note": "",
            "Session": "",
            "Solution": "482.py",
            "SubmitDate": "Tue May 21 2019 19:07:42 GMT-0700 (Pacific Daylight Time)"
        },
        "-LfSIGRrLvM6cfMbUdDE": {
            "Code": "class Solution:\r\n    def longestPalindrome(self, s: str) -> str:\r\n        l = len(s)\r\n        M = [[0]*l for x in range(l)]\r\n        maximum = 0\r\n        ans = ''\r\n        for i in range(l-1,-1,-1):\r\n            for j in range(l-1,-1,-1):\r\n                if (i==j):\r\n                    M[i][j] = 1\r\n                    if (M[i][j] and (j-i+1>maximum)):\r\n                        ans = s[i:j+1]\r\n                        maximum = j-i+1\r\n                if (i+1==j):\r\n                    M[i][j] = s[i]==s[j]\r\n                    if (M[i][j] and (j-i+1>maximum)):\r\n                        ans = s[i:j+1]\r\n                        maximum = j-i+1\r\n\r\n                elif (j>i):\r\n                    M[i][j] = (M[i+1][j-1]) & (s[i] == s[j])\r\n                    if (M[i][j] and (j-i+1>maximum)):\r\n                        ans = s[i:j+1]\r\n                        maximum = j-i+1\r\n\r\n        return ans\r\n                    ",
            "Contributor": "junliw1",
            "Difficulty": "med",
            "Link": "https://leetcode.com/problems/longest-palindromic-substring",
            "Name": "Longest Palindromic Substring",
            "Note": "",
            "Session": "",
            "Solution": "5.py",
            "SubmitDate": "Tue May 21 2019 19:09:39 GMT-0700 (Pacific Daylight Time)"
        },
        "-LfSInxmVAI6RMdM0miL": {
            "Code": "import math\r\nt = int(input())\r\nfor z in range(t):\r\n    n = int(input())\r\n    arr = []\r\n    for j in range(n):\r\n        a,b = [int(x) for x in input().split()]\r\n        arr.append((a,b))\r\n    res = 1\r\n    valid = set()\r\n    for i in range(len(arr)):\r\n        for j in range(i,len(arr)):\r\n            if (math.copysign(1,arr[i][0]-arr[j][0]) ==(math.copysign(1,arr[i][1]-arr[j][1]))):\r\n                continue\r\n            top = abs(arr[i][0]-arr[j][0])\r\n            bot = abs(arr[i][1]-arr[j][1])\r\n            if (top==0 or bot ==0):\r\n                continue\r\n            g = math.gcd(top,bot)\r\n            R =  (top/g,bot/g)\r\n            R2 = (bot/g,top/g)\r\n            # if ((R in valid) or (R2 in valid)):\r\n                # continue\r\n            # else:\r\n            valid.add(R)\r\n    res+= len(valid)\r\n\r\n\r\n    print(\"Case #%d: %d\" %(z+1,res))",
            "Contributor": "junliw1",
            "Difficulty": "hard",
            "Link": "https://codingcompetitions.withgoogle.com/codejam/round/0000000000051679/0000000000146183",
            "Name": "New Elements Part1",
            "Note": "",
            "Session": "",
            "Solution": "R2_A.py",
            "SubmitDate": "Tue May 21 2019 19:12:00 GMT-0700 (Pacific Daylight Time)"
        },
        "-LfSk1zx8VVBR_hIqFgH": {
            "Code": "T = int(raw_input())\r\ndef opt_loc_1d(r):\r\n    left = 0\r\n    right = sum(r)\r\n    best_total = 10**10\r\n    cur_total = sum((i+1)*n for i,n in enumerate(r))\r\n    for i in range(len(r)):\r\n        # update current total\r\n        cur_total-=right\r\n        cur_total+=left\r\n        left+=r[i]\r\n        right-=r[i]\r\n        best_total = min(best_total,cur_total)\r\n    return best_total\r\n\r\nfor case in range(T):\r\n    x,y = map(int,raw_input().split())\r\n    dy = []\r\n    dx = [0]*x\r\n    for i in range(y):\r\n        row = list(map(int,raw_input().split()))\r\n        dy.append(sum(row))\r\n        dx = [a+b for a,b in zip(dx,row)]\r\n    print(\"{} blocks\".format(opt_loc_1d(dy)+opt_loc_1d(dx)))\r\n",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://open.kattis.com/contests/y6ycsy/problems/pizza",
            "Name": "Pizza Delivery",
            "Note": "",
            "Session": "",
            "Solution": "pizzadelivery.py",
            "SubmitDate": "Tue May 21 2019 21:15:21 GMT-0700 (Pacific Daylight Time)"
        },
        "-LfSl1DzdMjzu5N9W8Cy": {
            "Code": "from collections import defaultdict\r\nm,u,d = raw_input().split()\r\nd = int(d)\r\nm = int(float(m)*100)\r\nu = int(float(u)*30)\r\n\r\ndrinks = []\r\nfor i in range(d):\r\n    name,alc,sz,cost = raw_input().split()\r\n    alc = int(alc)\r\n    alc*=[30,15,10][int(sz[-1])-1]\r\n    cost = int(float(cost)*100)\r\n    drinks.append([name,alc,cost])\r\n\r\ndp = [[None for i in range(m+1)] for j in range(u+1)]\r\ndp[u][m] = (\"\",(-1,-1))\r\nfor name,alc,cost in drinks:\r\n    for i in range(u,-1,-1):\r\n        if i - alc < 0:\r\n            break\r\n        for j in range(m,-1,-1):\r\n            if j - cost < 0:\r\n                break\r\n            if dp[i][j] and not dp[i-alc][j-cost]:\r\n                dp[i-alc][j-cost] = (name,(i,j))\r\nif dp[0][0]:\r\n    cur = dp[0][0]\r\n    result = defaultdict(int)\r\n    while(cur[0]):\r\n        result[cur[0]]+=1\r\n        i,j = cur[1]\r\n        cur = dp[i][j]\r\n    print(\"\\n\".join([\"{} {}\".format(k,result[k]) for k in result]))\r\nelse:\r\n    print(\"IMPOSSIBLE\")",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://open.kattis.com/contests/y6ycsy/problems/drinkresponsibly",
            "Name": "Drink Responsibly",
            "Note": "",
            "Session": "",
            "Solution": "drinkresponsibly.py",
            "SubmitDate": "Tue May 21 2019 21:19:40 GMT-0700 (Pacific Daylight Time)"
        },
        "-LfSm5m-f0NgZMLJSW9P": {
            "Code": "import heapq\r\nfrom collections import defaultdict\r\nR,N,A,B,X = map(int,raw_input().split())\r\nwalls = set(map(int,raw_input().split()))\r\n\r\nrow_sizes = list(range(R,R*2))\r\nrow_sizes+=row_sizes[-2::-1]\r\n\r\ng = defaultdict(set)\r\ncur = 1\r\nfor i in range(len(row_sizes)):\r\n    trs = row_sizes[i]\r\n    for j in range(trs):\r\n        if cur not in walls:\r\n            to_join = []\r\n            if i != len(row_sizes)-1:\r\n                if row_sizes[i] < row_sizes[i+1] or j != trs-1:\r\n                    to_join.append(cur+trs)\r\n                if row_sizes[i] < row_sizes[i+1] or j != 0:\r\n                    adj = cur+trs+(1 if row_sizes[i] < row_sizes[i+1] else -1)\r\n                    to_join.append(adj)\r\n            if j < trs-1:\r\n                to_join.append(cur+1)\r\n            for n in to_join:\r\n                if n not in walls:\r\n                    g[cur].add(n)\r\n                    g[n].add(cur)\r\n        cur+=1\r\n\r\nq = [(0,A)]\r\nvisited = set()\r\ndt = 0\r\nwhile len(q) > 0:\r\n    dt,cur = heapq.heappop(q)\r\n    if dt > N:\r\n        break\r\n    if cur == B:\r\n        print(\"{}\".format(dt))\r\n        exit()\r\n    if cur not in visited:\r\n        for child in g[cur]:\r\n            if child not in visited:\r\n                heapq.heappush(q,(dt+1,child))\r\n        visited.add(cur)        \r\nprint(\"No\")",
            "Contributor": "craut",
            "Difficulty": "med",
            "Link": "https://open.kattis.com/contests/y6ycsy/problems/honeyheist",
            "Name": "Honey Heist ",
            "Note": "",
            "Session": "",
            "Solution": "honeyheist.py",
            "SubmitDate": "Tue May 21 2019 21:24:21 GMT-0700 (Pacific Daylight Time)"
        },
        "-LfvneNsV1A5MZ9z-WDE": {
            "Code": "#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n# Complete the pylons function below.\ndef pylons(k, arr):\n    total = 0\n    i = 0\n    # find first index\n    first_idx = -1\n    while (i < k):\n        print(\"in while\")\n        if (arr[i] == 1):\n            first_idx = i\n        i += 1\n\n    if first_idx == -1: return -1\n    print(\"first index found\", first_idx)\n    idx = first_idx + 1\n    total += 1\n    while idx + k <= len(arr):\n        last_one = -1 \n        for j in range(idx, min(idx + 2 * k - 1, len(arr))):\n            if arr[j] == 1:\n                last_one = j\n            \n        print('last one', last_one)\n        if last_one == -1:\n            return -1\n\n        total += 1\n        idx = last_one + 1 \n\n    return total \n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    nk = input().split()\n\n    n = int(nk[0])\n\n    k = int(nk[1])\n\n    arr = list(map(int, input().rstrip().split()))\n\n    result = pylons(k, arr)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()\n",
            "Contributor": "jtuyls",
            "Difficulty": "med",
            "Link": "https://www.hackerrank.com/challenges/pylons/problem",
            "Name": "Goodland Electricity",
            "Note": "Greedy ",
            "Session": "",
            "Solution": "main.py",
            "SubmitDate": "Mon May 27 2019 17:19:45 GMT-0700 (PDT)"
        },
        "-Lfvqb3tNpURvC32qZvM": {
            "Code": "#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n# Complete the fibonacciModified function below.\ndef fibonacciModified(t1, t2, n):\n    f_minus_one, f_minus_two = t2, t1 \n    cur_fib = f_minus_two + f_minus_one ** 2\n    for i in range(3, n + 1):\n        cur_fib = f_minus_two + f_minus_one ** 2\n        f_minus_two = f_minus_one\n        f_minus_one = cur_fib\n    return cur_fib\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    t1T2n = input().split()\n\n    t1 = int(t1T2n[0])\n\n    t2 = int(t1T2n[1])\n\n    n = int(t1T2n[2])\n\n    result = fibonacciModified(t1, t2, n)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()\n",
            "Contributor": "jtuyls",
            "Difficulty": "med",
            "Link": "https://www.hackerrank.com/challenges/fibonacci-modified/problem",
            "Name": "Fibonacci Modified",
            "Note": "DP",
            "Session": "",
            "Solution": "main.py",
            "SubmitDate": "Mon May 27 2019 17:32:38 GMT-0700 (PDT)"
        },
        "-LfvyEXeUl8zUbMk8rOY": {
            "Code": "#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\nfrom collections import defaultdict \nimport queue\n\n# Complete the bfs function below.\ndef bfs(n, m, edges, s):\n    graph = defaultdict(list)\n    \n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n    \n    print('graph', graph)\n    D = [-1 for i in range(n + 1)]\n    D[s] = 0\n\n    visited = set()\n    q = queue.Queue()\n    q.put(s)\n    visited.add(s)\n    while not q.empty():\n        cur = q.get()\n        for adj in graph[cur]:\n            if adj not in visited:\n                visited.add(adj) \n                D[adj] = D[cur] + 6\n                print(D[adj])\n                print()\n                q.put(adj)\n\n    \n    return [D[i] for i in range(len(D)) if i != s and i != 0] \n\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    q = int(input())\n\n    for q_itr in range(q):\n        nm = input().split()\n\n        n = int(nm[0])\n\n        m = int(nm[1])\n\n        edges = []\n\n        for _ in range(m):\n            edges.append(list(map(int, input().rstrip().split())))\n\n        s = int(input())\n\n        result = bfs(n, m, edges, s)\n\n        fptr.write(' '.join(map(str, result)))\n        fptr.write('\\n')\n\n    fptr.close()\n",
            "Contributor": "jtuyls",
            "Difficulty": "med",
            "Link": "https://www.hackerrank.com/challenges/bfsshortreach/problem",
            "Name": "Breadth First Search: Shortest Reach ",
            "Note": "BFS",
            "Session": "",
            "Solution": "main.py",
            "SubmitDate": "Mon May 27 2019 18:05:58 GMT-0700 (PDT)"
        },
        "-Lg0E93ft0rhuX8hdBW9": {
            "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Kattis) freefood\n// Title: Free Food\n// Link: https://open.kattis.com/problems/freefood\n// Idea: Store an array telling if each day has free food and mark the days as\n// you go through the input.\n// Difficulty: easy\n// Tags: arrays\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\nbool serve[366];\n\nint main() {\n  int n;\n  while (GET(n) > 0) {\n    memset(serve, false, sizeof(serve));\n    for (int i = 0; i < n; ++i) {\n      int s, t;\n      GET(s);\n      GET(t);\n      for (int j = s; j <= t; ++j) {\n        serve[j] = true;\n      }\n    }\n\n    printf(\"%d\\n\", accumulate(serve + 1, serve + 366, 0));\n  }\n  return 0;\n}\n",
            "Contributor": "btjanaka",
            "Difficulty": "easy",
            "Link": "https://open.kattis.com/problems/freefood",
            "Name": "Free Food",
            "Note": "",
            "Session": "",
            "Solution": "freefood.cpp",
            "SubmitDate": "Tue May 28 2019 18:37:58 GMT-0700 (Pacific Daylight Time)"
        },
        "-Lg0Er9fD8WFl9BLEv3J": {
            "Code": "// Author: btjanaka (Bryon Tjanaka)\n// Problem: (Kattis) cake\n// Idea: Greedily divide the cake - it should always be possible to divide\n// without leftovers\n#include <bits/stdc++.h>\n#define GET(x) scanf(\"%d\", &x)\n#define GED(x) scanf(\"%lf\", &x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\nint main() {\n  int p, q, n;\n  while (GET(p) > 0) {\n    GET(q);\n    GET(n);\n    vector<vector<int>> cake(p + 1);\n    for (int i = 0; i < n; ++i) {\n      int r, c;\n      GET(r);\n      GET(c);\n      cake[r].push_back(c);\n    }\n\n    // make sure to order the columns in each row\n    for (int i = 1; i <= p; ++i) {\n      sort(cake[i].begin(), cake[i].end());\n    }\n\n    // remove empty rows at back\n    while (cake.back().empty()) cake.pop_back();\n\n    // divide cake\n    vector<vector<int>> res;\n    for (int r = 1; r < cake.size(); ++r) {\n      if (!cake[r].empty()) {\n        int r0 = res.size() == 0 ? 1 : res.back()[2] + 1;\n        int rf = r == cake.size() - 1 ? p : r;\n        int c0, cf;\n        for (int i = 0; i < cake[r].size(); ++i) {\n          c0 = i == 0 ? 1 : res.back()[3] + 1;\n          cf = i == cake[r].size() - 1 ? q : cake[r][i];\n          res.push_back({r0, c0, rf, cf});\n        }\n      }\n    }\n\n    for (const vector<int>& ans : res) {\n      printf(\"%d %d %d %d\\n\", ans[0], ans[1], ans[2], ans[3]);\n    }\n    printf(\"0\\n\");\n  }\n  return 0;\n}\n",
            "Contributor": "btjanaka",
            "Difficulty": "med",
            "File": "",
            "Link": "https://open.kattis.com/problems/cake",
            "Name": "Cake",
            "Note": "It's a piece of cake :p",
            "Session": "",
            "Solution": "cake.cpp",
            "SubmitDate": "Tue May 28 2019 18:41:03 GMT-0700 (Pacific Daylight Time)"
        }
    }
}
